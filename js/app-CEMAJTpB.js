function Gm(r, t, e) {
    return Math.max(r, Math.min(t, e))
}
class B0 {
    constructor()
    {
        this.isRunning = !1,
        this.value = 0,
        this.from = 0,
        this.to = 0,
        this.currentTime = 0
    }
    advance(t)
    {
        var e;
        if (!this.isRunning)
            return;
        let n = !1;
        if (this.duration && this.easing) {
            this.currentTime += t;
            const i = Gm(0, this.currentTime / this.duration, 1);
            n = i >= 1;
            const s = n ? 1 : this.easing(i);
            this.value = this.from + (this.to - this.from) * s
        } else
            this.lerp ? (this.value = function(s, o, a, l) {
                return function(h, u, d) {
                    return (1 - d) * h + d * u
                }(s, o, 1 - Math.exp(-a * l))
            }(this.value, this.to, 60 * this.lerp, t), Math.round(this.value) === this.to && (this.value = this.to, n = !0)) : (this.value = this.to, n = !0);
        n && this.stop(),
        (e = this.onUpdate) === null || e === void 0 || e.call(this, this.value, n)
    }
    stop()
    {
        this.isRunning = !1
    }
    fromTo(t, e, {lerp: n, duration: i, easing: s, onStart: o, onUpdate: a})
    {
        this.from = this.value = t,
        this.to = e,
        this.lerp = n,
        this.duration = i,
        this.easing = s,
        this.currentTime = 0,
        this.isRunning = !0,
        o == null || o(),
        this.onUpdate = a
    }
}
class k0 {
    constructor(t, e, {autoResize: n=!0, debounce: i=250}={})
    {
        this.wrapper = t,
        this.content = e,
        this.width = 0,
        this.height = 0,
        this.scrollHeight = 0,
        this.scrollWidth = 0,
        this.resize = () => {
            this.onWrapperResize(),
            this.onContentResize()
        },
        this.onWrapperResize = () => {
            this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
        },
        this.onContentResize = () => {
            this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
        },
        n && (this.debouncedResize = function(o, a) {
            let l;
            return function(...c) {
                let h = this;
                clearTimeout(l),
                l = setTimeout(() => {
                    l = void 0,
                    o.apply(h, c)
                }, a)
            }
        }(this.resize, i), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)),
        this.resize()
    }
    destroy()
    {
        var t,
            e;
        (t = this.wrapperResizeObserver) === null || t === void 0 || t.disconnect(),
        (e = this.contentResizeObserver) === null || e === void 0 || e.disconnect(),
        this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1)
    }
    get limit()
    {
        return {
            x: this.scrollWidth - this.width,
            y: this.scrollHeight - this.height
        }
    }
}
class Wm {
    constructor()
    {
        this.events = {}
    }
    emit(t, ...e)
    {
        var n;
        let i = this.events[t] || [];
        for (let s = 0, o = i.length; s < o; s++)
            (n = i[s]) === null || n === void 0 || n.call(i, ...e)
    }
    on(t, e)
    {
        var n;
        return !((n = this.events[t]) === null || n === void 0) && n.push(e) || (this.events[t] = [e]), () => {
            var i;
            this.events[t] = (i = this.events[t]) === null || i === void 0 ? void 0 : i.filter(s => e !== s)
        }
    }
    off(t, e)
    {
        var n;
        this.events[t] = (n = this.events[t]) === null || n === void 0 ? void 0 : n.filter(i => e !== i)
    }
    destroy()
    {
        this.events = {}
    }
}
const Mf = 100 / 6,
    Ts = {
        passive: !1
    };
class H0 {
    constructor(t, e={
        wheelMultiplier: 1,
        touchMultiplier: 1
    })
    {
        this.element = t,
        this.options = e,
        this.touchStart = {
            x: 0,
            y: 0
        },
        this.lastDelta = {
            x: 0,
            y: 0
        },
        this.window = {
            width: 0,
            height: 0
        },
        this.emitter = new Wm,
        this.onTouchStart = n => {
            const {clientX: i, clientY: s} = n.targetTouches ? n.targetTouches[0] : n;
            this.touchStart.x = i,
            this.touchStart.y = s,
            this.lastDelta = {
                x: 0,
                y: 0
            },
            this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: n
            })
        },
        this.onTouchMove = n => {
            const {clientX: i, clientY: s} = n.targetTouches ? n.targetTouches[0] : n,
                o = -(i - this.touchStart.x) * this.options.touchMultiplier,
                a = -(s - this.touchStart.y) * this.options.touchMultiplier;
            this.touchStart.x = i,
            this.touchStart.y = s,
            this.lastDelta = {
                x: o,
                y: a
            },
            this.emitter.emit("scroll", {
                deltaX: o,
                deltaY: a,
                event: n
            })
        },
        this.onTouchEnd = n => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: n
            })
        },
        this.onWheel = n => {
            let {deltaX: i, deltaY: s, deltaMode: o} = n;
            i *= o === 1 ? Mf : o === 2 ? this.window.width : 1,
            s *= o === 1 ? Mf : o === 2 ? this.window.height : 1,
            i *= this.options.wheelMultiplier,
            s *= this.options.wheelMultiplier,
            this.emitter.emit("scroll", {
                deltaX: i,
                deltaY: s,
                event: n
            })
        },
        this.onWindowResize = () => {
            this.window = {
                width: window.innerWidth,
                height: window.innerHeight
            }
        },
        window.addEventListener("resize", this.onWindowResize, !1),
        this.onWindowResize(),
        this.element.addEventListener("wheel", this.onWheel, Ts),
        this.element.addEventListener("touchstart", this.onTouchStart, Ts),
        this.element.addEventListener("touchmove", this.onTouchMove, Ts),
        this.element.addEventListener("touchend", this.onTouchEnd, Ts)
    }
    on(t, e)
    {
        return this.emitter.on(t, e)
    }
    destroy()
    {
        this.emitter.destroy(),
        window.removeEventListener("resize", this.onWindowResize, !1),
        this.element.removeEventListener("wheel", this.onWheel, Ts),
        this.element.removeEventListener("touchstart", this.onTouchStart, Ts),
        this.element.removeEventListener("touchmove", this.onTouchMove, Ts),
        this.element.removeEventListener("touchend", this.onTouchEnd, Ts)
    }
}
class V0 {
    constructor({wrapper: t=window, content: e=document.documentElement, eventsTarget: n=t, smoothWheel: i=!0, syncTouch: s=!1, syncTouchLerp: o=.075, touchInertiaMultiplier: a=35, duration: l, easing: c=y => Math.min(1, 1.001 - Math.pow(2, -10 * y)), lerp: h=.1, infinite: u=!1, orientation: d="vertical", gestureOrientation: f="vertical", touchMultiplier: m=1, wheelMultiplier: _=1, autoResize: g=!0, prevent: p, virtualScroll: x, __experimental__naiveDimensions: v=!1}={})
    {
        this._isScrolling = !1,
        this._isStopped = !1,
        this._isLocked = !1,
        this._preventNextNativeScrollEvent = !1,
        this._resetVelocityTimeout = null,
        this.time = 0,
        this.userData = {},
        this.lastVelocity = 0,
        this.velocity = 0,
        this.direction = 0,
        this.animate = new B0,
        this.emitter = new Wm,
        this.onPointerDown = y => {
            y.button === 1 && this.reset()
        },
        this.onVirtualScroll = y => {
            if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(y) === !1)
                return;
            const {deltaX: C, deltaY: A, event: T} = y;
            if (this.emitter.emit("virtual-scroll", {
                deltaX: C,
                deltaY: A,
                event: T
            }), T.ctrlKey)
                return;
            const R = T.type.includes("touch"),
                E = T.type.includes("wheel");
            if (this.isTouching = T.type === "touchstart" || T.type === "touchmove", this.options.syncTouch && R && T.type === "touchstart" && !this.isStopped && !this.isLocked)
                return void this.reset();
            const M = C === 0 && A === 0,
                D = this.options.gestureOrientation === "vertical" && A === 0 || this.options.gestureOrientation === "horizontal" && C === 0;
            if (M || D)
                return;
            let I = T.composedPath();
            I = I.slice(0, I.indexOf(this.rootElement));
            const k = this.options.prevent;
            if (I.find(H => {
                var V,
                    nt,
                    P,
                    ct,
                    Ut;
                return H instanceof HTMLElement && (typeof k == "function" && (k == null ? void 0 : k(H)) || ((V = H.hasAttribute) === null || V === void 0 ? void 0 : V.call(H, "data-lenis-prevent")) || R && ((nt = H.hasAttribute) === null || nt === void 0 ? void 0 : nt.call(H, "data-lenis-prevent-touch")) || E && ((P = H.hasAttribute) === null || P === void 0 ? void 0 : P.call(H, "data-lenis-prevent-wheel")) || ((ct = H.classList) === null || ct === void 0 ? void 0 : ct.contains("lenis")) && !(!((Ut = H.classList) === null || Ut === void 0) && Ut.contains("lenis-stopped")))
            }))
                return;
            if (this.isStopped || this.isLocked)
                return void T.preventDefault();
            if (!(this.options.syncTouch && R || this.options.smoothWheel && E))
                return this.isScrolling = "native", void this.animate.stop();
            T.preventDefault();
            let $ = A;
            this.options.gestureOrientation === "both" ? $ = Math.abs(A) > Math.abs(C) ? A : C : this.options.gestureOrientation === "horizontal" && ($ = C);
            const j = R && this.options.syncTouch,
                G = R && T.type === "touchend" && Math.abs($) > 5;
            G && ($ = this.velocity * this.options.touchInertiaMultiplier),
            this.scrollTo(this.targetScroll + $, Object.assign({
                programmatic: !1
            }, j ? {
                lerp: G ? this.options.syncTouchLerp : 1
            } : {
                lerp: this.options.lerp,
                duration: this.options.duration,
                easing: this.options.easing
            }))
        },
        this.onNativeScroll = () => {
            if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent)
                this._preventNextNativeScrollEvent = !1;
            else if (this.isScrolling === !1 || this.isScrolling === "native") {
                const y = this.animatedScroll;
                this.animatedScroll = this.targetScroll = this.actualScroll,
                this.lastVelocity = this.velocity,
                this.velocity = this.animatedScroll - y,
                this.direction = Math.sign(this.animatedScroll - y),
                this.isScrolling = "native",
                this.emit(),
                this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout(() => {
                    this.lastVelocity = this.velocity,
                    this.velocity = 0,
                    this.isScrolling = !1,
                    this.emit()
                }, 400))
            }
        },
        window.lenisVersion = "1.1.13",
        t && t !== document.documentElement && t !== document.body || (t = window),
        this.options = {
            wrapper: t,
            content: e,
            eventsTarget: n,
            smoothWheel: i,
            syncTouch: s,
            syncTouchLerp: o,
            touchInertiaMultiplier: a,
            duration: l,
            easing: c,
            lerp: h,
            infinite: u,
            gestureOrientation: f,
            orientation: d,
            touchMultiplier: m,
            wheelMultiplier: _,
            autoResize: g,
            prevent: p,
            virtualScroll: x,
            __experimental__naiveDimensions: v
        },
        this.dimensions = new k0(t, e, {
            autoResize: g
        }),
        this.updateClassName(),
        this.targetScroll = this.animatedScroll = this.actualScroll,
        this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1),
        this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1),
        this.virtualScroll = new H0(n, {
            touchMultiplier: m,
            wheelMultiplier: _
        }),
        this.virtualScroll.on("scroll", this.onVirtualScroll)
    }
    destroy()
    {
        this.emitter.destroy(),
        this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1),
        this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1),
        this.virtualScroll.destroy(),
        this.dimensions.destroy(),
        this.cleanUpClassName()
    }
    on(t, e)
    {
        return this.emitter.on(t, e)
    }
    off(t, e)
    {
        return this.emitter.off(t, e)
    }
    setScroll(t)
    {
        this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t
    }
    resize()
    {
        this.dimensions.resize(),
        this.animatedScroll = this.targetScroll = this.actualScroll,
        this.emit()
    }
    emit()
    {
        this.emitter.emit("scroll", this)
    }
    reset()
    {
        this.isLocked = !1,
        this.isScrolling = !1,
        this.animatedScroll = this.targetScroll = this.actualScroll,
        this.lastVelocity = this.velocity = 0,
        this.animate.stop()
    }
    start()
    {
        this.isStopped && (this.isStopped = !1, this.reset())
    }
    stop()
    {
        this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
    }
    raf(t)
    {
        const e = t - (this.time || t);
        this.time = t,
        this.animate.advance(.001 * e)
    }
    scrollTo(t, {offset: e=0, immediate: n=!1, lock: i=!1, duration: s=this.options.duration, easing: o=this.options.easing, lerp: a=this.options.lerp, onStart: l, onComplete: c, force: h=!1, programmatic: u=!0, userData: d}={})
    {
        if (!this.isStopped && !this.isLocked || h) {
            if (typeof t == "string" && ["top", "left", "start"].includes(t))
                t = 0;
            else if (typeof t == "string" && ["bottom", "right", "end"].includes(t))
                t = this.limit;
            else {
                let f;
                if (typeof t == "string" ? f = document.querySelector(t) : t instanceof HTMLElement && (t != null && t.nodeType) && (f = t), f) {
                    if (this.options.wrapper !== window) {
                        const _ = this.rootElement.getBoundingClientRect();
                        e -= this.isHorizontal ? _.left : _.top
                    }
                    const m = f.getBoundingClientRect();
                    t = (this.isHorizontal ? m.left : m.top) + this.animatedScroll
                }
            }
            if (typeof t == "number") {
                if (t += e, t = Math.round(t), this.options.infinite ? u && (this.targetScroll = this.animatedScroll = this.scroll) : t = Gm(0, t, this.limit), t === this.targetScroll)
                    return l == null || l(this), void (c == null || c(this));
                if (this.userData = d ?? {}, n)
                    return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), c == null || c(this), void (this.userData = {});
                u || (this.targetScroll = t),
                this.animate.fromTo(this.animatedScroll, t, {
                    duration: s,
                    easing: o,
                    lerp: a,
                    onStart: () => {
                        i && (this.isLocked = !0),
                        this.isScrolling = "smooth",
                        l == null || l(this)
                    },
                    onUpdate: (f, m) => {
                        this.isScrolling = "smooth",
                        this.lastVelocity = this.velocity,
                        this.velocity = f - this.animatedScroll,
                        this.direction = Math.sign(this.velocity),
                        this.animatedScroll = f,
                        this.setScroll(this.scroll),
                        u && (this.targetScroll = f),
                        m || this.emit(),
                        m && (this.reset(), this.emit(), c == null || c(this), this.userData = {}, this.preventNextNativeScrollEvent())
                    }
                })
            }
        }
    }
    preventNextNativeScrollEvent()
    {
        this._preventNextNativeScrollEvent = !0,
        requestAnimationFrame(() => {
            this._preventNextNativeScrollEvent = !1
        })
    }
    get rootElement()
    {
        return this.options.wrapper === window ? document.documentElement : this.options.wrapper
    }
    get limit()
    {
        return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
    }
    get isHorizontal()
    {
        return this.options.orientation === "horizontal"
    }
    get actualScroll()
    {
        return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
    }
    get scroll()
    {
        return this.options.infinite ? function(e, n) {
            return (e % n + n) % n
        }(this.animatedScroll, this.limit) : this.animatedScroll
    }
    get progress()
    {
        return this.limit === 0 ? 1 : this.scroll / this.limit
    }
    get isScrolling()
    {
        return this._isScrolling
    }
    set isScrolling(t)
    {
        this._isScrolling !== t && (this._isScrolling = t, this.updateClassName())
    }
    get isStopped()
    {
        return this._isStopped
    }
    set isStopped(t)
    {
        this._isStopped !== t && (this._isStopped = t, this.updateClassName())
    }
    get isLocked()
    {
        return this._isLocked
    }
    set isLocked(t)
    {
        this._isLocked !== t && (this._isLocked = t, this.updateClassName())
    }
    get isSmooth()
    {
        return this.isScrolling === "smooth"
    }
    get className()
    {
        let t = "lenis";
        return this.isStopped && (t += " lenis-stopped"), this.isLocked && (t += " lenis-locked"), this.isScrolling && (t += " lenis-scrolling"), this.isScrolling === "smooth" && (t += " lenis-smooth"), t
    }
    updateClassName()
    {
        this.cleanUpClassName(),
        this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim()
    }
    cleanUpClassName()
    {
        this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
    }
} /**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */



const dd = "167",
    Nr = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    },
    Ir = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    },
    G0 = 0,
    Sf = 1,
    W0 = 2,
    Xm = 1,
    X0 = 2,
    ss = 3,
    _s = 0,
    kn = 1,
    wi = 2,
    ps = 0,
    uo = 1,
    Yh = 2,
    Tf = 3,
    Ef = 4,
    Y0 = 5,
    dr = 100,
    $0 = 101,
    q0 = 102,
    K0 = 103,
    j0 = 104,
    Z0 = 200,
    J0 = 201,
    Q0 = 202,
    tx = 203,
    $h = 204,
    qh = 205,
    ex = 206,
    nx = 207,
    ix = 208,
    sx = 209,
    rx = 210,
    ox = 211,
    ax = 212,
    lx = 213,
    cx = 214,
    hx = 0,
    ux = 1,
    dx = 2,
    ac = 3,
    fx = 4,
    px = 5,
    mx = 6,
    gx = 7,
    Ym = 0,
    _x = 1,
    xx = 2,
    Xs = 0,
    vx = 1,
    yx = 2,
    Mx = 3,
    Sx = 4,
    Tx = 5,
    Ex = 6,
    bx = 7,
    bf = "attached",
    wx = "detached",
    $m = 300,
    To = 301,
    Eo = 302,
    Kh = 303,
    jh = 304,
    Rc = 306,
    bo = 1e3,
    Os = 1001,
    lc = 1002,
    Fn = 1003,
    qm = 1004,
    ra = 1005,
    ti = 1006,
    Xl = 1007,
    hs = 1008,
    xs = 1009,
    Km = 1010,
    jm = 1011,
    La = 1012,
    fd = 1013,
    Tr = 1014,
    Ci = 1015,
    ms = 1016,
    pd = 1017,
    md = 1018,
    wo = 1020,
    Zm = 35902,
    Jm = 1021,
    Qm = 1022,
    fi = 1023,
    tg = 1024,
    eg = 1025,
    fo = 1026,
    Ao = 1027,
    gd = 1028,
    _d = 1029,
    ng = 1030,
    xd = 1031,
    vd = 1033,
    Yl = 33776,
    $l = 33777,
    ql = 33778,
    Kl = 33779,
    Zh = 35840,
    Jh = 35841,
    Qh = 35842,
    tu = 35843,
    eu = 36196,
    nu = 37492,
    iu = 37496,
    su = 37808,
    ru = 37809,
    ou = 37810,
    au = 37811,
    lu = 37812,
    cu = 37813,
    hu = 37814,
    uu = 37815,
    du = 37816,
    fu = 37817,
    pu = 37818,
    mu = 37819,
    gu = 37820,
    _u = 37821,
    jl = 36492,
    xu = 36494,
    vu = 36495,
    ig = 36283,
    yu = 36284,
    Mu = 36285,
    Su = 36286,
    Da = 2300,
    Na = 2301,
    Vc = 2302,
    wf = 2400,
    Af = 2401,
    Cf = 2402,
    Ax = 2500,
    Cx = 0,
    sg = 1,
    Tu = 2,
    Rx = 3200,
    Px = 3201,
    yd = 0,
    Lx = 1,
    Us = "",
    Ln = "srgb",
    dn = "srgb-linear",
    Md = "display-p3",
    Pc = "display-p3-linear",
    cc = "linear",
    Ne = "srgb",
    hc = "rec709",
    uc = "p3",
    Fr = 7680,
    Rf = 519,
    Dx = 512,
    Nx = 513,
    Ix = 514,
    rg = 515,
    Fx = 516,
    Ux = 517,
    Ox = 518,
    zx = 519,
    Eu = 35044,
    Pf = "300 es",
    us = 2e3,
    dc = 2001;
let Rr = class {
    addEventListener(t, e)
    {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[t] === void 0 && (n[t] = []),
        n[t].indexOf(e) === -1 && n[t].push(e)
    }
    hasEventListener(t, e)
    {
        if (this._listeners === void 0)
            return !1;
        const n = this._listeners;
        return n[t] !== void 0 && n[t].indexOf(e) !== -1
    }
    removeEventListener(t, e)
    {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[t];
        if (i !== void 0) {
            const s = i.indexOf(e);
            s !== -1 && i.splice(s, 1)
        }
    }
    dispatchEvent(t)
    {
        if (this._listeners === void 0)
            return;
        const n = this._listeners[t.type];
        if (n !== void 0) {
            t.target = this;
            const i = n.slice(0);
            for (let s = 0, o = i.length; s < o; s++)
                i[s].call(this, t);
            t.target = null
        }
    }
}
;
const pn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Lf = 1234567;
const pa = Math.PI / 180,
    Co = 180 / Math.PI;
function Ri() {
    const r = Math.random() * 4294967295 | 0,
        t = Math.random() * 4294967295 | 0,
        e = Math.random() * 4294967295 | 0,
        n = Math.random() * 4294967295 | 0;
    return (pn[r & 255] + pn[r >> 8 & 255] + pn[r >> 16 & 255] + pn[r >> 24 & 255] + "-" + pn[t & 255] + pn[t >> 8 & 255] + "-" + pn[t >> 16 & 15 | 64] + pn[t >> 24 & 255] + "-" + pn[e & 63 | 128] + pn[e >> 8 & 255] + "-" + pn[e >> 16 & 255] + pn[e >> 24 & 255] + pn[n & 255] + pn[n >> 8 & 255] + pn[n >> 16 & 255] + pn[n >> 24 & 255]).toLowerCase()
}
function hn(r, t, e) {
    return Math.max(t, Math.min(e, r))
}
function Sd(r, t) {
    return (r % t + t) % t
}
function Bx(r, t, e, n, i) {
    return n + (r - t) * (i - n) / (e - t)
}
function kx(r, t, e) {
    return r !== t ? (e - r) / (t - r) : 0
}
function ma(r, t, e) {
    return (1 - e) * r + e * t
}
function Hx(r, t, e, n) {
    return ma(r, t, 1 - Math.exp(-e * n))
}
function Vx(r, t=1) {
    return t - Math.abs(Sd(r, t * 2) - t)
}
function Gx(r, t, e) {
    return r <= t ? 0 : r >= e ? 1 : (r = (r - t) / (e - t), r * r * (3 - 2 * r))
}
function Wx(r, t, e) {
    return r <= t ? 0 : r >= e ? 1 : (r = (r - t) / (e - t), r * r * r * (r * (r * 6 - 15) + 10))
}
function Xx(r, t) {
    return r + Math.floor(Math.random() * (t - r + 1))
}
function Yx(r, t) {
    return r + Math.random() * (t - r)
}
function $x(r) {
    return r * (.5 - Math.random())
}
function qx(r) {
    r !== void 0 && (Lf = r);
    let t = Lf += 1831565813;
    return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296
}
function Kx(r) {
    return r * pa
}
function jx(r) {
    return r * Co
}
function Zx(r) {
    return (r & r - 1) === 0 && r !== 0
}
function Jx(r) {
    return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
}
function Qx(r) {
    return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
}
function tv(r, t, e, n, i) {
    const s = Math.cos,
        o = Math.sin,
        a = s(e / 2),
        l = o(e / 2),
        c = s((t + n) / 2),
        h = o((t + n) / 2),
        u = s((t - n) / 2),
        d = o((t - n) / 2),
        f = s((n - t) / 2),
        m = o((n - t) / 2);
    switch (i) {
    case "XYX":
        r.set(a * h, l * u, l * d, a * c);
        break;
    case "YZY":
        r.set(l * d, a * h, l * u, a * c);
        break;
    case "ZXZ":
        r.set(l * u, l * d, a * h, a * c);
        break;
    case "XZX":
        r.set(a * h, l * m, l * f, a * c);
        break;
    case "YXY":
        r.set(l * f, a * h, l * m, a * c);
        break;
    case "ZYZ":
        r.set(l * m, l * f, a * h, a * c);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}
function Ai(r, t) {
    switch (t.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return r / 4294967295;
    case Uint16Array:
        return r / 65535;
    case Uint8Array:
        return r / 255;
    case Int32Array:
        return Math.max(r / 2147483647, -1);
    case Int16Array:
        return Math.max(r / 32767, -1);
    case Int8Array:
        return Math.max(r / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function ye(r, t) {
    switch (t.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return Math.round(r * 4294967295);
    case Uint16Array:
        return Math.round(r * 65535);
    case Uint8Array:
        return Math.round(r * 255);
    case Int32Array:
        return Math.round(r * 2147483647);
    case Int16Array:
        return Math.round(r * 32767);
    case Int8Array:
        return Math.round(r * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const fc = {
    DEG2RAD: pa,
    RAD2DEG: Co,
    generateUUID: Ri,
    clamp: hn,
    euclideanModulo: Sd,
    mapLinear: Bx,
    inverseLerp: kx,
    lerp: ma,
    damp: Hx,
    pingpong: Vx,
    smoothstep: Gx,
    smootherstep: Wx,
    randInt: Xx,
    randFloat: Yx,
    randFloatSpread: $x,
    seededRandom: qx,
    degToRad: Kx,
    radToDeg: jx,
    isPowerOfTwo: Zx,
    ceilPowerOfTwo: Jx,
    floorPowerOfTwo: Qx,
    setQuaternionFromProperEuler: tv,
    normalize: ye,
    denormalize: Ai
};
let St = class og {
        constructor(t=0, e=0)
        {
            og.prototype.isVector2 = !0,
            this.x = t,
            this.y = e
        }
        get width()
        {
            return this.x
        }
        set width(t)
        {
            this.x = t
        }
        get height()
        {
            return this.y
        }
        set height(t)
        {
            this.y = t
        }
        set(t, e)
        {
            return this.x = t, this.y = e, this
        }
        setScalar(t)
        {
            return this.x = t, this.y = t, this
        }
        setX(t)
        {
            return this.x = t, this
        }
        setY(t)
        {
            return this.y = t, this
        }
        setComponent(t, e)
        {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t)
        {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone()
        {
            return new this.constructor(this.x, this.y)
        }
        copy(t)
        {
            return this.x = t.x, this.y = t.y, this
        }
        add(t)
        {
            return this.x += t.x, this.y += t.y, this
        }
        addScalar(t)
        {
            return this.x += t, this.y += t, this
        }
        addVectors(t, e)
        {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        }
        addScaledVector(t, e)
        {
            return this.x += t.x * e, this.y += t.y * e, this
        }
        sub(t)
        {
            return this.x -= t.x, this.y -= t.y, this
        }
        subScalar(t)
        {
            return this.x -= t, this.y -= t, this
        }
        subVectors(t, e)
        {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        }
        multiply(t)
        {
            return this.x *= t.x, this.y *= t.y, this
        }
        multiplyScalar(t)
        {
            return this.x *= t, this.y *= t, this
        }
        divide(t)
        {
            return this.x /= t.x, this.y /= t.y, this
        }
        divideScalar(t)
        {
            return this.multiplyScalar(1 / t)
        }
        applyMatrix3(t)
        {
            const e = this.x,
                n = this.y,
                i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
        }
        min(t)
        {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        }
        max(t)
        {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        }
        clamp(t, e)
        {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        }
        clampScalar(t, e)
        {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
        }
        clampLength(t, e)
        {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor()
        {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }
        ceil()
        {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }
        round()
        {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }
        roundToZero()
        {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
        }
        negate()
        {
            return this.x = -this.x, this.y = -this.y, this
        }
        dot(t)
        {
            return this.x * t.x + this.y * t.y
        }
        cross(t)
        {
            return this.x * t.y - this.y * t.x
        }
        lengthSq()
        {
            return this.x * this.x + this.y * this.y
        }
        length()
        {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength()
        {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize()
        {
            return this.divideScalar(this.length() || 1)
        }
        angle()
        {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        angleTo(t)
        {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (e === 0)
                return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(hn(n, -1, 1))
        }
        distanceTo(t)
        {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t)
        {
            const e = this.x - t.x,
                n = this.y - t.y;
            return e * e + n * n
        }
        manhattanDistanceTo(t)
        {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        }
        setLength(t)
        {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e)
        {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        }
        lerpVectors(t, e, n)
        {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
        }
        equals(t)
        {
            return t.x === this.x && t.y === this.y
        }
        fromArray(t, e=0)
        {
            return this.x = t[e], this.y = t[e + 1], this
        }
        toArray(t=[], e=0)
        {
            return t[e] = this.x, t[e + 1] = this.y, t
        }
        fromBufferAttribute(t, e)
        {
            return this.x = t.getX(e), this.y = t.getY(e), this
        }
        rotateAround(t, e)
        {
            const n = Math.cos(e),
                i = Math.sin(e),
                s = this.x - t.x,
                o = this.y - t.y;
            return this.x = s * n - o * i + t.x, this.y = s * i + o * n + t.y, this
        }
        random()
        {
            return this.x = Math.random(), this.y = Math.random(), this
        }
        *[Symbol.iterator]()
        {
            yield this.x,
            yield this.y
        }
    }
    ,
    re = class ag {
        constructor(t, e, n, i, s, o, a, l, c)
        {
            ag.prototype.isMatrix3 = !0,
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            t !== void 0 && this.set(t, e, n, i, s, o, a, l, c)
        }
        set(t, e, n, i, s, o, a, l, c)
        {
            const h = this.elements;
            return h[0] = t, h[1] = i, h[2] = a, h[3] = e, h[4] = s, h[5] = l, h[6] = n, h[7] = o, h[8] = c, this
        }
        identity()
        {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }
        copy(t)
        {
            const e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
        }
        extractBasis(t, e, n)
        {
            return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        }
        setFromMatrix4(t)
        {
            const e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        }
        multiply(t)
        {
            return this.multiplyMatrices(this, t)
        }
        premultiply(t)
        {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e)
        {
            const n = t.elements,
                i = e.elements,
                s = this.elements,
                o = n[0],
                a = n[3],
                l = n[6],
                c = n[1],
                h = n[4],
                u = n[7],
                d = n[2],
                f = n[5],
                m = n[8],
                _ = i[0],
                g = i[3],
                p = i[6],
                x = i[1],
                v = i[4],
                y = i[7],
                C = i[2],
                A = i[5],
                T = i[8];
            return s[0] = o * _ + a * x + l * C, s[3] = o * g + a * v + l * A, s[6] = o * p + a * y + l * T, s[1] = c * _ + h * x + u * C, s[4] = c * g + h * v + u * A, s[7] = c * p + h * y + u * T, s[2] = d * _ + f * x + m * C, s[5] = d * g + f * v + m * A, s[8] = d * p + f * y + m * T, this
        }
        multiplyScalar(t)
        {
            const e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        }
        determinant()
        {
            const t = this.elements,
                e = t[0],
                n = t[1],
                i = t[2],
                s = t[3],
                o = t[4],
                a = t[5],
                l = t[6],
                c = t[7],
                h = t[8];
            return e * o * h - e * a * c - n * s * h + n * a * l + i * s * c - i * o * l
        }
        invert()
        {
            const t = this.elements,
                e = t[0],
                n = t[1],
                i = t[2],
                s = t[3],
                o = t[4],
                a = t[5],
                l = t[6],
                c = t[7],
                h = t[8],
                u = h * o - a * c,
                d = a * l - h * s,
                f = c * s - o * l,
                m = e * u + n * d + i * f;
            if (m === 0)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const _ = 1 / m;
            return t[0] = u * _, t[1] = (i * c - h * n) * _, t[2] = (a * n - i * o) * _, t[3] = d * _, t[4] = (h * e - i * l) * _, t[5] = (i * s - a * e) * _, t[6] = f * _, t[7] = (n * l - c * e) * _, t[8] = (o * e - n * s) * _, this
        }
        transpose()
        {
            let t;
            const e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        }
        getNormalMatrix(t)
        {
            return this.setFromMatrix4(t).invert().transpose()
        }
        transposeIntoArray(t)
        {
            const e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        }
        setUvTransform(t, e, n, i, s, o, a)
        {
            const l = Math.cos(s),
                c = Math.sin(s);
            return this.set(n * l, n * c, -n * (l * o + c * a) + o + t, -i * c, i * l, -i * (-c * o + l * a) + a + e, 0, 0, 1), this
        }
        scale(t, e)
        {
            return this.premultiply(Gc.makeScale(t, e)), this
        }
        rotate(t)
        {
            return this.premultiply(Gc.makeRotation(-t)), this
        }
        translate(t, e)
        {
            return this.premultiply(Gc.makeTranslation(t, e)), this
        }
        makeTranslation(t, e)
        {
            return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
        }
        makeRotation(t)
        {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
        }
        makeScale(t, e)
        {
            return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
        }
        equals(t)
        {
            const e = this.elements,
                n = t.elements;
            for (let i = 0; i < 9; i++)
                if (e[i] !== n[i])
                    return !1;
            return !0
        }
        fromArray(t, e=0)
        {
            for (let n = 0; n < 9; n++)
                this.elements[n] = t[n + e];
            return this
        }
        toArray(t=[], e=0)
        {
            const n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
        }
        clone()
        {
            return new this.constructor().fromArray(this.elements)
        }
    }
    ;
const Gc = new re;
function lg(r) {
    for (let t = r.length - 1; t >= 0; --t)
        if (r[t] >= 65535)
            return !0;
    return !1
}
function Ia(r) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", r)
}
function ev() {
    const r = Ia("canvas");
    return r.style.display = "block", r
}
const Df = {};
function po(r) {
    r in Df || (Df[r] = !0, console.warn(r))
}
function nv(r, t, e) {
    return new Promise(function(n, i) {
        function s() {
            switch (r.clientWaitSync(t, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case r.WAIT_FAILED:
                i();
                break;
            case r.TIMEOUT_EXPIRED:
                setTimeout(s, e);
                break;
            default:
                n()
            }
        }
        setTimeout(s, e)
    })
}
const Nf = new re().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
    If = new re().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
    Xo = {
        [dn]: {
            transfer: cc,
            primaries: hc,
            luminanceCoefficients: [.2126, .7152, .0722],
            toReference: r => r,
            fromReference: r => r
        },
        [Ln]: {
            transfer: Ne,
            primaries: hc,
            luminanceCoefficients: [.2126, .7152, .0722],
            toReference: r => r.convertSRGBToLinear(),
            fromReference: r => r.convertLinearToSRGB()
        },
        [Pc]: {
            transfer: cc,
            primaries: uc,
            luminanceCoefficients: [.2289, .6917, .0793],
            toReference: r => r.applyMatrix3(If),
            fromReference: r => r.applyMatrix3(Nf)
        },
        [Md]: {
            transfer: Ne,
            primaries: uc,
            luminanceCoefficients: [.2289, .6917, .0793],
            toReference: r => r.convertSRGBToLinear().applyMatrix3(If),
            fromReference: r => r.applyMatrix3(Nf).convertLinearToSRGB()
        }
    },
    iv = new Set([dn, Pc]),
    me = {
        enabled: !0,
        _workingColorSpace: dn,
        get workingColorSpace() {
            return this._workingColorSpace
        },
        set workingColorSpace(r) {
            if (!iv.has(r))
                throw new Error(`Unsupported working color space, "${r}".`);
            this._workingColorSpace = r
        },
        convert: function(r, t, e) {
            if (this.enabled === !1 || t === e || !t || !e)
                return r;
            const n = Xo[t].toReference,
                i = Xo[e].fromReference;
            return i(n(r))
        },
        fromWorkingColorSpace: function(r, t) {
            return this.convert(r, this._workingColorSpace, t)
        },
        toWorkingColorSpace: function(r, t) {
            return this.convert(r, t, this._workingColorSpace)
        },
        getPrimaries: function(r) {
            return Xo[r].primaries
        },
        getTransfer: function(r) {
            return r === Us ? cc : Xo[r].transfer
        },
        getLuminanceCoefficients: function(r, t=this._workingColorSpace) {
            return r.fromArray(Xo[t].luminanceCoefficients)
        }
    };
function mo(r) {
    return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
}
function Wc(r) {
    return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
}
let Ur;
class sv {
    static getDataURL(t)
    {
        if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
            return t.src;
        let e;
        if (t instanceof HTMLCanvasElement)
            e = t;
        else {
            Ur === void 0 && (Ur = Ia("canvas")),
            Ur.width = t.width,
            Ur.height = t.height;
            const n = Ur.getContext("2d");
            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
            e = Ur
        }
        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
    }
    static sRGBToLinear(t)
    {
        if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
            const e = Ia("canvas");
            e.width = t.width,
            e.height = t.height;
            const n = e.getContext("2d");
            n.drawImage(t, 0, 0, t.width, t.height);
            const i = n.getImageData(0, 0, t.width, t.height),
                s = i.data;
            for (let o = 0; o < s.length; o++)
                s[o] = mo(s[o] / 255) * 255;
            return n.putImageData(i, 0, 0), e
        } else if (t.data) {
            const e = t.data.slice(0);
            for (let n = 0; n < e.length; n++)
                e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(mo(e[n] / 255) * 255) : e[n] = mo(e[n]);
            return {
                data: e,
                width: t.width,
                height: t.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
    }
}
let rv = 0;
class cg {
    constructor(t=null)
    {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: rv++
        }),
        this.uuid = Ri(),
        this.data = t,
        this.dataReady = !0,
        this.version = 0
    }
    set needsUpdate(t)
    {
        t === !0 && this.version++
    }
    toJSON(t)
    {
        const e = t === void 0 || typeof t == "string";
        if (!e && t.images[this.uuid] !== void 0)
            return t.images[this.uuid];
        const n = {
                uuid: this.uuid,
                url: ""
            },
            i = this.data;
        if (i !== null) {
            let s;
            if (Array.isArray(i)) {
                s = [];
                for (let o = 0, a = i.length; o < a; o++)
                    i[o].isDataTexture ? s.push(Xc(i[o].image)) : s.push(Xc(i[o]))
            } else
                s = Xc(i);
            n.url = s
        }
        return e || (t.images[this.uuid] = n), n
    }
}
function Xc(r) {
    return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? sv.getDataURL(r) : r.data ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let ov = 0;
class an extends Rr {
    constructor(t=an.DEFAULT_IMAGE, e=an.DEFAULT_MAPPING, n=Os, i=Os, s=ti, o=hs, a=fi, l=xs, c=an.DEFAULT_ANISOTROPY, h=Us)
    {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: ov++
        }),
        this.uuid = Ri(),
        this.name = "",
        this.source = new cg(t),
        this.mipmaps = [],
        this.mapping = e,
        this.channel = 0,
        this.wrapS = n,
        this.wrapT = i,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new St(0, 0),
        this.repeat = new St(1, 1),
        this.center = new St(0, 0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new re,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = h,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.pmremVersion = 0
    }
    get image()
    {
        return this.source.data
    }
    set image(t=null)
    {
        this.source.data = t
    }
    updateMatrix()
    {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
    copy(t)
    {
        return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
    }
    toJSON(t)
    {
        const e = t === void 0 || typeof t == "string";
        if (!e && t.textures[this.uuid] !== void 0)
            return t.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
    }
    dispose()
    {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(t)
    {
        if (this.mapping !== $m)
            return t;
        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
            switch (this.wrapS) {
            case bo:
                t.x = t.x - Math.floor(t.x);
                break;
            case Os:
                t.x = t.x < 0 ? 0 : 1;
                break;
            case lc:
                Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                break
            }
        if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
            case bo:
                t.y = t.y - Math.floor(t.y);
                break;
            case Os:
                t.y = t.y < 0 ? 0 : 1;
                break;
            case lc:
                Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                break
            }
        return this.flipY && (t.y = 1 - t.y), t
    }
    set needsUpdate(t)
    {
        t === !0 && (this.version++, this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(t)
    {
        t === !0 && this.pmremVersion++
    }
}
an.DEFAULT_IMAGE = null;
an.DEFAULT_MAPPING = $m;
an.DEFAULT_ANISOTROPY = 1;
let Pe = class hg {
    constructor(t=0, e=0, n=0, i=1)
    {
        hg.prototype.isVector4 = !0,
        this.x = t,
        this.y = e,
        this.z = n,
        this.w = i
    }
    get width()
    {
        return this.z
    }
    set width(t)
    {
        this.z = t
    }
    get height()
    {
        return this.w
    }
    set height(t)
    {
        this.w = t
    }
    set(t, e, n, i)
    {
        return this.x = t, this.y = e, this.z = n, this.w = i, this
    }
    setScalar(t)
    {
        return this.x = t, this.y = t, this.z = t, this.w = t, this
    }
    setX(t)
    {
        return this.x = t, this
    }
    setY(t)
    {
        return this.y = t, this
    }
    setZ(t)
    {
        return this.z = t, this
    }
    setW(t)
    {
        return this.w = t, this
    }
    setComponent(t, e)
    {
        switch (t) {
        case 0:
            this.x = e;
            break;
        case 1:
            this.y = e;
            break;
        case 2:
            this.z = e;
            break;
        case 3:
            this.w = e;
            break;
        default:
            throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t)
    {
        switch (t) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + t)
        }
    }
    clone()
    {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(t)
    {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this
    }
    add(t)
    {
        return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
    }
    addScalar(t)
    {
        return this.x += t, this.y += t, this.z += t, this.w += t, this
    }
    addVectors(t, e)
    {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
    }
    addScaledVector(t, e)
    {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
    }
    sub(t)
    {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
    }
    subScalar(t)
    {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
    }
    subVectors(t, e)
    {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
    }
    multiply(t)
    {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
    }
    multiplyScalar(t)
    {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
    }
    applyMatrix4(t)
    {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = this.w,
            o = t.elements;
        return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * s, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * s, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * s, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * s, this
    }
    divideScalar(t)
    {
        return this.multiplyScalar(1 / t)
    }
    setAxisAngleFromQuaternion(t)
    {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
    }
    setAxisAngleFromRotationMatrix(t)
    {
        let e,
            n,
            i,
            s;
        const l = t.elements,
            c = l[0],
            h = l[4],
            u = l[8],
            d = l[1],
            f = l[5],
            m = l[9],
            _ = l[2],
            g = l[6],
            p = l[10];
        if (Math.abs(h - d) < .01 && Math.abs(u - _) < .01 && Math.abs(m - g) < .01) {
            if (Math.abs(h + d) < .1 && Math.abs(u + _) < .1 && Math.abs(m + g) < .1 && Math.abs(c + f + p - 3) < .1)
                return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const v = (c + 1) / 2,
                y = (f + 1) / 2,
                C = (p + 1) / 2,
                A = (h + d) / 4,
                T = (u + _) / 4,
                R = (m + g) / 4;
            return v > y && v > C ? v < .01 ? (n = 0, i = .707106781, s = .707106781) : (n = Math.sqrt(v), i = A / n, s = T / n) : y > C ? y < .01 ? (n = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(y), n = A / i, s = R / i) : C < .01 ? (n = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(C), n = T / s, i = R / s), this.set(n, i, s, e), this
        }
        let x = Math.sqrt((g - m) * (g - m) + (u - _) * (u - _) + (d - h) * (d - h));
        return Math.abs(x) < .001 && (x = 1), this.x = (g - m) / x, this.y = (u - _) / x, this.z = (d - h) / x, this.w = Math.acos((c + f + p - 1) / 2), this
    }
    setFromMatrixPosition(t)
    {
        const e = t.elements;
        return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this
    }
    min(t)
    {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
    }
    max(t)
    {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
    }
    clamp(t, e)
    {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
    }
    clampScalar(t, e)
    {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
    }
    clampLength(t, e)
    {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }
    floor()
    {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil()
    {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round()
    {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero()
    {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
    }
    negate()
    {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(t)
    {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }
    lengthSq()
    {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length()
    {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength()
    {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize()
    {
        return this.divideScalar(this.length() || 1)
    }
    setLength(t)
    {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e)
    {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
    }
    lerpVectors(t, e, n)
    {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
    }
    equals(t)
    {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
    }
    fromArray(t, e=0)
    {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
    }
    toArray(t=[], e=0)
    {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
    }
    fromBufferAttribute(t, e)
    {
        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
    }
    random()
    {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }
    *[Symbol.iterator]()
    {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
;
class av extends Rr {
    constructor(t=1, e=1, n={})
    {
        super(),
        this.isRenderTarget = !0,
        this.width = t,
        this.height = e,
        this.depth = 1,
        this.scissor = new Pe(0, 0, t, e),
        this.scissorTest = !1,
        this.viewport = new Pe(0, 0, t, e);
        const i = {
            width: t,
            height: e,
            depth: 1
        };
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: ti,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, n);
        const s = new an(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
        s.flipY = !1,
        s.generateMipmaps = n.generateMipmaps,
        s.internalFormat = n.internalFormat,
        this.textures = [];
        const o = n.count;
        for (let a = 0; a < o; a++)
            this.textures[a] = s.clone(),
            this.textures[a].isRenderTargetTexture = !0;
        this.depthBuffer = n.depthBuffer,
        this.stencilBuffer = n.stencilBuffer,
        this.resolveDepthBuffer = n.resolveDepthBuffer,
        this.resolveStencilBuffer = n.resolveStencilBuffer,
        this.depthTexture = n.depthTexture,
        this.samples = n.samples
    }
    get texture()
    {
        return this.textures[0]
    }
    set texture(t)
    {
        this.textures[0] = t
    }
    setSize(t, e, n=1)
    {
        if (this.width !== t || this.height !== e || this.depth !== n) {
            this.width = t,
            this.height = e,
            this.depth = n;
            for (let i = 0, s = this.textures.length; i < s; i++)
                this.textures[i].image.width = t,
                this.textures[i].image.height = e,
                this.textures[i].image.depth = n;
            this.dispose()
        }
        this.viewport.set(0, 0, t, e),
        this.scissor.set(0, 0, t, e)
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
    copy(t)
    {
        this.width = t.width,
        this.height = t.height,
        this.depth = t.depth,
        this.scissor.copy(t.scissor),
        this.scissorTest = t.scissorTest,
        this.viewport.copy(t.viewport),
        this.textures.length = 0;
        for (let n = 0, i = t.textures.length; n < i; n++)
            this.textures[n] = t.textures[n].clone(),
            this.textures[n].isRenderTargetTexture = !0;
        const e = Object.assign({}, t.texture.image);
        return this.texture.source = new cg(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
    }
    dispose()
    {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Pi extends av {
    constructor(t=1, e=1, n={})
    {
        super(t, e, n),
        this.isWebGLRenderTarget = !0
    }
}
class ug extends an {
    constructor(t=null, e=1, n=1, i=1)
    {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: t,
            width: e,
            height: n,
            depth: i
        },
        this.magFilter = Fn,
        this.minFilter = Fn,
        this.wrapR = Os,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(t)
    {
        this.layerUpdates.add(t)
    }
    clearLayerUpdates()
    {
        this.layerUpdates.clear()
    }
}
class lv extends an {
    constructor(t=null, e=1, n=1, i=1)
    {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: t,
            width: e,
            height: n,
            depth: i
        },
        this.magFilter = Fn,
        this.minFilter = Fn,
        this.wrapR = Os,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
let Wi = class {
        constructor(t=0, e=0, n=0, i=1)
        {
            this.isQuaternion = !0,
            this._x = t,
            this._y = e,
            this._z = n,
            this._w = i
        }
        static slerpFlat(t, e, n, i, s, o, a)
        {
            let l = n[i + 0],
                c = n[i + 1],
                h = n[i + 2],
                u = n[i + 3];
            const d = s[o + 0],
                f = s[o + 1],
                m = s[o + 2],
                _ = s[o + 3];
            if (a === 0) {
                t[e + 0] = l,
                t[e + 1] = c,
                t[e + 2] = h,
                t[e + 3] = u;
                return
            }
            if (a === 1) {
                t[e + 0] = d,
                t[e + 1] = f,
                t[e + 2] = m,
                t[e + 3] = _;
                return
            }
            if (u !== _ || l !== d || c !== f || h !== m) {
                let g = 1 - a;
                const p = l * d + c * f + h * m + u * _,
                    x = p >= 0 ? 1 : -1,
                    v = 1 - p * p;
                if (v > Number.EPSILON) {
                    const C = Math.sqrt(v),
                        A = Math.atan2(C, p * x);
                    g = Math.sin(g * A) / C,
                    a = Math.sin(a * A) / C
                }
                const y = a * x;
                if (l = l * g + d * y, c = c * g + f * y, h = h * g + m * y, u = u * g + _ * y, g === 1 - a) {
                    const C = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
                    l *= C,
                    c *= C,
                    h *= C,
                    u *= C
                }
            }
            t[e] = l,
            t[e + 1] = c,
            t[e + 2] = h,
            t[e + 3] = u
        }
        static multiplyQuaternionsFlat(t, e, n, i, s, o)
        {
            const a = n[i],
                l = n[i + 1],
                c = n[i + 2],
                h = n[i + 3],
                u = s[o],
                d = s[o + 1],
                f = s[o + 2],
                m = s[o + 3];
            return t[e] = a * m + h * u + l * f - c * d, t[e + 1] = l * m + h * d + c * u - a * f, t[e + 2] = c * m + h * f + a * d - l * u, t[e + 3] = h * m - a * u - l * d - c * f, t
        }
        get x()
        {
            return this._x
        }
        set x(t)
        {
            this._x = t,
            this._onChangeCallback()
        }
        get y()
        {
            return this._y
        }
        set y(t)
        {
            this._y = t,
            this._onChangeCallback()
        }
        get z()
        {
            return this._z
        }
        set z(t)
        {
            this._z = t,
            this._onChangeCallback()
        }
        get w()
        {
            return this._w
        }
        set w(t)
        {
            this._w = t,
            this._onChangeCallback()
        }
        set(t, e, n, i)
        {
            return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
        }
        clone()
        {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(t)
        {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
        }
        setFromEuler(t, e=!0)
        {
            const n = t._x,
                i = t._y,
                s = t._z,
                o = t._order,
                a = Math.cos,
                l = Math.sin,
                c = a(n / 2),
                h = a(i / 2),
                u = a(s / 2),
                d = l(n / 2),
                f = l(i / 2),
                m = l(s / 2);
            switch (o) {
            case "XYZ":
                this._x = d * h * u + c * f * m,
                this._y = c * f * u - d * h * m,
                this._z = c * h * m + d * f * u,
                this._w = c * h * u - d * f * m;
                break;
            case "YXZ":
                this._x = d * h * u + c * f * m,
                this._y = c * f * u - d * h * m,
                this._z = c * h * m - d * f * u,
                this._w = c * h * u + d * f * m;
                break;
            case "ZXY":
                this._x = d * h * u - c * f * m,
                this._y = c * f * u + d * h * m,
                this._z = c * h * m + d * f * u,
                this._w = c * h * u - d * f * m;
                break;
            case "ZYX":
                this._x = d * h * u - c * f * m,
                this._y = c * f * u + d * h * m,
                this._z = c * h * m - d * f * u,
                this._w = c * h * u + d * f * m;
                break;
            case "YZX":
                this._x = d * h * u + c * f * m,
                this._y = c * f * u + d * h * m,
                this._z = c * h * m - d * f * u,
                this._w = c * h * u - d * f * m;
                break;
            case "XZY":
                this._x = d * h * u - c * f * m,
                this._y = c * f * u - d * h * m,
                this._z = c * h * m + d * f * u,
                this._w = c * h * u + d * f * m;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
            }
            return e === !0 && this._onChangeCallback(), this
        }
        setFromAxisAngle(t, e)
        {
            const n = e / 2,
                i = Math.sin(n);
            return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        }
        setFromRotationMatrix(t)
        {
            const e = t.elements,
                n = e[0],
                i = e[4],
                s = e[8],
                o = e[1],
                a = e[5],
                l = e[9],
                c = e[2],
                h = e[6],
                u = e[10],
                d = n + a + u;
            if (d > 0) {
                const f = .5 / Math.sqrt(d + 1);
                this._w = .25 / f,
                this._x = (h - l) * f,
                this._y = (s - c) * f,
                this._z = (o - i) * f
            } else if (n > a && n > u) {
                const f = 2 * Math.sqrt(1 + n - a - u);
                this._w = (h - l) / f,
                this._x = .25 * f,
                this._y = (i + o) / f,
                this._z = (s + c) / f
            } else if (a > u) {
                const f = 2 * Math.sqrt(1 + a - n - u);
                this._w = (s - c) / f,
                this._x = (i + o) / f,
                this._y = .25 * f,
                this._z = (l + h) / f
            } else {
                const f = 2 * Math.sqrt(1 + u - n - a);
                this._w = (o - i) / f,
                this._x = (s + c) / f,
                this._y = (l + h) / f,
                this._z = .25 * f
            }
            return this._onChangeCallback(), this
        }
        setFromUnitVectors(t, e)
        {
            let n = t.dot(e) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
        }
        angleTo(t)
        {
            return 2 * Math.acos(Math.abs(hn(this.dot(t), -1, 1)))
        }
        rotateTowards(t, e)
        {
            const n = this.angleTo(t);
            if (n === 0)
                return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i), this
        }
        identity()
        {
            return this.set(0, 0, 0, 1)
        }
        invert()
        {
            return this.conjugate()
        }
        conjugate()
        {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        }
        dot(t)
        {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        }
        lengthSq()
        {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length()
        {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize()
        {
            let t = this.length();
            return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
        }
        multiply(t)
        {
            return this.multiplyQuaternions(this, t)
        }
        premultiply(t)
        {
            return this.multiplyQuaternions(t, this)
        }
        multiplyQuaternions(t, e)
        {
            const n = t._x,
                i = t._y,
                s = t._z,
                o = t._w,
                a = e._x,
                l = e._y,
                c = e._z,
                h = e._w;
            return this._x = n * h + o * a + i * c - s * l, this._y = i * h + o * l + s * a - n * c, this._z = s * h + o * c + n * l - i * a, this._w = o * h - n * a - i * l - s * c, this._onChangeCallback(), this
        }
        slerp(t, e)
        {
            if (e === 0)
                return this;
            if (e === 1)
                return this.copy(t);
            const n = this._x,
                i = this._y,
                s = this._z,
                o = this._w;
            let a = o * t._w + n * t._x + i * t._y + s * t._z;
            if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1)
                return this._w = o, this._x = n, this._y = i, this._z = s, this;
            const l = 1 - a * a;
            if (l <= Number.EPSILON) {
                const f = 1 - e;
                return this._w = f * o + e * this._w, this._x = f * n + e * this._x, this._y = f * i + e * this._y, this._z = f * s + e * this._z, this.normalize(), this
            }
            const c = Math.sqrt(l),
                h = Math.atan2(c, a),
                u = Math.sin((1 - e) * h) / c,
                d = Math.sin(e * h) / c;
            return this._w = o * u + this._w * d, this._x = n * u + this._x * d, this._y = i * u + this._y * d, this._z = s * u + this._z * d, this._onChangeCallback(), this
        }
        slerpQuaternions(t, e, n)
        {
            return this.copy(t).slerp(e, n)
        }
        random()
        {
            const t = 2 * Math.PI * Math.random(),
                e = 2 * Math.PI * Math.random(),
                n = Math.random(),
                i = Math.sqrt(1 - n),
                s = Math.sqrt(n);
            return this.set(i * Math.sin(t), i * Math.cos(t), s * Math.sin(e), s * Math.cos(e))
        }
        equals(t)
        {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        }
        fromArray(t, e=0)
        {
            return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
        }
        toArray(t=[], e=0)
        {
            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        }
        fromBufferAttribute(t, e)
        {
            return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this
        }
        toJSON()
        {
            return this.toArray()
        }
        _onChange(t)
        {
            return this._onChangeCallback = t, this
        }
        _onChangeCallback() {}
        *[Symbol.iterator]()
        {
            yield this._x,
            yield this._y,
            yield this._z,
            yield this._w
        }
    }
    ,
    O = class dg {
        constructor(t=0, e=0, n=0)
        {
            dg.prototype.isVector3 = !0,
            this.x = t,
            this.y = e,
            this.z = n
        }
        set(t, e, n)
        {
            return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this
        }
        setScalar(t)
        {
            return this.x = t, this.y = t, this.z = t, this
        }
        setX(t)
        {
            return this.x = t, this
        }
        setY(t)
        {
            return this.y = t, this
        }
        setZ(t)
        {
            return this.z = t, this
        }
        setComponent(t, e)
        {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t)
        {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone()
        {
            return new this.constructor(this.x, this.y, this.z)
        }
        copy(t)
        {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        }
        add(t)
        {
            return this.x += t.x, this.y += t.y, this.z += t.z, this
        }
        addScalar(t)
        {
            return this.x += t, this.y += t, this.z += t, this
        }
        addVectors(t, e)
        {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        }
        addScaledVector(t, e)
        {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        }
        sub(t)
        {
            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
        }
        subScalar(t)
        {
            return this.x -= t, this.y -= t, this.z -= t, this
        }
        subVectors(t, e)
        {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        }
        multiply(t)
        {
            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
        }
        multiplyScalar(t)
        {
            return this.x *= t, this.y *= t, this.z *= t, this
        }
        multiplyVectors(t, e)
        {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        }
        applyEuler(t)
        {
            return this.applyQuaternion(Ff.setFromEuler(t))
        }
        applyAxisAngle(t, e)
        {
            return this.applyQuaternion(Ff.setFromAxisAngle(t, e))
        }
        applyMatrix3(t)
        {
            const e = this.x,
                n = this.y,
                i = this.z,
                s = t.elements;
            return this.x = s[0] * e + s[3] * n + s[6] * i, this.y = s[1] * e + s[4] * n + s[7] * i, this.z = s[2] * e + s[5] * n + s[8] * i, this
        }
        applyNormalMatrix(t)
        {
            return this.applyMatrix3(t).normalize()
        }
        applyMatrix4(t)
        {
            const e = this.x,
                n = this.y,
                i = this.z,
                s = t.elements,
                o = 1 / (s[3] * e + s[7] * n + s[11] * i + s[15]);
            return this.x = (s[0] * e + s[4] * n + s[8] * i + s[12]) * o, this.y = (s[1] * e + s[5] * n + s[9] * i + s[13]) * o, this.z = (s[2] * e + s[6] * n + s[10] * i + s[14]) * o, this
        }
        applyQuaternion(t)
        {
            const e = this.x,
                n = this.y,
                i = this.z,
                s = t.x,
                o = t.y,
                a = t.z,
                l = t.w,
                c = 2 * (o * i - a * n),
                h = 2 * (a * e - s * i),
                u = 2 * (s * n - o * e);
            return this.x = e + l * c + o * u - a * h, this.y = n + l * h + a * c - s * u, this.z = i + l * u + s * h - o * c, this
        }
        project(t)
        {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        }
        unproject(t)
        {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        }
        transformDirection(t)
        {
            const e = this.x,
                n = this.y,
                i = this.z,
                s = t.elements;
            return this.x = s[0] * e + s[4] * n + s[8] * i, this.y = s[1] * e + s[5] * n + s[9] * i, this.z = s[2] * e + s[6] * n + s[10] * i, this.normalize()
        }
        divide(t)
        {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        }
        divideScalar(t)
        {
            return this.multiplyScalar(1 / t)
        }
        min(t)
        {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        }
        max(t)
        {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        }
        clamp(t, e)
        {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        }
        clampScalar(t, e)
        {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
        }
        clampLength(t, e)
        {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor()
        {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }
        ceil()
        {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }
        round()
        {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }
        roundToZero()
        {
            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
        }
        negate()
        {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }
        dot(t)
        {
            return this.x * t.x + this.y * t.y + this.z * t.z
        }
        lengthSq()
        {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length()
        {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength()
        {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize()
        {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t)
        {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e)
        {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        }
        lerpVectors(t, e, n)
        {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
        }
        cross(t)
        {
            return this.crossVectors(this, t)
        }
        crossVectors(t, e)
        {
            const n = t.x,
                i = t.y,
                s = t.z,
                o = e.x,
                a = e.y,
                l = e.z;
            return this.x = i * l - s * a, this.y = s * o - n * l, this.z = n * a - i * o, this
        }
        projectOnVector(t)
        {
            const e = t.lengthSq();
            if (e === 0)
                return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n)
        }
        projectOnPlane(t)
        {
            return Yc.copy(this).projectOnVector(t), this.sub(Yc)
        }
        reflect(t)
        {
            return this.sub(Yc.copy(t).multiplyScalar(2 * this.dot(t)))
        }
        angleTo(t)
        {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (e === 0)
                return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(hn(n, -1, 1))
        }
        distanceTo(t)
        {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t)
        {
            const e = this.x - t.x,
                n = this.y - t.y,
                i = this.z - t.z;
            return e * e + n * n + i * i
        }
        manhattanDistanceTo(t)
        {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        }
        setFromSpherical(t)
        {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        }
        setFromSphericalCoords(t, e, n)
        {
            const i = Math.sin(e) * t;
            return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
        }
        setFromCylindrical(t)
        {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        }
        setFromCylindricalCoords(t, e, n)
        {
            return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
        }
        setFromMatrixPosition(t)
        {
            const e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this
        }
        setFromMatrixScale(t)
        {
            const e = this.setFromMatrixColumn(t, 0).length(),
                n = this.setFromMatrixColumn(t, 1).length(),
                i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = n, this.z = i, this
        }
        setFromMatrixColumn(t, e)
        {
            return this.fromArray(t.elements, e * 4)
        }
        setFromMatrix3Column(t, e)
        {
            return this.fromArray(t.elements, e * 3)
        }
        setFromEuler(t)
        {
            return this.x = t._x, this.y = t._y, this.z = t._z, this
        }
        setFromColor(t)
        {
            return this.x = t.r, this.y = t.g, this.z = t.b, this
        }
        equals(t)
        {
            return t.x === this.x && t.y === this.y && t.z === this.z
        }
        fromArray(t, e=0)
        {
            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        }
        toArray(t=[], e=0)
        {
            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        }
        fromBufferAttribute(t, e)
        {
            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        }
        random()
        {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
        randomDirection()
        {
            const t = Math.random() * Math.PI * 2,
                e = Math.random() * 2 - 1,
                n = Math.sqrt(1 - e * e);
            return this.x = n * Math.cos(t), this.y = e, this.z = n * Math.sin(t), this
        }
        *[Symbol.iterator]()
        {
            yield this.x,
            yield this.y,
            yield this.z
        }
    }
    ;
const Yc = new O,
    Ff = new Wi;
class Ms {
    constructor(t=new O(1 / 0, 1 / 0, 1 / 0), e=new O(-1 / 0, -1 / 0, -1 / 0))
    {
        this.isBox3 = !0,
        this.min = t,
        this.max = e
    }
    set(t, e)
    {
        return this.min.copy(t), this.max.copy(e), this
    }
    setFromArray(t)
    {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e += 3)
            this.expandByPoint(vi.fromArray(t, e));
        return this
    }
    setFromBufferAttribute(t)
    {
        this.makeEmpty();
        for (let e = 0, n = t.count; e < n; e++)
            this.expandByPoint(vi.fromBufferAttribute(t, e));
        return this
    }
    setFromPoints(t)
    {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++)
            this.expandByPoint(t[e]);
        return this
    }
    setFromCenterAndSize(t, e)
    {
        const n = vi.copy(e).multiplyScalar(.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
    }
    setFromObject(t, e=!1)
    {
        return this.makeEmpty(), this.expandByObject(t, e)
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
    copy(t)
    {
        return this.min.copy(t.min), this.max.copy(t.max), this
    }
    makeEmpty()
    {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty()
    {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(t)
    {
        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(t)
    {
        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    }
    expandByPoint(t)
    {
        return this.min.min(t), this.max.max(t), this
    }
    expandByVector(t)
    {
        return this.min.sub(t), this.max.add(t), this
    }
    expandByScalar(t)
    {
        return this.min.addScalar(-t), this.max.addScalar(t), this
    }
    expandByObject(t, e=!1)
    {
        t.updateWorldMatrix(!1, !1);
        const n = t.geometry;
        if (n !== void 0) {
            const s = n.getAttribute("position");
            if (e === !0 && s !== void 0 && t.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    t.isMesh === !0 ? t.getVertexPosition(o, vi) : vi.fromBufferAttribute(s, o),
                    vi.applyMatrix4(t.matrixWorld),
                    this.expandByPoint(vi);
            else
                t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), tl.copy(t.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), tl.copy(n.boundingBox)),
                tl.applyMatrix4(t.matrixWorld),
                this.union(tl)
        }
        const i = t.children;
        for (let s = 0, o = i.length; s < o; s++)
            this.expandByObject(i[s], e);
        return this
    }
    containsPoint(t)
    {
        return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z
    }
    containsBox(t)
    {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
    }
    getParameter(t, e)
    {
        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(t)
    {
        return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z
    }
    intersectsSphere(t)
    {
        return this.clampPoint(t.center, vi), vi.distanceToSquared(t.center) <= t.radius * t.radius
    }
    intersectsPlane(t)
    {
        let e,
            n;
        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
    }
    intersectsTriangle(t)
    {
        if (this.isEmpty())
            return !1;
        this.getCenter(Yo),
        el.subVectors(this.max, Yo),
        Or.subVectors(t.a, Yo),
        zr.subVectors(t.b, Yo),
        Br.subVectors(t.c, Yo),
        Es.subVectors(zr, Or),
        bs.subVectors(Br, zr),
        Qs.subVectors(Or, Br);
        let e = [0, -Es.z, Es.y, 0, -bs.z, bs.y, 0, -Qs.z, Qs.y, Es.z, 0, -Es.x, bs.z, 0, -bs.x, Qs.z, 0, -Qs.x, -Es.y, Es.x, 0, -bs.y, bs.x, 0, -Qs.y, Qs.x, 0];
        return !$c(e, Or, zr, Br, el) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !$c(e, Or, zr, Br, el)) ? !1 : (nl.crossVectors(Es, bs), e = [nl.x, nl.y, nl.z], $c(e, Or, zr, Br, el))
    }
    clampPoint(t, e)
    {
        return e.copy(t).clamp(this.min, this.max)
    }
    distanceToPoint(t)
    {
        return this.clampPoint(t, vi).distanceTo(t)
    }
    getBoundingSphere(t)
    {
        return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(vi).length() * .5), t
    }
    intersect(t)
    {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(t)
    {
        return this.min.min(t.min), this.max.max(t.max), this
    }
    applyMatrix4(t)
    {
        return this.isEmpty() ? this : (Ji[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ji[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ji[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ji[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ji[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ji[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ji[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ji[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ji), this)
    }
    translate(t)
    {
        return this.min.add(t), this.max.add(t), this
    }
    equals(t)
    {
        return t.min.equals(this.min) && t.max.equals(this.max)
    }
}
const Ji = [new O, new O, new O, new O, new O, new O, new O, new O],
    vi = new O,
    tl = new Ms,
    Or = new O,
    zr = new O,
    Br = new O,
    Es = new O,
    bs = new O,
    Qs = new O,
    Yo = new O,
    el = new O,
    nl = new O,
    tr = new O;
function $c(r, t, e, n, i) {
    for (let s = 0, o = r.length - 3; s <= o; s += 3) {
        tr.fromArray(r, s);
        const a = i.x * Math.abs(tr.x) + i.y * Math.abs(tr.y) + i.z * Math.abs(tr.z),
            l = t.dot(tr),
            c = e.dot(tr),
            h = n.dot(tr);
        if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a)
            return !1
    }
    return !0
}
const cv = new Ms,
    $o = new O,
    qc = new O;
class $i {
    constructor(t=new O, e=-1)
    {
        this.isSphere = !0,
        this.center = t,
        this.radius = e
    }
    set(t, e)
    {
        return this.center.copy(t), this.radius = e, this
    }
    setFromPoints(t, e)
    {
        const n = this.center;
        e !== void 0 ? n.copy(e) : cv.setFromPoints(t).getCenter(n);
        let i = 0;
        for (let s = 0, o = t.length; s < o; s++)
            i = Math.max(i, n.distanceToSquared(t[s]));
        return this.radius = Math.sqrt(i), this
    }
    copy(t)
    {
        return this.center.copy(t.center), this.radius = t.radius, this
    }
    isEmpty()
    {
        return this.radius < 0
    }
    makeEmpty()
    {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(t)
    {
        return t.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(t)
    {
        return t.distanceTo(this.center) - this.radius
    }
    intersectsSphere(t)
    {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e
    }
    intersectsBox(t)
    {
        return t.intersectsSphere(this)
    }
    intersectsPlane(t)
    {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(t, e)
    {
        const n = this.center.distanceToSquared(t);
        return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
    }
    getBoundingBox(t)
    {
        return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
    }
    applyMatrix4(t)
    {
        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
    }
    translate(t)
    {
        return this.center.add(t), this
    }
    expandByPoint(t)
    {
        if (this.isEmpty())
            return this.center.copy(t), this.radius = 0, this;
        $o.subVectors(t, this.center);
        const e = $o.lengthSq();
        if (e > this.radius * this.radius) {
            const n = Math.sqrt(e),
                i = (n - this.radius) * .5;
            this.center.addScaledVector($o, i / n),
            this.radius += i
        }
        return this
    }
    union(t)
    {
        return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (qc.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint($o.copy(t.center).add(qc)), this.expandByPoint($o.copy(t.center).sub(qc))), this)
    }
    equals(t)
    {
        return t.center.equals(this.center) && t.radius === this.radius
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
}
const Qi = new O,
    Kc = new O,
    il = new O,
    ws = new O,
    jc = new O,
    sl = new O,
    Zc = new O;
class Ya {
    constructor(t=new O, e=new O(0, 0, -1))
    {
        this.origin = t,
        this.direction = e
    }
    set(t, e)
    {
        return this.origin.copy(t), this.direction.copy(e), this
    }
    copy(t)
    {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
    }
    at(t, e)
    {
        return e.copy(this.origin).addScaledVector(this.direction, t)
    }
    lookAt(t)
    {
        return this.direction.copy(t).sub(this.origin).normalize(), this
    }
    recast(t)
    {
        return this.origin.copy(this.at(t, Qi)), this
    }
    closestPointToPoint(t, e)
    {
        e.subVectors(t, this.origin);
        const n = e.dot(this.direction);
        return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(t)
    {
        return Math.sqrt(this.distanceSqToPoint(t))
    }
    distanceSqToPoint(t)
    {
        const e = Qi.subVectors(t, this.origin).dot(this.direction);
        return e < 0 ? this.origin.distanceToSquared(t) : (Qi.copy(this.origin).addScaledVector(this.direction, e), Qi.distanceToSquared(t))
    }
    distanceSqToSegment(t, e, n, i)
    {
        Kc.copy(t).add(e).multiplyScalar(.5),
        il.copy(e).sub(t).normalize(),
        ws.copy(this.origin).sub(Kc);
        const s = t.distanceTo(e) * .5,
            o = -this.direction.dot(il),
            a = ws.dot(this.direction),
            l = -ws.dot(il),
            c = ws.lengthSq(),
            h = Math.abs(1 - o * o);
        let u,
            d,
            f,
            m;
        if (h > 0)
            if (u = o * l - a, d = o * a - l, m = s * h, u >= 0)
                if (d >= -m)
                    if (d <= m) {
                        const _ = 1 / h;
                        u *= _,
                        d *= _,
                        f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c
                    } else
                        d = s,
                        u = Math.max(0, -(o * d + a)),
                        f = -u * u + d * (d + 2 * l) + c;
                else
                    d = -s,
                    u = Math.max(0, -(o * d + a)),
                    f = -u * u + d * (d + 2 * l) + c;
            else
                d <= -m ? (u = Math.max(0, -(-o * s + a)), d = u > 0 ? -s : Math.min(Math.max(-s, -l), s), f = -u * u + d * (d + 2 * l) + c) : d <= m ? (u = 0, d = Math.min(Math.max(-s, -l), s), f = d * (d + 2 * l) + c) : (u = Math.max(0, -(o * s + a)), d = u > 0 ? s : Math.min(Math.max(-s, -l), s), f = -u * u + d * (d + 2 * l) + c);
        else
            d = o > 0 ? -s : s,
            u = Math.max(0, -(o * d + a)),
            f = -u * u + d * (d + 2 * l) + c;
        return n && n.copy(this.origin).addScaledVector(this.direction, u), i && i.copy(Kc).addScaledVector(il, d), f
    }
    intersectSphere(t, e)
    {
        Qi.subVectors(t.center, this.origin);
        const n = Qi.dot(this.direction),
            i = Qi.dot(Qi) - n * n,
            s = t.radius * t.radius;
        if (i > s)
            return null;
        const o = Math.sqrt(s - i),
            a = n - o,
            l = n + o;
        return l < 0 ? null : a < 0 ? this.at(l, e) : this.at(a, e)
    }
    intersectsSphere(t)
    {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
    }
    distanceToPlane(t)
    {
        const e = t.normal.dot(this.direction);
        if (e === 0)
            return t.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(t.normal) + t.constant) / e;
        return n >= 0 ? n : null
    }
    intersectPlane(t, e)
    {
        const n = this.distanceToPlane(t);
        return n === null ? null : this.at(n, e)
    }
    intersectsPlane(t)
    {
        const e = t.distanceToPoint(this.origin);
        return e === 0 || t.normal.dot(this.direction) * e < 0
    }
    intersectBox(t, e)
    {
        let n,
            i,
            s,
            o,
            a,
            l;
        const c = 1 / this.direction.x,
            h = 1 / this.direction.y,
            u = 1 / this.direction.z,
            d = this.origin;
        return c >= 0 ? (n = (t.min.x - d.x) * c, i = (t.max.x - d.x) * c) : (n = (t.max.x - d.x) * c, i = (t.min.x - d.x) * c), h >= 0 ? (s = (t.min.y - d.y) * h, o = (t.max.y - d.y) * h) : (s = (t.max.y - d.y) * h, o = (t.min.y - d.y) * h), n > o || s > i || ((s > n || isNaN(n)) && (n = s), (o < i || isNaN(i)) && (i = o), u >= 0 ? (a = (t.min.z - d.z) * u, l = (t.max.z - d.z) * u) : (a = (t.max.z - d.z) * u, l = (t.min.z - d.z) * u), n > l || a > i) || ((a > n || n !== n) && (n = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, e)
    }
    intersectsBox(t)
    {
        return this.intersectBox(t, Qi) !== null
    }
    intersectTriangle(t, e, n, i, s)
    {
        jc.subVectors(e, t),
        sl.subVectors(n, t),
        Zc.crossVectors(jc, sl);
        let o = this.direction.dot(Zc),
            a;
        if (o > 0) {
            if (i)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        ws.subVectors(this.origin, t);
        const l = a * this.direction.dot(sl.crossVectors(ws, sl));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(jc.cross(ws));
        if (c < 0 || l + c > o)
            return null;
        const h = -a * ws.dot(Zc);
        return h < 0 ? null : this.at(h / o, s)
    }
    applyMatrix4(t)
    {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    }
    equals(t)
    {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
}
let le = class bu {
    constructor(t, e, n, i, s, o, a, l, c, h, u, d, f, m, _, g)
    {
        bu.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        t !== void 0 && this.set(t, e, n, i, s, o, a, l, c, h, u, d, f, m, _, g)
    }
    set(t, e, n, i, s, o, a, l, c, h, u, d, f, m, _, g)
    {
        const p = this.elements;
        return p[0] = t, p[4] = e, p[8] = n, p[12] = i, p[1] = s, p[5] = o, p[9] = a, p[13] = l, p[2] = c, p[6] = h, p[10] = u, p[14] = d, p[3] = f, p[7] = m, p[11] = _, p[15] = g, this
    }
    identity()
    {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone()
    {
        return new bu().fromArray(this.elements)
    }
    copy(t)
    {
        const e = this.elements,
            n = t.elements;
        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
    }
    copyPosition(t)
    {
        const e = this.elements,
            n = t.elements;
        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
    }
    setFromMatrix3(t)
    {
        const e = t.elements;
        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(t, e, n)
    {
        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
    }
    makeBasis(t, e, n)
    {
        return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(t)
    {
        const e = this.elements,
            n = t.elements,
            i = 1 / kr.setFromMatrixColumn(t, 0).length(),
            s = 1 / kr.setFromMatrixColumn(t, 1).length(),
            o = 1 / kr.setFromMatrixColumn(t, 2).length();
        return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }
    makeRotationFromEuler(t)
    {
        const e = this.elements,
            n = t.x,
            i = t.y,
            s = t.z,
            o = Math.cos(n),
            a = Math.sin(n),
            l = Math.cos(i),
            c = Math.sin(i),
            h = Math.cos(s),
            u = Math.sin(s);
        if (t.order === "XYZ") {
            const d = o * h,
                f = o * u,
                m = a * h,
                _ = a * u;
            e[0] = l * h,
            e[4] = -l * u,
            e[8] = c,
            e[1] = f + m * c,
            e[5] = d - _ * c,
            e[9] = -a * l,
            e[2] = _ - d * c,
            e[6] = m + f * c,
            e[10] = o * l
        } else if (t.order === "YXZ") {
            const d = l * h,
                f = l * u,
                m = c * h,
                _ = c * u;
            e[0] = d + _ * a,
            e[4] = m * a - f,
            e[8] = o * c,
            e[1] = o * u,
            e[5] = o * h,
            e[9] = -a,
            e[2] = f * a - m,
            e[6] = _ + d * a,
            e[10] = o * l
        } else if (t.order === "ZXY") {
            const d = l * h,
                f = l * u,
                m = c * h,
                _ = c * u;
            e[0] = d - _ * a,
            e[4] = -o * u,
            e[8] = m + f * a,
            e[1] = f + m * a,
            e[5] = o * h,
            e[9] = _ - d * a,
            e[2] = -o * c,
            e[6] = a,
            e[10] = o * l
        } else if (t.order === "ZYX") {
            const d = o * h,
                f = o * u,
                m = a * h,
                _ = a * u;
            e[0] = l * h,
            e[4] = m * c - f,
            e[8] = d * c + _,
            e[1] = l * u,
            e[5] = _ * c + d,
            e[9] = f * c - m,
            e[2] = -c,
            e[6] = a * l,
            e[10] = o * l
        } else if (t.order === "YZX") {
            const d = o * l,
                f = o * c,
                m = a * l,
                _ = a * c;
            e[0] = l * h,
            e[4] = _ - d * u,
            e[8] = m * u + f,
            e[1] = u,
            e[5] = o * h,
            e[9] = -a * h,
            e[2] = -c * h,
            e[6] = f * u + m,
            e[10] = d - _ * u
        } else if (t.order === "XZY") {
            const d = o * l,
                f = o * c,
                m = a * l,
                _ = a * c;
            e[0] = l * h,
            e[4] = -u,
            e[8] = c * h,
            e[1] = d * u + _,
            e[5] = o * h,
            e[9] = f * u - m,
            e[2] = m * u - f,
            e[6] = a * h,
            e[10] = _ * u + d
        }
        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }
    makeRotationFromQuaternion(t)
    {
        return this.compose(hv, t, uv)
    }
    lookAt(t, e, n)
    {
        const i = this.elements;
        return qn.subVectors(t, e), qn.lengthSq() === 0 && (qn.z = 1), qn.normalize(), As.crossVectors(n, qn), As.lengthSq() === 0 && (Math.abs(n.z) === 1 ? qn.x += 1e-4 : qn.z += 1e-4, qn.normalize(), As.crossVectors(n, qn)), As.normalize(), rl.crossVectors(qn, As), i[0] = As.x, i[4] = rl.x, i[8] = qn.x, i[1] = As.y, i[5] = rl.y, i[9] = qn.y, i[2] = As.z, i[6] = rl.z, i[10] = qn.z, this
    }
    multiply(t)
    {
        return this.multiplyMatrices(this, t)
    }
    premultiply(t)
    {
        return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, e)
    {
        const n = t.elements,
            i = e.elements,
            s = this.elements,
            o = n[0],
            a = n[4],
            l = n[8],
            c = n[12],
            h = n[1],
            u = n[5],
            d = n[9],
            f = n[13],
            m = n[2],
            _ = n[6],
            g = n[10],
            p = n[14],
            x = n[3],
            v = n[7],
            y = n[11],
            C = n[15],
            A = i[0],
            T = i[4],
            R = i[8],
            E = i[12],
            M = i[1],
            D = i[5],
            I = i[9],
            k = i[13],
            $ = i[2],
            j = i[6],
            G = i[10],
            H = i[14],
            V = i[3],
            nt = i[7],
            P = i[11],
            ct = i[15];
        return s[0] = o * A + a * M + l * $ + c * V, s[4] = o * T + a * D + l * j + c * nt, s[8] = o * R + a * I + l * G + c * P, s[12] = o * E + a * k + l * H + c * ct, s[1] = h * A + u * M + d * $ + f * V, s[5] = h * T + u * D + d * j + f * nt, s[9] = h * R + u * I + d * G + f * P, s[13] = h * E + u * k + d * H + f * ct, s[2] = m * A + _ * M + g * $ + p * V, s[6] = m * T + _ * D + g * j + p * nt, s[10] = m * R + _ * I + g * G + p * P, s[14] = m * E + _ * k + g * H + p * ct, s[3] = x * A + v * M + y * $ + C * V, s[7] = x * T + v * D + y * j + C * nt, s[11] = x * R + v * I + y * G + C * P, s[15] = x * E + v * k + y * H + C * ct, this
    }
    multiplyScalar(t)
    {
        const e = this.elements;
        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
    }
    determinant()
    {
        const t = this.elements,
            e = t[0],
            n = t[4],
            i = t[8],
            s = t[12],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[13],
            h = t[2],
            u = t[6],
            d = t[10],
            f = t[14],
            m = t[3],
            _ = t[7],
            g = t[11],
            p = t[15];
        return m * (+s * l * u - i * c * u - s * a * d + n * c * d + i * a * f - n * l * f) + _ * (+e * l * f - e * c * d + s * o * d - i * o * f + i * c * h - s * l * h) + g * (+e * c * u - e * a * f - s * o * u + n * o * f + s * a * h - n * c * h) + p * (-i * a * h - e * l * u + e * a * d + i * o * u - n * o * d + n * l * h)
    }
    transpose()
    {
        const t = this.elements;
        let e;
        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
    }
    setPosition(t, e, n)
    {
        const i = this.elements;
        return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
    }
    invert()
    {
        const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            s = t[3],
            o = t[4],
            a = t[5],
            l = t[6],
            c = t[7],
            h = t[8],
            u = t[9],
            d = t[10],
            f = t[11],
            m = t[12],
            _ = t[13],
            g = t[14],
            p = t[15],
            x = u * g * c - _ * d * c + _ * l * f - a * g * f - u * l * p + a * d * p,
            v = m * d * c - h * g * c - m * l * f + o * g * f + h * l * p - o * d * p,
            y = h * _ * c - m * u * c + m * a * f - o * _ * f - h * a * p + o * u * p,
            C = m * u * l - h * _ * l - m * a * d + o * _ * d + h * a * g - o * u * g,
            A = e * x + n * v + i * y + s * C;
        if (A === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / A;
        return t[0] = x * T, t[1] = (_ * d * s - u * g * s - _ * i * f + n * g * f + u * i * p - n * d * p) * T, t[2] = (a * g * s - _ * l * s + _ * i * c - n * g * c - a * i * p + n * l * p) * T, t[3] = (u * l * s - a * d * s - u * i * c + n * d * c + a * i * f - n * l * f) * T, t[4] = v * T, t[5] = (h * g * s - m * d * s + m * i * f - e * g * f - h * i * p + e * d * p) * T, t[6] = (m * l * s - o * g * s - m * i * c + e * g * c + o * i * p - e * l * p) * T, t[7] = (o * d * s - h * l * s + h * i * c - e * d * c - o * i * f + e * l * f) * T, t[8] = y * T, t[9] = (m * u * s - h * _ * s - m * n * f + e * _ * f + h * n * p - e * u * p) * T, t[10] = (o * _ * s - m * a * s + m * n * c - e * _ * c - o * n * p + e * a * p) * T, t[11] = (h * a * s - o * u * s - h * n * c + e * u * c + o * n * f - e * a * f) * T, t[12] = C * T, t[13] = (h * _ * i - m * u * i + m * n * d - e * _ * d - h * n * g + e * u * g) * T, t[14] = (m * a * i - o * _ * i - m * n * l + e * _ * l + o * n * g - e * a * g) * T, t[15] = (o * u * i - h * a * i + h * n * l - e * u * l - o * n * d + e * a * d) * T, this
    }
    scale(t)
    {
        const e = this.elements,
            n = t.x,
            i = t.y,
            s = t.z;
        return e[0] *= n, e[4] *= i, e[8] *= s, e[1] *= n, e[5] *= i, e[9] *= s, e[2] *= n, e[6] *= i, e[10] *= s, e[3] *= n, e[7] *= i, e[11] *= s, this
    }
    getMaxScaleOnAxis()
    {
        const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, i))
    }
    makeTranslation(t, e, n)
    {
        return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
    }
    makeRotationX(t)
    {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
    }
    makeRotationY(t)
    {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(t)
    {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(t, e)
    {
        const n = Math.cos(e),
            i = Math.sin(e),
            s = 1 - n,
            o = t.x,
            a = t.y,
            l = t.z,
            c = s * o,
            h = s * a;
        return this.set(c * o + n, c * a - i * l, c * l + i * a, 0, c * a + i * l, h * a + n, h * l - i * o, 0, c * l - i * a, h * l + i * o, s * l * l + n, 0, 0, 0, 0, 1), this
    }
    makeScale(t, e, n)
    {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
    }
    makeShear(t, e, n, i, s, o)
    {
        return this.set(1, n, s, 0, t, 1, o, 0, e, i, 1, 0, 0, 0, 0, 1), this
    }
    compose(t, e, n)
    {
        const i = this.elements,
            s = e._x,
            o = e._y,
            a = e._z,
            l = e._w,
            c = s + s,
            h = o + o,
            u = a + a,
            d = s * c,
            f = s * h,
            m = s * u,
            _ = o * h,
            g = o * u,
            p = a * u,
            x = l * c,
            v = l * h,
            y = l * u,
            C = n.x,
            A = n.y,
            T = n.z;
        return i[0] = (1 - (_ + p)) * C, i[1] = (f + y) * C, i[2] = (m - v) * C, i[3] = 0, i[4] = (f - y) * A, i[5] = (1 - (d + p)) * A, i[6] = (g + x) * A, i[7] = 0, i[8] = (m + v) * T, i[9] = (g - x) * T, i[10] = (1 - (d + _)) * T, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
    }
    decompose(t, e, n)
    {
        const i = this.elements;
        let s = kr.set(i[0], i[1], i[2]).length();
        const o = kr.set(i[4], i[5], i[6]).length(),
            a = kr.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (s = -s),
        t.x = i[12],
        t.y = i[13],
        t.z = i[14],
        yi.copy(this);
        const c = 1 / s,
            h = 1 / o,
            u = 1 / a;
        return yi.elements[0] *= c, yi.elements[1] *= c, yi.elements[2] *= c, yi.elements[4] *= h, yi.elements[5] *= h, yi.elements[6] *= h, yi.elements[8] *= u, yi.elements[9] *= u, yi.elements[10] *= u, e.setFromRotationMatrix(yi), n.x = s, n.y = o, n.z = a, this
    }
    makePerspective(t, e, n, i, s, o, a=us)
    {
        const l = this.elements,
            c = 2 * s / (e - t),
            h = 2 * s / (n - i),
            u = (e + t) / (e - t),
            d = (n + i) / (n - i);
        let f,
            m;
        if (a === us)
            f = -(o + s) / (o - s),
            m = -2 * o * s / (o - s);
        else if (a === dc)
            f = -o / (o - s),
            m = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c, l[4] = 0, l[8] = u, l[12] = 0, l[1] = 0, l[5] = h, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
    }
    makeOrthographic(t, e, n, i, s, o, a=us)
    {
        const l = this.elements,
            c = 1 / (e - t),
            h = 1 / (n - i),
            u = 1 / (o - s),
            d = (e + t) * c,
            f = (n + i) * h;
        let m,
            _;
        if (a === us)
            m = (o + s) * u,
            _ = -2 * u;
        else if (a === dc)
            m = s * u,
            _ = -1 * u;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
    }
    equals(t)
    {
        const e = this.elements,
            n = t.elements;
        for (let i = 0; i < 16; i++)
            if (e[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(t, e=0)
    {
        for (let n = 0; n < 16; n++)
            this.elements[n] = t[n + e];
        return this
    }
    toArray(t=[], e=0)
    {
        const n = this.elements;
        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
    }
}
;
const kr = new O,
    yi = new le,
    hv = new O(0, 0, 0),
    uv = new O(1, 1, 1),
    As = new O,
    rl = new O,
    qn = new O,
    Uf = new le,
    Of = new Wi;
class Xi {
    constructor(t=0, e=0, n=0, i=Xi.DEFAULT_ORDER)
    {
        this.isEuler = !0,
        this._x = t,
        this._y = e,
        this._z = n,
        this._order = i
    }
    get x()
    {
        return this._x
    }
    set x(t)
    {
        this._x = t,
        this._onChangeCallback()
    }
    get y()
    {
        return this._y
    }
    set y(t)
    {
        this._y = t,
        this._onChangeCallback()
    }
    get z()
    {
        return this._z
    }
    set z(t)
    {
        this._z = t,
        this._onChangeCallback()
    }
    get order()
    {
        return this._order
    }
    set order(t)
    {
        this._order = t,
        this._onChangeCallback()
    }
    set(t, e, n, i=this._order)
    {
        return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this
    }
    clone()
    {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(t)
    {
        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(t, e=this._order, n=!0)
    {
        const i = t.elements,
            s = i[0],
            o = i[4],
            a = i[8],
            l = i[1],
            c = i[5],
            h = i[9],
            u = i[2],
            d = i[6],
            f = i[10];
        switch (e) {
        case "XYZ":
            this._y = Math.asin(hn(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, c), this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-hn(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, s), this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(hn(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-hn(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(hn(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, s)) : (this._x = 0, this._y = Math.atan2(a, f));
            break;
        case "XZY":
            this._z = Math.asin(-hn(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, f), this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
        }
        return this._order = e, n === !0 && this._onChangeCallback(), this
    }
    setFromQuaternion(t, e, n)
    {
        return Uf.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Uf, e, n)
    }
    setFromVector3(t, e=this._order)
    {
        return this.set(t.x, t.y, t.z, e)
    }
    reorder(t)
    {
        return Of.setFromEuler(this), this.setFromQuaternion(Of, t)
    }
    equals(t)
    {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
    }
    fromArray(t)
    {
        return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this
    }
    toArray(t=[], e=0)
    {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
    }
    _onChange(t)
    {
        return this._onChangeCallback = t, this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]()
    {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Xi.DEFAULT_ORDER = "XYZ";
class fg {
    constructor()
    {
        this.mask = 1
    }
    set(t)
    {
        this.mask = (1 << t | 0) >>> 0
    }
    enable(t)
    {
        this.mask |= 1 << t | 0
    }
    enableAll()
    {
        this.mask = -1
    }
    toggle(t)
    {
        this.mask ^= 1 << t | 0
    }
    disable(t)
    {
        this.mask &= ~(1 << t | 0)
    }
    disableAll()
    {
        this.mask = 0
    }
    test(t)
    {
        return (this.mask & t.mask) !== 0
    }
    isEnabled(t)
    {
        return (this.mask & (1 << t | 0)) !== 0
    }
}
let dv = 0;
const zf = new O,
    Hr = new Wi,
    ts = new le,
    ol = new O,
    qo = new O,
    fv = new O,
    pv = new Wi,
    Bf = new O(1, 0, 0),
    kf = new O(0, 1, 0),
    Hf = new O(0, 0, 1),
    Vf = {
        type: "added"
    },
    mv = {
        type: "removed"
    },
    Vr = {
        type: "childadded",
        child: null
    },
    Jc = {
        type: "childremoved",
        child: null
    };
class He extends Rr {
    constructor()
    {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: dv++
        }),
        this.uuid = Ri(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = He.DEFAULT_UP.clone();
        const t = new O,
            e = new Xi,
            n = new Wi,
            i = new O(1, 1, 1);
        function s() {
            n.setFromEuler(e, !1)
        }
        function o() {
            e.setFromQuaternion(n, void 0, !1)
        }
        e._onChange(s),
        n._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new le
            },
            normalMatrix: {
                value: new re
            }
        }),
        this.matrix = new le,
        this.matrixWorld = new le,
        this.matrixAutoUpdate = He.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = He.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new fg,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t)
    {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(t)
    {
        return this.quaternion.premultiply(t), this
    }
    setRotationFromAxisAngle(t, e)
    {
        this.quaternion.setFromAxisAngle(t, e)
    }
    setRotationFromEuler(t)
    {
        this.quaternion.setFromEuler(t, !0)
    }
    setRotationFromMatrix(t)
    {
        this.quaternion.setFromRotationMatrix(t)
    }
    setRotationFromQuaternion(t)
    {
        this.quaternion.copy(t)
    }
    rotateOnAxis(t, e)
    {
        return Hr.setFromAxisAngle(t, e), this.quaternion.multiply(Hr), this
    }
    rotateOnWorldAxis(t, e)
    {
        return Hr.setFromAxisAngle(t, e), this.quaternion.premultiply(Hr), this
    }
    rotateX(t)
    {
        return this.rotateOnAxis(Bf, t)
    }
    rotateY(t)
    {
        return this.rotateOnAxis(kf, t)
    }
    rotateZ(t)
    {
        return this.rotateOnAxis(Hf, t)
    }
    translateOnAxis(t, e)
    {
        return zf.copy(t).applyQuaternion(this.quaternion), this.position.add(zf.multiplyScalar(e)), this
    }
    translateX(t)
    {
        return this.translateOnAxis(Bf, t)
    }
    translateY(t)
    {
        return this.translateOnAxis(kf, t)
    }
    translateZ(t)
    {
        return this.translateOnAxis(Hf, t)
    }
    localToWorld(t)
    {
        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(t)
    {
        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(ts.copy(this.matrixWorld).invert())
    }
    lookAt(t, e, n)
    {
        t.isVector3 ? ol.copy(t) : ol.set(t, e, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
        qo.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? ts.lookAt(qo, ol, this.up) : ts.lookAt(ol, qo, this.up),
        this.quaternion.setFromRotationMatrix(ts),
        i && (ts.extractRotation(i.matrixWorld), Hr.setFromRotationMatrix(ts), this.quaternion.premultiply(Hr.invert()))
    }
    add(t)
    {
        if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++)
                this.add(arguments[e]);
            return this
        }
        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(Vf), Vr.child = t, this.dispatchEvent(Vr), Vr.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
    }
    remove(t)
    {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.remove(arguments[n]);
            return this
        }
        const e = this.children.indexOf(t);
        return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(mv), Jc.child = t, this.dispatchEvent(Jc), Jc.child = null), this
    }
    removeFromParent()
    {
        const t = this.parent;
        return t !== null && t.remove(this), this
    }
    clear()
    {
        return this.remove(...this.children)
    }
    attach(t)
    {
        return this.updateWorldMatrix(!0, !1), ts.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), ts.multiply(t.parent.matrixWorld)), t.applyMatrix4(ts), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(Vf), Vr.child = t, this.dispatchEvent(Vr), Vr.child = null, this
    }
    getObjectById(t)
    {
        return this.getObjectByProperty("id", t)
    }
    getObjectByName(t)
    {
        return this.getObjectByProperty("name", t)
    }
    getObjectByProperty(t, e)
    {
        if (this[t] === e)
            return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(t, e);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(t, e, n=[])
    {
        this[t] === e && n.push(this);
        const i = this.children;
        for (let s = 0, o = i.length; s < o; s++)
            i[s].getObjectsByProperty(t, e, n);
        return n
    }
    getWorldPosition(t)
    {
        return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(t)
    {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(qo, t, fv), t
    }
    getWorldScale(t)
    {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(qo, pv, t), t
    }
    getWorldDirection(t)
    {
        this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize()
    }
    raycast() {}
    traverse(t)
    {
        t(this);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++)
            e[n].traverse(t)
    }
    traverseVisible(t)
    {
        if (this.visible === !1)
            return;
        t(this);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++)
            e[n].traverseVisible(t)
    }
    traverseAncestors(t)
    {
        const e = this.parent;
        e !== null && (t(e), e.traverseAncestors(t))
    }
    updateMatrix()
    {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(t)
    {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, t = !0);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++)
            e[n].updateMatrixWorld(t)
    }
    updateWorldMatrix(t, e)
    {
        const n = this.parent;
        if (t === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), e === !0) {
            const i = this.children;
            for (let s = 0, o = i.length; s < o; s++)
                i[s].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(t)
    {
        const e = t === void 0 || typeof t == "string",
            n = {};
        e && (t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, n.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        i.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(t), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(t)), this.boundingSphere !== null && (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius
        }), this.boundingBox !== null && (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray()
        }));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(t)), l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(t).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(t.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, h = l.length; c < h; c++) {
                        const u = l[c];
                        s(t.shapes, u)
                    }
                else
                    s(t.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(s(t.materials, this.material[l]));
                i.material = a
            } else
                i.material = s(t.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
                i.children.push(this.children[a].toJSON(t).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                i.animations.push(s(t.animations, l))
            }
        }
        if (e) {
            const a = o(t.geometries),
                l = o(t.materials),
                c = o(t.textures),
                h = o(t.images),
                u = o(t.shapes),
                d = o(t.skeletons),
                f = o(t.animations),
                m = o(t.nodes);
            a.length > 0 && (n.geometries = a),
            l.length > 0 && (n.materials = l),
            c.length > 0 && (n.textures = c),
            h.length > 0 && (n.images = h),
            u.length > 0 && (n.shapes = u),
            d.length > 0 && (n.skeletons = d),
            f.length > 0 && (n.animations = f),
            m.length > 0 && (n.nodes = m)
        }
        return n.object = i, n;
        function o(a) {
            const l = [];
            for (const c in a) {
                const h = a[c];
                delete h.metadata,
                l.push(h)
            }
            return l
        }
    }
    clone(t)
    {
        return new this.constructor().copy(this, t)
    }
    copy(t, e=!0)
    {
        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
            for (let n = 0; n < t.children.length; n++) {
                const i = t.children[n];
                this.add(i.clone())
            }
        return this
    }
}
He.DEFAULT_UP = new O(0, 1, 0);
He.DEFAULT_MATRIX_AUTO_UPDATE = !0;
He.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Mi = new O,
    es = new O,
    Qc = new O,
    ns = new O,
    Gr = new O,
    Wr = new O,
    Gf = new O,
    th = new O,
    eh = new O,
    nh = new O;
class Oi {
    constructor(t=new O, e=new O, n=new O)
    {
        this.a = t,
        this.b = e,
        this.c = n
    }
    static getNormal(t, e, n, i)
    {
        i.subVectors(n, e),
        Mi.subVectors(t, e),
        i.cross(Mi);
        const s = i.lengthSq();
        return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
    }
    static getBarycoord(t, e, n, i, s)
    {
        Mi.subVectors(i, e),
        es.subVectors(n, e),
        Qc.subVectors(t, e);
        const o = Mi.dot(Mi),
            a = Mi.dot(es),
            l = Mi.dot(Qc),
            c = es.dot(es),
            h = es.dot(Qc),
            u = o * c - a * a;
        if (u === 0)
            return s.set(0, 0, 0), null;
        const d = 1 / u,
            f = (c * l - a * h) * d,
            m = (o * h - a * l) * d;
        return s.set(1 - f - m, m, f)
    }
    static containsPoint(t, e, n, i)
    {
        return this.getBarycoord(t, e, n, i, ns) === null ? !1 : ns.x >= 0 && ns.y >= 0 && ns.x + ns.y <= 1
    }
    static getInterpolation(t, e, n, i, s, o, a, l)
    {
        return this.getBarycoord(t, e, n, i, ns) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, ns.x), l.addScaledVector(o, ns.y), l.addScaledVector(a, ns.z), l)
    }
    static isFrontFacing(t, e, n, i)
    {
        return Mi.subVectors(n, e), es.subVectors(t, e), Mi.cross(es).dot(i) < 0
    }
    set(t, e, n)
    {
        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
    }
    setFromPointsAndIndices(t, e, n, i)
    {
        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
    }
    setFromAttributeAndIndices(t, e, n, i)
    {
        return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
    copy(t)
    {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
    }
    getArea()
    {
        return Mi.subVectors(this.c, this.b), es.subVectors(this.a, this.b), Mi.cross(es).length() * .5
    }
    getMidpoint(t)
    {
        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(t)
    {
        return Oi.getNormal(this.a, this.b, this.c, t)
    }
    getPlane(t)
    {
        return t.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(t, e)
    {
        return Oi.getBarycoord(t, this.a, this.b, this.c, e)
    }
    getInterpolation(t, e, n, i, s)
    {
        return Oi.getInterpolation(t, this.a, this.b, this.c, e, n, i, s)
    }
    containsPoint(t)
    {
        return Oi.containsPoint(t, this.a, this.b, this.c)
    }
    isFrontFacing(t)
    {
        return Oi.isFrontFacing(this.a, this.b, this.c, t)
    }
    intersectsBox(t)
    {
        return t.intersectsTriangle(this)
    }
    closestPointToPoint(t, e)
    {
        const n = this.a,
            i = this.b,
            s = this.c;
        let o,
            a;
        Gr.subVectors(i, n),
        Wr.subVectors(s, n),
        th.subVectors(t, n);
        const l = Gr.dot(th),
            c = Wr.dot(th);
        if (l <= 0 && c <= 0)
            return e.copy(n);
        eh.subVectors(t, i);
        const h = Gr.dot(eh),
            u = Wr.dot(eh);
        if (h >= 0 && u <= h)
            return e.copy(i);
        const d = l * u - h * c;
        if (d <= 0 && l >= 0 && h <= 0)
            return o = l / (l - h), e.copy(n).addScaledVector(Gr, o);
        nh.subVectors(t, s);
        const f = Gr.dot(nh),
            m = Wr.dot(nh);
        if (m >= 0 && f <= m)
            return e.copy(s);
        const _ = f * c - l * m;
        if (_ <= 0 && c >= 0 && m <= 0)
            return a = c / (c - m), e.copy(n).addScaledVector(Wr, a);
        const g = h * m - f * u;
        if (g <= 0 && u - h >= 0 && f - m >= 0)
            return Gf.subVectors(s, i), a = (u - h) / (u - h + (f - m)), e.copy(i).addScaledVector(Gf, a);
        const p = 1 / (g + _ + d);
        return o = _ * p, a = d * p, e.copy(n).addScaledVector(Gr, o).addScaledVector(Wr, a)
    }
    equals(t)
    {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
    }
}
const pg = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    Cs = {
        h: 0,
        s: 0,
        l: 0
    },
    al = {
        h: 0,
        s: 0,
        l: 0
    };
function ih(r, t, e) {
    return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? r + (t - r) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? r + (t - r) * 6 * (2 / 3 - e) : r
}
let Gt = class {
    constructor(t, e, n)
    {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n)
    }
    set(t, e, n)
    {
        if (e === void 0 && n === void 0) {
            const i = t;
            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
        } else
            this.setRGB(t, e, n);
        return this
    }
    setScalar(t)
    {
        return this.r = t, this.g = t, this.b = t, this
    }
    setHex(t, e=Ln)
    {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, me.toWorkingColorSpace(this, e), this
    }
    setRGB(t, e, n, i=me.workingColorSpace)
    {
        return this.r = t, this.g = e, this.b = n, me.toWorkingColorSpace(this, i), this
    }
    setHSL(t, e, n, i=me.workingColorSpace)
    {
        if (t = Sd(t, 1), e = hn(e, 0, 1), n = hn(n, 0, 1), e === 0)
            this.r = this.g = this.b = n;
        else {
            const s = n <= .5 ? n * (1 + e) : n + e - n * e,
                o = 2 * n - s;
            this.r = ih(o, s, t + 1 / 3),
            this.g = ih(o, s, t),
            this.b = ih(o, s, t - 1 / 3)
        }
        return me.toWorkingColorSpace(this, i), this
    }
    setStyle(t, e=Ln)
    {
        function n(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
            let s;
            const o = i[1],
                a = i[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, e);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, e);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, e);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + t)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const s = i[1],
                o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, e);
            if (o === 6)
                return this.setHex(parseInt(s, 16), e);
            console.warn("THREE.Color: Invalid hex color " + t)
        } else if (t && t.length > 0)
            return this.setColorName(t, e);
        return this
    }
    setColorName(t, e=Ln)
    {
        const n = pg[t.toLowerCase()];
        return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
    }
    clone()
    {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(t)
    {
        return this.r = t.r, this.g = t.g, this.b = t.b, this
    }
    copySRGBToLinear(t)
    {
        return this.r = mo(t.r), this.g = mo(t.g), this.b = mo(t.b), this
    }
    copyLinearToSRGB(t)
    {
        return this.r = Wc(t.r), this.g = Wc(t.g), this.b = Wc(t.b), this
    }
    convertSRGBToLinear()
    {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB()
    {
        return this.copyLinearToSRGB(this), this
    }
    getHex(t=Ln)
    {
        return me.fromWorkingColorSpace(mn.copy(this), t), Math.round(hn(mn.r * 255, 0, 255)) * 65536 + Math.round(hn(mn.g * 255, 0, 255)) * 256 + Math.round(hn(mn.b * 255, 0, 255))
    }
    getHexString(t=Ln)
    {
        return ("000000" + this.getHex(t).toString(16)).slice(-6)
    }
    getHSL(t, e=me.workingColorSpace)
    {
        me.fromWorkingColorSpace(mn.copy(this), e);
        const n = mn.r,
            i = mn.g,
            s = mn.b,
            o = Math.max(n, i, s),
            a = Math.min(n, i, s);
        let l,
            c;
        const h = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const u = o - a;
            switch (c = h <= .5 ? u / (o + a) : u / (2 - o - a), o) {
            case n:
                l = (i - s) / u + (i < s ? 6 : 0);
                break;
            case i:
                l = (s - n) / u + 2;
                break;
            case s:
                l = (n - i) / u + 4;
                break
            }
            l /= 6
        }
        return t.h = l, t.s = c, t.l = h, t
    }
    getRGB(t, e=me.workingColorSpace)
    {
        return me.fromWorkingColorSpace(mn.copy(this), e), t.r = mn.r, t.g = mn.g, t.b = mn.b, t
    }
    getStyle(t=Ln)
    {
        me.fromWorkingColorSpace(mn.copy(this), t);
        const e = mn.r,
            n = mn.g,
            i = mn.b;
        return t !== Ln ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
    }
    offsetHSL(t, e, n)
    {
        return this.getHSL(Cs), this.setHSL(Cs.h + t, Cs.s + e, Cs.l + n)
    }
    add(t)
    {
        return this.r += t.r, this.g += t.g, this.b += t.b, this
    }
    addColors(t, e)
    {
        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
    }
    addScalar(t)
    {
        return this.r += t, this.g += t, this.b += t, this
    }
    sub(t)
    {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
    }
    multiply(t)
    {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
    }
    multiplyScalar(t)
    {
        return this.r *= t, this.g *= t, this.b *= t, this
    }
    lerp(t, e)
    {
        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
    }
    lerpColors(t, e, n)
    {
        return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
    }
    lerpHSL(t, e)
    {
        this.getHSL(Cs),
        t.getHSL(al);
        const n = ma(Cs.h, al.h, e),
            i = ma(Cs.s, al.s, e),
            s = ma(Cs.l, al.l, e);
        return this.setHSL(n, i, s), this
    }
    setFromVector3(t)
    {
        return this.r = t.x, this.g = t.y, this.b = t.z, this
    }
    applyMatrix3(t)
    {
        const e = this.r,
            n = this.g,
            i = this.b,
            s = t.elements;
        return this.r = s[0] * e + s[3] * n + s[6] * i, this.g = s[1] * e + s[4] * n + s[7] * i, this.b = s[2] * e + s[5] * n + s[8] * i, this
    }
    equals(t)
    {
        return t.r === this.r && t.g === this.g && t.b === this.b
    }
    fromArray(t, e=0)
    {
        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
    }
    toArray(t=[], e=0)
    {
        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
    }
    fromBufferAttribute(t, e)
    {
        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
    }
    toJSON()
    {
        return this.getHex()
    }
    *[Symbol.iterator]()
    {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
;
const mn = new Gt;
Gt.NAMES = pg;
let gv = 0;
class Li extends Rr {
    constructor()
    {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: gv++
        }),
        this.uuid = Ri(),
        this.name = "",
        this.type = "Material",
        this.blending = uo,
        this.side = _s,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = $h,
        this.blendDst = qh,
        this.blendEquation = dr,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new Gt(0, 0, 0),
        this.blendAlpha = 0,
        this.depthFunc = ac,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = Rf,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = Fr,
        this.stencilZFail = Fr,
        this.stencilZPass = Fr,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest()
    {
        return this._alphaTest
    }
    set alphaTest(t)
    {
        this._alphaTest > 0 != t > 0 && this.version++,
        this._alphaTest = t
    }
    onBeforeCompile() {}
    customProgramCacheKey()
    {
        return this.onBeforeCompile.toString()
    }
    setValues(t)
    {
        if (t !== void 0)
            for (const e in t) {
                const n = t[e];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                    continue
                }
                const i = this[e];
                if (i === void 0) {
                    console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
                    continue
                }
                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n
            }
    }
    toJSON(t)
    {
        const e = t === void 0 || typeof t == "string";
        e && (t = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        this.roughness !== void 0 && (n.roughness = this.roughness),
        this.metalness !== void 0 && (n.metalness = this.metalness),
        this.sheen !== void 0 && (n.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (n.shininess = this.shininess),
        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid),
        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)),
        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
        this.transmission !== void 0 && (n.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
        this.thickness !== void 0 && (n.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (n.size = this.size),
        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
        this.blending !== uo && (n.blending = this.blending),
        this.side !== _s && (n.side = this.side),
        this.vertexColors === !0 && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        this.transparent === !0 && (n.transparent = !0),
        this.blendSrc !== $h && (n.blendSrc = this.blendSrc),
        this.blendDst !== qh && (n.blendDst = this.blendDst),
        this.blendEquation !== dr && (n.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
        this.depthFunc !== ac && (n.depthFunc = this.depthFunc),
        this.depthTest === !1 && (n.depthTest = this.depthTest),
        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== Rf && (n.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== Fr && (n.stencilFail = this.stencilFail),
        this.stencilZFail !== Fr && (n.stencilZFail = this.stencilZFail),
        this.stencilZPass !== Fr && (n.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
        this.polygonOffset === !0 && (n.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
        this.scale !== void 0 && (n.scale = this.scale),
        this.dithering === !0 && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (n.alphaHash = !0),
        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
        this.wireframe === !0 && (n.wireframe = !0),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (n.flatShading = !0),
        this.visible === !1 && (n.visible = !1),
        this.toneMapped === !1 && (n.toneMapped = !1),
        this.fog === !1 && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
        function i(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (e) {
            const s = i(t.textures),
                o = i(t.images);
            s.length > 0 && (n.textures = s),
            o.length > 0 && (n.images = o)
        }
        return n
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
    copy(t)
    {
        this.name = t.name,
        this.blending = t.blending,
        this.side = t.side,
        this.vertexColors = t.vertexColors,
        this.opacity = t.opacity,
        this.transparent = t.transparent,
        this.blendSrc = t.blendSrc,
        this.blendDst = t.blendDst,
        this.blendEquation = t.blendEquation,
        this.blendSrcAlpha = t.blendSrcAlpha,
        this.blendDstAlpha = t.blendDstAlpha,
        this.blendEquationAlpha = t.blendEquationAlpha,
        this.blendColor.copy(t.blendColor),
        this.blendAlpha = t.blendAlpha,
        this.depthFunc = t.depthFunc,
        this.depthTest = t.depthTest,
        this.depthWrite = t.depthWrite,
        this.stencilWriteMask = t.stencilWriteMask,
        this.stencilFunc = t.stencilFunc,
        this.stencilRef = t.stencilRef,
        this.stencilFuncMask = t.stencilFuncMask,
        this.stencilFail = t.stencilFail,
        this.stencilZFail = t.stencilZFail,
        this.stencilZPass = t.stencilZPass,
        this.stencilWrite = t.stencilWrite;
        const e = t.clippingPlanes;
        let n = null;
        if (e !== null) {
            const i = e.length;
            n = new Array(i);
            for (let s = 0; s !== i; ++s)
                n[s] = e[s].clone()
        }
        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
    }
    dispose()
    {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(t)
    {
        t === !0 && this.version++
    }
    onBuild()
    {
        console.warn("Material: onBuild() has been removed.")
    }
    onBeforeRender()
    {
        console.warn("Material: onBeforeRender() has been removed.")
    }
}
class zs extends Li {
    constructor(t)
    {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Gt(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Xi,
        this.combine = Ym,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(t)
    }
    copy(t)
    {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
    }
}
const Ye = new O,
    ll = new St;
class zn {
    constructor(t, e, n=!1)
    {
        if (Array.isArray(t))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = t,
        this.itemSize = e,
        this.count = t !== void 0 ? t.length / e : 0,
        this.normalized = n,
        this.usage = Eu,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = Ci,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(t)
    {
        t === !0 && this.version++
    }
    get updateRange()
    {
        return po("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
    }
    setUsage(t)
    {
        return this.usage = t, this
    }
    addUpdateRange(t, e)
    {
        this.updateRanges.push({
            start: t,
            count: e
        })
    }
    clearUpdateRanges()
    {
        this.updateRanges.length = 0
    }
    copy(t)
    {
        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
    }
    copyAt(t, e, n)
    {
        t *= this.itemSize,
        n *= e.itemSize;
        for (let i = 0, s = this.itemSize; i < s; i++)
            this.array[t + i] = e.array[n + i];
        return this
    }
    copyArray(t)
    {
        return this.array.set(t), this
    }
    applyMatrix3(t)
    {
        if (this.itemSize === 2)
            for (let e = 0, n = this.count; e < n; e++)
                ll.fromBufferAttribute(this, e),
                ll.applyMatrix3(t),
                this.setXY(e, ll.x, ll.y);
        else if (this.itemSize === 3)
            for (let e = 0, n = this.count; e < n; e++)
                Ye.fromBufferAttribute(this, e),
                Ye.applyMatrix3(t),
                this.setXYZ(e, Ye.x, Ye.y, Ye.z);
        return this
    }
    applyMatrix4(t)
    {
        for (let e = 0, n = this.count; e < n; e++)
            Ye.fromBufferAttribute(this, e),
            Ye.applyMatrix4(t),
            this.setXYZ(e, Ye.x, Ye.y, Ye.z);
        return this
    }
    applyNormalMatrix(t)
    {
        for (let e = 0, n = this.count; e < n; e++)
            Ye.fromBufferAttribute(this, e),
            Ye.applyNormalMatrix(t),
            this.setXYZ(e, Ye.x, Ye.y, Ye.z);
        return this
    }
    transformDirection(t)
    {
        for (let e = 0, n = this.count; e < n; e++)
            Ye.fromBufferAttribute(this, e),
            Ye.transformDirection(t),
            this.setXYZ(e, Ye.x, Ye.y, Ye.z);
        return this
    }
    set(t, e=0)
    {
        return this.array.set(t, e), this
    }
    getComponent(t, e)
    {
        let n = this.array[t * this.itemSize + e];
        return this.normalized && (n = Ai(n, this.array)), n
    }
    setComponent(t, e, n)
    {
        return this.normalized && (n = ye(n, this.array)), this.array[t * this.itemSize + e] = n, this
    }
    getX(t)
    {
        let e = this.array[t * this.itemSize];
        return this.normalized && (e = Ai(e, this.array)), e
    }
    setX(t, e)
    {
        return this.normalized && (e = ye(e, this.array)), this.array[t * this.itemSize] = e, this
    }
    getY(t)
    {
        let e = this.array[t * this.itemSize + 1];
        return this.normalized && (e = Ai(e, this.array)), e
    }
    setY(t, e)
    {
        return this.normalized && (e = ye(e, this.array)), this.array[t * this.itemSize + 1] = e, this
    }
    getZ(t)
    {
        let e = this.array[t * this.itemSize + 2];
        return this.normalized && (e = Ai(e, this.array)), e
    }
    setZ(t, e)
    {
        return this.normalized && (e = ye(e, this.array)), this.array[t * this.itemSize + 2] = e, this
    }
    getW(t)
    {
        let e = this.array[t * this.itemSize + 3];
        return this.normalized && (e = Ai(e, this.array)), e
    }
    setW(t, e)
    {
        return this.normalized && (e = ye(e, this.array)), this.array[t * this.itemSize + 3] = e, this
    }
    setXY(t, e, n)
    {
        return t *= this.itemSize, this.normalized && (e = ye(e, this.array), n = ye(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
    }
    setXYZ(t, e, n, i)
    {
        return t *= this.itemSize, this.normalized && (e = ye(e, this.array), n = ye(n, this.array), i = ye(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
    }
    setXYZW(t, e, n, i, s)
    {
        return t *= this.itemSize, this.normalized && (e = ye(e, this.array), n = ye(n, this.array), i = ye(i, this.array), s = ye(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = s, this
    }
    onUpload(t)
    {
        return this.onUploadCallback = t, this
    }
    clone()
    {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON()
    {
        const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (t.name = this.name), this.usage !== Eu && (t.usage = this.usage), t
    }
}
class mg extends zn {
    constructor(t, e, n)
    {
        super(new Uint16Array(t), e, n)
    }
}
class gg extends zn {
    constructor(t, e, n)
    {
        super(new Uint32Array(t), e, n)
    }
}
class Di extends zn {
    constructor(t, e, n)
    {
        super(new Float32Array(t), e, n)
    }
}
let _v = 0;
const li = new le,
    sh = new He,
    Xr = new O,
    Kn = new Ms,
    Ko = new Ms,
    en = new O;
class Ni extends Rr {
    constructor()
    {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: _v++
        }),
        this.uuid = Ri(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex()
    {
        return this.index
    }
    setIndex(t)
    {
        return Array.isArray(t) ? this.index = new (lg(t) ? gg : mg)(t, 1) : this.index = t, this
    }
    getAttribute(t)
    {
        return this.attributes[t]
    }
    setAttribute(t, e)
    {
        return this.attributes[t] = e, this
    }
    deleteAttribute(t)
    {
        return delete this.attributes[t], this
    }
    hasAttribute(t)
    {
        return this.attributes[t] !== void 0
    }
    addGroup(t, e, n=0)
    {
        this.groups.push({
            start: t,
            count: e,
            materialIndex: n
        })
    }
    clearGroups()
    {
        this.groups = []
    }
    setDrawRange(t, e)
    {
        this.drawRange.start = t,
        this.drawRange.count = e
    }
    applyMatrix4(t)
    {
        const e = this.attributes.position;
        e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const s = new re().getNormalMatrix(t);
            n.applyNormalMatrix(s),
            n.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(t), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }
    applyQuaternion(t)
    {
        return li.makeRotationFromQuaternion(t), this.applyMatrix4(li), this
    }
    rotateX(t)
    {
        return li.makeRotationX(t), this.applyMatrix4(li), this
    }
    rotateY(t)
    {
        return li.makeRotationY(t), this.applyMatrix4(li), this
    }
    rotateZ(t)
    {
        return li.makeRotationZ(t), this.applyMatrix4(li), this
    }
    translate(t, e, n)
    {
        return li.makeTranslation(t, e, n), this.applyMatrix4(li), this
    }
    scale(t, e, n)
    {
        return li.makeScale(t, e, n), this.applyMatrix4(li), this
    }
    lookAt(t)
    {
        return sh.lookAt(t), sh.updateMatrix(), this.applyMatrix4(sh.matrix), this
    }
    center()
    {
        return this.computeBoundingBox(), this.boundingBox.getCenter(Xr).negate(), this.translate(Xr.x, Xr.y, Xr.z), this
    }
    setFromPoints(t)
    {
        const e = [];
        for (let n = 0, i = t.length; n < i; n++) {
            const s = t[n];
            e.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new Di(e, 3)), this
    }
    computeBoundingBox()
    {
        this.boundingBox === null && (this.boundingBox = new Ms);
        const t = this.attributes.position,
            e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new O(-1 / 0, -1 / 0, -1 / 0), new O(1 / 0, 1 / 0, 1 / 0));
            return
        }
        if (t !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(t), e)
                for (let n = 0, i = e.length; n < i; n++) {
                    const s = e[n];
                    Kn.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (en.addVectors(this.boundingBox.min, Kn.min), this.boundingBox.expandByPoint(en), en.addVectors(this.boundingBox.max, Kn.max), this.boundingBox.expandByPoint(en)) : (this.boundingBox.expandByPoint(Kn.min), this.boundingBox.expandByPoint(Kn.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere()
    {
        this.boundingSphere === null && (this.boundingSphere = new $i);
        const t = this.attributes.position,
            e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new O, 1 / 0);
            return
        }
        if (t) {
            const n = this.boundingSphere.center;
            if (Kn.setFromBufferAttribute(t), e)
                for (let s = 0, o = e.length; s < o; s++) {
                    const a = e[s];
                    Ko.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (en.addVectors(Kn.min, Ko.min), Kn.expandByPoint(en), en.addVectors(Kn.max, Ko.max), Kn.expandByPoint(en)) : (Kn.expandByPoint(Ko.min), Kn.expandByPoint(Ko.max))
                }
            Kn.getCenter(n);
            let i = 0;
            for (let s = 0, o = t.count; s < o; s++)
                en.fromBufferAttribute(t, s),
                i = Math.max(i, n.distanceToSquared(en));
            if (e)
                for (let s = 0, o = e.length; s < o; s++) {
                    const a = e[s],
                        l = this.morphTargetsRelative;
                    for (let c = 0, h = a.count; c < h; c++)
                        en.fromBufferAttribute(a, c),
                        l && (Xr.fromBufferAttribute(t, c), en.add(Xr)),
                        i = Math.max(i, n.distanceToSquared(en))
                }
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents()
    {
        const t = this.index,
            e = this.attributes;
        if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = e.position,
            i = e.normal,
            s = e.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new zn(new Float32Array(4 * n.count), 4));
        const o = this.getAttribute("tangent"),
            a = [],
            l = [];
        for (let R = 0; R < n.count; R++)
            a[R] = new O,
            l[R] = new O;
        const c = new O,
            h = new O,
            u = new O,
            d = new St,
            f = new St,
            m = new St,
            _ = new O,
            g = new O;
        function p(R, E, M) {
            c.fromBufferAttribute(n, R),
            h.fromBufferAttribute(n, E),
            u.fromBufferAttribute(n, M),
            d.fromBufferAttribute(s, R),
            f.fromBufferAttribute(s, E),
            m.fromBufferAttribute(s, M),
            h.sub(c),
            u.sub(c),
            f.sub(d),
            m.sub(d);
            const D = 1 / (f.x * m.y - m.x * f.y);
            isFinite(D) && (_.copy(h).multiplyScalar(m.y).addScaledVector(u, -f.y).multiplyScalar(D), g.copy(u).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(D), a[R].add(_), a[E].add(_), a[M].add(_), l[R].add(g), l[E].add(g), l[M].add(g))
        }
        let x = this.groups;
        x.length === 0 && (x = [{
            start: 0,
            count: t.count
        }]);
        for (let R = 0, E = x.length; R < E; ++R) {
            const M = x[R],
                D = M.start,
                I = M.count;
            for (let k = D, $ = D + I; k < $; k += 3)
                p(t.getX(k + 0), t.getX(k + 1), t.getX(k + 2))
        }
        const v = new O,
            y = new O,
            C = new O,
            A = new O;
        function T(R) {
            C.fromBufferAttribute(i, R),
            A.copy(C);
            const E = a[R];
            v.copy(E),
            v.sub(C.multiplyScalar(C.dot(E))).normalize(),
            y.crossVectors(A, E);
            const D = y.dot(l[R]) < 0 ? -1 : 1;
            o.setXYZW(R, v.x, v.y, v.z, D)
        }
        for (let R = 0, E = x.length; R < E; ++R) {
            const M = x[R],
                D = M.start,
                I = M.count;
            for (let k = D, $ = D + I; k < $; k += 3)
                T(t.getX(k + 0)),
                T(t.getX(k + 1)),
                T(t.getX(k + 2))
        }
    }
    computeVertexNormals()
    {
        const t = this.index,
            e = this.getAttribute("position");
        if (e !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
                n = new zn(new Float32Array(e.count * 3), 3),
                this.setAttribute("normal", n);
            else
                for (let d = 0, f = n.count; d < f; d++)
                    n.setXYZ(d, 0, 0, 0);
            const i = new O,
                s = new O,
                o = new O,
                a = new O,
                l = new O,
                c = new O,
                h = new O,
                u = new O;
            if (t)
                for (let d = 0, f = t.count; d < f; d += 3) {
                    const m = t.getX(d + 0),
                        _ = t.getX(d + 1),
                        g = t.getX(d + 2);
                    i.fromBufferAttribute(e, m),
                    s.fromBufferAttribute(e, _),
                    o.fromBufferAttribute(e, g),
                    h.subVectors(o, s),
                    u.subVectors(i, s),
                    h.cross(u),
                    a.fromBufferAttribute(n, m),
                    l.fromBufferAttribute(n, _),
                    c.fromBufferAttribute(n, g),
                    a.add(h),
                    l.add(h),
                    c.add(h),
                    n.setXYZ(m, a.x, a.y, a.z),
                    n.setXYZ(_, l.x, l.y, l.z),
                    n.setXYZ(g, c.x, c.y, c.z)
                }
            else
                for (let d = 0, f = e.count; d < f; d += 3)
                    i.fromBufferAttribute(e, d + 0),
                    s.fromBufferAttribute(e, d + 1),
                    o.fromBufferAttribute(e, d + 2),
                    h.subVectors(o, s),
                    u.subVectors(i, s),
                    h.cross(u),
                    n.setXYZ(d + 0, h.x, h.y, h.z),
                    n.setXYZ(d + 1, h.x, h.y, h.z),
                    n.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    normalizeNormals()
    {
        const t = this.attributes.normal;
        for (let e = 0, n = t.count; e < n; e++)
            en.fromBufferAttribute(t, e),
            en.normalize(),
            t.setXYZ(e, en.x, en.y, en.z)
    }
    toNonIndexed()
    {
        function t(a, l) {
            const c = a.array,
                h = a.itemSize,
                u = a.normalized,
                d = new c.constructor(l.length * h);
            let f = 0,
                m = 0;
            for (let _ = 0, g = l.length; _ < g; _++) {
                a.isInterleavedBufferAttribute ? f = l[_] * a.data.stride + a.offset : f = l[_] * h;
                for (let p = 0; p < h; p++)
                    d[m++] = c[f++]
            }
            return new zn(d, h, u)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const e = new Ni,
            n = this.index.array,
            i = this.attributes;
        for (const a in i) {
            const l = i[a],
                c = t(l, n);
            e.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = [],
                c = s[a];
            for (let h = 0, u = c.length; h < u; h++) {
                const d = c[h],
                    f = t(d, n);
                l.push(f)
            }
            e.morphAttributes[a] = l
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            e.addGroup(c.start, c.count, c.materialIndex)
        }
        return e
    }
    toJSON()
    {
        const t = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (t[c] = l[c]);
            return t
        }
        t.data = {
            attributes: {}
        };
        const e = this.index;
        e !== null && (t.data.index = {
            type: e.array.constructor.name,
            array: Array.prototype.slice.call(e.array)
        });
        const n = this.attributes;
        for (const l in n) {
            const c = n[l];
            t.data.attributes[l] = c.toJSON(t.data)
        }
        const i = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
                h = [];
            for (let u = 0, d = c.length; u < d; u++) {
                const f = c[u];
                h.push(f.toJSON(t.data))
            }
            h.length > 0 && (i[l] = h, s = !0)
        }
        s && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (t.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }), t
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
    copy(t)
    {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const e = {};
        this.name = t.name;
        const n = t.index;
        n !== null && this.setIndex(n.clone(e));
        const i = t.attributes;
        for (const c in i) {
            const h = i[c];
            this.setAttribute(c, h.clone(e))
        }
        const s = t.morphAttributes;
        for (const c in s) {
            const h = [],
                u = s[c];
            for (let d = 0, f = u.length; d < f; d++)
                h.push(u[d].clone(e));
            this.morphAttributes[c] = h
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const o = t.groups;
        for (let c = 0, h = o.length; c < h; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex)
        }
        const a = t.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = t.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
    }
    dispose()
    {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Wf = new le,
    er = new Ya,
    cl = new $i,
    Xf = new O,
    Yr = new O,
    $r = new O,
    qr = new O,
    rh = new O,
    hl = new O,
    ul = new St,
    dl = new St,
    fl = new St,
    Yf = new O,
    $f = new O,
    qf = new O,
    pl = new O,
    ml = new O;
class Un extends He {
    constructor(t=new Ni, e=new zs)
    {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = t,
        this.material = e,
        this.updateMorphTargets()
    }
    copy(t, e)
    {
        return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
    }
    updateMorphTargets()
    {
        const e = this.geometry.morphAttributes,
            n = Object.keys(e);
        if (n.length > 0) {
            const i = e[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(t, e)
    {
        const n = this.geometry,
            i = n.attributes.position,
            s = n.morphAttributes.position,
            o = n.morphTargetsRelative;
        e.fromBufferAttribute(i, t);
        const a = this.morphTargetInfluences;
        if (s && a) {
            hl.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const h = a[l],
                    u = s[l];
                h !== 0 && (rh.fromBufferAttribute(u, t), o ? hl.addScaledVector(rh, h) : hl.addScaledVector(rh.sub(e), h))
            }
            e.add(hl)
        }
        return e
    }
    raycast(t, e)
    {
        const n = this.geometry,
            i = this.material,
            s = this.matrixWorld;
        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), cl.copy(n.boundingSphere), cl.applyMatrix4(s), er.copy(t.ray).recast(t.near), !(cl.containsPoint(er.origin) === !1 && (er.intersectSphere(cl, Xf) === null || er.origin.distanceToSquared(Xf) > (t.far - t.near) ** 2)) && (Wf.copy(s).invert(), er.copy(t.ray).applyMatrix4(Wf), !(n.boundingBox !== null && er.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(t, e, er)))
    }
    _computeIntersections(t, e, n)
    {
        let i;
        const s = this.geometry,
            o = this.material,
            a = s.index,
            l = s.attributes.position,
            c = s.attributes.uv,
            h = s.attributes.uv1,
            u = s.attributes.normal,
            d = s.groups,
            f = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let m = 0, _ = d.length; m < _; m++) {
                    const g = d[m],
                        p = o[g.materialIndex],
                        x = Math.max(g.start, f.start),
                        v = Math.min(a.count, Math.min(g.start + g.count, f.start + f.count));
                    for (let y = x, C = v; y < C; y += 3) {
                        const A = a.getX(y),
                            T = a.getX(y + 1),
                            R = a.getX(y + 2);
                        i = gl(this, p, t, n, c, h, u, A, T, R),
                        i && (i.faceIndex = Math.floor(y / 3), i.face.materialIndex = g.materialIndex, e.push(i))
                    }
                }
            else {
                const m = Math.max(0, f.start),
                    _ = Math.min(a.count, f.start + f.count);
                for (let g = m, p = _; g < p; g += 3) {
                    const x = a.getX(g),
                        v = a.getX(g + 1),
                        y = a.getX(g + 2);
                    i = gl(this, o, t, n, c, h, u, x, v, y),
                    i && (i.faceIndex = Math.floor(g / 3), e.push(i))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let m = 0, _ = d.length; m < _; m++) {
                    const g = d[m],
                        p = o[g.materialIndex],
                        x = Math.max(g.start, f.start),
                        v = Math.min(l.count, Math.min(g.start + g.count, f.start + f.count));
                    for (let y = x, C = v; y < C; y += 3) {
                        const A = y,
                            T = y + 1,
                            R = y + 2;
                        i = gl(this, p, t, n, c, h, u, A, T, R),
                        i && (i.faceIndex = Math.floor(y / 3), i.face.materialIndex = g.materialIndex, e.push(i))
                    }
                }
            else {
                const m = Math.max(0, f.start),
                    _ = Math.min(l.count, f.start + f.count);
                for (let g = m, p = _; g < p; g += 3) {
                    const x = g,
                        v = g + 1,
                        y = g + 2;
                    i = gl(this, o, t, n, c, h, u, x, v, y),
                    i && (i.faceIndex = Math.floor(g / 3), e.push(i))
                }
            }
    }
}
function xv(r, t, e, n, i, s, o, a) {
    let l;
    if (t.side === kn ? l = n.intersectTriangle(o, s, i, !0, a) : l = n.intersectTriangle(i, s, o, t.side === _s, a), l === null)
        return null;
    ml.copy(a),
    ml.applyMatrix4(r.matrixWorld);
    const c = e.ray.origin.distanceTo(ml);
    return c < e.near || c > e.far ? null : {
        distance: c,
        point: ml.clone(),
        object: r
    }
}
function gl(r, t, e, n, i, s, o, a, l, c) {
    r.getVertexPosition(a, Yr),
    r.getVertexPosition(l, $r),
    r.getVertexPosition(c, qr);
    const h = xv(r, t, e, n, Yr, $r, qr, pl);
    if (h) {
        i && (ul.fromBufferAttribute(i, a), dl.fromBufferAttribute(i, l), fl.fromBufferAttribute(i, c), h.uv = Oi.getInterpolation(pl, Yr, $r, qr, ul, dl, fl, new St)),
        s && (ul.fromBufferAttribute(s, a), dl.fromBufferAttribute(s, l), fl.fromBufferAttribute(s, c), h.uv1 = Oi.getInterpolation(pl, Yr, $r, qr, ul, dl, fl, new St)),
        o && (Yf.fromBufferAttribute(o, a), $f.fromBufferAttribute(o, l), qf.fromBufferAttribute(o, c), h.normal = Oi.getInterpolation(pl, Yr, $r, qr, Yf, $f, qf, new O), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
        const u = {
            a,
            b: l,
            c,
            normal: new O,
            materialIndex: 0
        };
        Oi.getNormal(Yr, $r, qr, u.normal),
        h.face = u
    }
    return h
}
class $a extends Ni {
    constructor(t=1, e=1, n=1, i=1, s=1, o=1)
    {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        i = Math.floor(i),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = [],
            c = [],
            h = [],
            u = [];
        let d = 0,
            f = 0;
        m("z", "y", "x", -1, -1, n, e, t, o, s, 0),
        m("z", "y", "x", 1, -1, n, e, -t, o, s, 1),
        m("x", "z", "y", 1, 1, t, n, e, i, o, 2),
        m("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
        m("x", "y", "z", 1, -1, t, e, n, i, s, 4),
        m("x", "y", "z", -1, -1, t, e, -n, i, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new Di(c, 3)),
        this.setAttribute("normal", new Di(h, 3)),
        this.setAttribute("uv", new Di(u, 2));
        function m(_, g, p, x, v, y, C, A, T, R, E) {
            const M = y / T,
                D = C / R,
                I = y / 2,
                k = C / 2,
                $ = A / 2,
                j = T + 1,
                G = R + 1;
            let H = 0,
                V = 0;
            const nt = new O;
            for (let P = 0; P < G; P++) {
                const ct = P * D - k;
                for (let Ut = 0; Ut < j; Ut++) {
                    const Zt = Ut * M - I;
                    nt[_] = Zt * x,
                    nt[g] = ct * v,
                    nt[p] = $,
                    c.push(nt.x, nt.y, nt.z),
                    nt[_] = 0,
                    nt[g] = 0,
                    nt[p] = A > 0 ? 1 : -1,
                    h.push(nt.x, nt.y, nt.z),
                    u.push(Ut / T),
                    u.push(1 - P / R),
                    H += 1
                }
            }
            for (let P = 0; P < R; P++)
                for (let ct = 0; ct < T; ct++) {
                    const Ut = d + ct + j * P,
                        Zt = d + ct + j * (P + 1),
                        J = d + (ct + 1) + j * (P + 1),
                        it = d + (ct + 1) + j * P;
                    l.push(Ut, Zt, it),
                    l.push(Zt, J, it),
                    V += 6
                }
            a.addGroup(f, V, E),
            f += V,
            d += H
        }
    }
    copy(t)
    {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t)
    {
        return new $a(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
    }
}
function Ro(r) {
    const t = {};
    for (const e in r) {
        t[e] = {};
        for (const n in r[e]) {
            const i = r[e][n];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][n] = null) : t[e][n] = i.clone() : Array.isArray(i) ? t[e][n] = i.slice() : t[e][n] = i
        }
    }
    return t
}
function An(r) {
    const t = {};
    for (let e = 0; e < r.length; e++) {
        const n = Ro(r[e]);
        for (const i in n)
            t[i] = n[i]
    }
    return t
}
function vv(r) {
    const t = [];
    for (let e = 0; e < r.length; e++)
        t.push(r[e].clone());
    return t
}
function _g(r) {
    const t = r.getRenderTarget();
    return t === null ? r.outputColorSpace : t.isXRRenderTarget === !0 ? t.texture.colorSpace : me.workingColorSpace
}
const pc = {
    clone: Ro,
    merge: An
};
var yv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`

    ,
    Mv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`

    ;
class On extends Li {
    constructor(t)
    {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = yv,
        this.fragmentShader = Mv,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        t !== void 0 && this.setValues(t)
    }
    copy(t)
    {
        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ro(t.uniforms), this.uniformsGroups = vv(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
    }
    toJSON(t)
    {
        const e = super.toJSON(t);
        e.glslVersion = this.glslVersion,
        e.uniforms = {};
        for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture ? e.uniforms[i] = {
                type: "t",
                value: o.toJSON(t).uuid
            } : o && o.isColor ? e.uniforms[i] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? e.uniforms[i] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? e.uniforms[i] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? e.uniforms[i] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? e.uniforms[i] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? e.uniforms[i] = {
                type: "m4",
                value: o.toArray()
            } : e.uniforms[i] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
        e.vertexShader = this.vertexShader,
        e.fragmentShader = this.fragmentShader,
        e.lights = this.lights,
        e.clipping = this.clipping;
        const n = {};
        for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
        return Object.keys(n).length > 0 && (e.extensions = n), e
    }
}
class xg extends He {
    constructor()
    {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new le,
        this.projectionMatrix = new le,
        this.projectionMatrixInverse = new le,
        this.coordinateSystem = us
    }
    copy(t, e)
    {
        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
    }
    getWorldDirection(t)
    {
        return super.getWorldDirection(t).negate()
    }
    updateMatrixWorld(t)
    {
        super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(t, e)
    {
        super.updateWorldMatrix(t, e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
}
const Rs = new O,
    Kf = new St,
    jf = new St;
class yn extends xg {
    constructor(t=50, e=1, n=.1, i=2e3)
    {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = t,
        this.zoom = 1,
        this.near = n,
        this.far = i,
        this.focus = 10,
        this.aspect = e,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(t, e)
    {
        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
    }
    setFocalLength(t)
    {
        const e = .5 * this.getFilmHeight() / t;
        this.fov = Co * 2 * Math.atan(e),
        this.updateProjectionMatrix()
    }
    getFocalLength()
    {
        const t = Math.tan(pa * .5 * this.fov);
        return .5 * this.getFilmHeight() / t
    }
    getEffectiveFOV()
    {
        return Co * 2 * Math.atan(Math.tan(pa * .5 * this.fov) / this.zoom)
    }
    getFilmWidth()
    {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight()
    {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(t, e, n)
    {
        Rs.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        e.set(Rs.x, Rs.y).multiplyScalar(-t / Rs.z),
        Rs.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        n.set(Rs.x, Rs.y).multiplyScalar(-t / Rs.z)
    }
    getViewSize(t, e)
    {
        return this.getViewBounds(t, Kf, jf), e.subVectors(jf, Kf)
    }
    setViewOffset(t, e, n, i, s, o)
    {
        this.aspect = t / e,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = t,
        this.view.fullHeight = e,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset()
    {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix()
    {
        const t = this.near;
        let e = t * Math.tan(pa * .5 * this.fov) / this.zoom,
            n = 2 * e,
            i = this.aspect * n,
            s = -.5 * i;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
                c = o.fullHeight;
            s += o.offsetX * i / l,
            e -= o.offsetY * n / c,
            i *= o.width / l,
            n *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += t * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + i, e, e - n, t, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t)
    {
        const e = super.toJSON(t);
        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
    }
}
const Kr = -90,
    jr = 1;
class Sv extends He {
    constructor(t, e, n)
    {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const i = new yn(Kr, jr, t, e);
        i.layers = this.layers,
        this.add(i);
        const s = new yn(Kr, jr, t, e);
        s.layers = this.layers,
        this.add(s);
        const o = new yn(Kr, jr, t, e);
        o.layers = this.layers,
        this.add(o);
        const a = new yn(Kr, jr, t, e);
        a.layers = this.layers,
        this.add(a);
        const l = new yn(Kr, jr, t, e);
        l.layers = this.layers,
        this.add(l);
        const c = new yn(Kr, jr, t, e);
        c.layers = this.layers,
        this.add(c)
    }
    updateCoordinateSystem()
    {
        const t = this.coordinateSystem,
            e = this.children.concat(),
            [n, i, s, o, a, l] = e;
        for (const c of e)
            this.remove(c);
        if (t === us)
            n.up.set(0, 1, 0),
            n.lookAt(1, 0, 0),
            i.up.set(0, 1, 0),
            i.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, -1);
        else if (t === dc)
            n.up.set(0, -1, 0),
            n.lookAt(-1, 0, 0),
            i.up.set(0, -1, 0),
            i.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
        for (const c of e)
            this.add(c),
            c.updateMatrixWorld()
    }
    update(t, e)
    {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: n, activeMipmapLevel: i} = this;
        this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
        const [s, o, a, l, c, h] = this.children,
            u = t.getRenderTarget(),
            d = t.getActiveCubeFace(),
            f = t.getActiveMipmapLevel(),
            m = t.xr.enabled;
        t.xr.enabled = !1;
        const _ = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        t.setRenderTarget(n, 0, i),
        t.render(e, s),
        t.setRenderTarget(n, 1, i),
        t.render(e, o),
        t.setRenderTarget(n, 2, i),
        t.render(e, a),
        t.setRenderTarget(n, 3, i),
        t.render(e, l),
        t.setRenderTarget(n, 4, i),
        t.render(e, c),
        n.texture.generateMipmaps = _,
        t.setRenderTarget(n, 5, i),
        t.render(e, h),
        t.setRenderTarget(u, d, f),
        t.xr.enabled = m,
        n.texture.needsPMREMUpdate = !0
    }
}
class vg extends an {
    constructor(t, e, n, i, s, o, a, l, c, h)
    {
        t = t !== void 0 ? t : [],
        e = e !== void 0 ? e : To,
        super(t, e, n, i, s, o, a, l, c, h),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images()
    {
        return this.image
    }
    set images(t)
    {
        this.image = t
    }
}
class Tv extends Pi {
    constructor(t=1, e={})
    {
        super(t, t, e),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
                width: t,
                height: t,
                depth: 1
            },
            i = [n, n, n, n, n, n];
        this.texture = new vg(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1,
        this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : ti
    }
    fromEquirectangularTexture(t, e)
    {
        this.texture.type = e.type,
        this.texture.colorSpace = e.colorSpace,
        this.texture.generateMipmaps = e.generateMipmaps,
        this.texture.minFilter = e.minFilter,
        this.texture.magFilter = e.magFilter;
        const n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`

















                ,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
















            },
            i = new $a(5, 5, 5),
            s = new On({
                name: "CubemapFromEquirect",
                uniforms: Ro(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: kn,
                blending: ps
            });
        s.uniforms.tEquirect.value = e;
        const o = new Un(i, s),
            a = e.minFilter;
        return e.minFilter === hs && (e.minFilter = ti), new Sv(1, 10, this).update(t, o), e.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
    }
    clear(t, e, n, i)
    {
        const s = t.getRenderTarget();
        for (let o = 0; o < 6; o++)
            t.setRenderTarget(this, o),
            t.clear(e, n, i);
        t.setRenderTarget(s)
    }
}
const oh = new O,
    Ev = new O,
    bv = new re;
class Fs {
    constructor(t=new O(1, 0, 0), e=0)
    {
        this.isPlane = !0,
        this.normal = t,
        this.constant = e
    }
    set(t, e)
    {
        return this.normal.copy(t), this.constant = e, this
    }
    setComponents(t, e, n, i)
    {
        return this.normal.set(t, e, n), this.constant = i, this
    }
    setFromNormalAndCoplanarPoint(t, e)
    {
        return this.normal.copy(t), this.constant = -e.dot(this.normal), this
    }
    setFromCoplanarPoints(t, e, n)
    {
        const i = oh.subVectors(n, e).cross(Ev.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, t), this
    }
    copy(t)
    {
        return this.normal.copy(t.normal), this.constant = t.constant, this
    }
    normalize()
    {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), this.constant *= t, this
    }
    negate()
    {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(t)
    {
        return this.normal.dot(t) + this.constant
    }
    distanceToSphere(t)
    {
        return this.distanceToPoint(t.center) - t.radius
    }
    projectPoint(t, e)
    {
        return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
    }
    intersectLine(t, e)
    {
        const n = t.delta(oh),
            i = this.normal.dot(n);
        if (i === 0)
            return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
        const s = -(t.start.dot(this.normal) + this.constant) / i;
        return s < 0 || s > 1 ? null : e.copy(t.start).addScaledVector(n, s)
    }
    intersectsLine(t)
    {
        const e = this.distanceToPoint(t.start),
            n = this.distanceToPoint(t.end);
        return e < 0 && n > 0 || n < 0 && e > 0
    }
    intersectsBox(t)
    {
        return t.intersectsPlane(this)
    }
    intersectsSphere(t)
    {
        return t.intersectsPlane(this)
    }
    coplanarPoint(t)
    {
        return t.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(t, e)
    {
        const n = e || bv.getNormalMatrix(t),
            i = this.coplanarPoint(oh).applyMatrix4(t),
            s = this.normal.applyMatrix3(n).normalize();
        return this.constant = -i.dot(s), this
    }
    translate(t)
    {
        return this.constant -= t.dot(this.normal), this
    }
    equals(t)
    {
        return t.normal.equals(this.normal) && t.constant === this.constant
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
}
const nr = new $i,
    _l = new O;
class Td {
    constructor(t=new Fs, e=new Fs, n=new Fs, i=new Fs, s=new Fs, o=new Fs)
    {
        this.planes = [t, e, n, i, s, o]
    }
    set(t, e, n, i, s, o)
    {
        const a = this.planes;
        return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(s), a[5].copy(o), this
    }
    copy(t)
    {
        const e = this.planes;
        for (let n = 0; n < 6; n++)
            e[n].copy(t.planes[n]);
        return this
    }
    setFromProjectionMatrix(t, e=us)
    {
        const n = this.planes,
            i = t.elements,
            s = i[0],
            o = i[1],
            a = i[2],
            l = i[3],
            c = i[4],
            h = i[5],
            u = i[6],
            d = i[7],
            f = i[8],
            m = i[9],
            _ = i[10],
            g = i[11],
            p = i[12],
            x = i[13],
            v = i[14],
            y = i[15];
        if (n[0].setComponents(l - s, d - c, g - f, y - p).normalize(), n[1].setComponents(l + s, d + c, g + f, y + p).normalize(), n[2].setComponents(l + o, d + h, g + m, y + x).normalize(), n[3].setComponents(l - o, d - h, g - m, y - x).normalize(), n[4].setComponents(l - a, d - u, g - _, y - v).normalize(), e === us)
            n[5].setComponents(l + a, d + u, g + _, y + v).normalize();
        else if (e === dc)
            n[5].setComponents(a, u, _, v).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
        return this
    }
    intersectsObject(t)
    {
        if (t.boundingSphere !== void 0)
            t.boundingSphere === null && t.computeBoundingSphere(),
            nr.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
        else {
            const e = t.geometry;
            e.boundingSphere === null && e.computeBoundingSphere(),
            nr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
        }
        return this.intersectsSphere(nr)
    }
    intersectsSprite(t)
    {
        return nr.center.set(0, 0, 0), nr.radius = .7071067811865476, nr.applyMatrix4(t.matrixWorld), this.intersectsSphere(nr)
    }
    intersectsSphere(t)
    {
        const e = this.planes,
            n = t.center,
            i = -t.radius;
        for (let s = 0; s < 6; s++)
            if (e[s].distanceToPoint(n) < i)
                return !1;
        return !0
    }
    intersectsBox(t)
    {
        const e = this.planes;
        for (let n = 0; n < 6; n++) {
            const i = e[n];
            if (_l.x = i.normal.x > 0 ? t.max.x : t.min.x, _l.y = i.normal.y > 0 ? t.max.y : t.min.y, _l.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(_l) < 0)
                return !1
        }
        return !0
    }
    containsPoint(t)
    {
        const e = this.planes;
        for (let n = 0; n < 6; n++)
            if (e[n].distanceToPoint(t) < 0)
                return !1;
        return !0
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
}
function yg() {
    let r = null,
        t = !1,
        e = null,
        n = null;
    function i(s, o) {
        e(s, o),
        n = r.requestAnimationFrame(i)
    }
    return {
        start: function() {
            t !== !0 && e !== null && (n = r.requestAnimationFrame(i), t = !0)
        },
        stop: function() {
            r.cancelAnimationFrame(n),
            t = !1
        },
        setAnimationLoop: function(s) {
            e = s
        },
        setContext: function(s) {
            r = s
        }
    }
}
function wv(r) {
    const t = new WeakMap;
    function e(a, l) {
        const c = a.array,
            h = a.usage,
            u = c.byteLength,
            d = r.createBuffer();
        r.bindBuffer(l, d),
        r.bufferData(l, c, h),
        a.onUploadCallback();
        let f;
        if (c instanceof Float32Array)
            f = r.FLOAT;
        else if (c instanceof Uint16Array)
            a.isFloat16BufferAttribute ? f = r.HALF_FLOAT : f = r.UNSIGNED_SHORT;
        else if (c instanceof Int16Array)
            f = r.SHORT;
        else if (c instanceof Uint32Array)
            f = r.UNSIGNED_INT;
        else if (c instanceof Int32Array)
            f = r.INT;
        else if (c instanceof Int8Array)
            f = r.BYTE;
        else if (c instanceof Uint8Array)
            f = r.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray)
            f = r.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
            buffer: d,
            type: f,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: u
        }
    }
    function n(a, l, c) {
        const h = l.array,
            u = l._updateRange,
            d = l.updateRanges;
        if (r.bindBuffer(c, a), u.count === -1 && d.length === 0 && r.bufferSubData(c, 0, h), d.length !== 0) {
            for (let f = 0, m = d.length; f < m; f++) {
                const _ = d[f];
                r.bufferSubData(c, _.start * h.BYTES_PER_ELEMENT, h, _.start, _.count)
            }
            l.clearUpdateRanges()
        }
        u.count !== -1 && (r.bufferSubData(c, u.offset * h.BYTES_PER_ELEMENT, h, u.offset, u.count), u.count = -1),
        l.onUploadCallback()
    }
    function i(a) {
        return a.isInterleavedBufferAttribute && (a = a.data), t.get(a)
    }
    function s(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const l = t.get(a);
        l && (r.deleteBuffer(l.buffer), t.delete(a))
    }
    function o(a, l) {
        if (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute) {
            const h = t.get(a);
            (!h || h.version < a.version) && t.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        const c = t.get(a);
        if (c === void 0)
            t.set(a, e(a, l));
        else if (c.version < a.version) {
            if (c.size !== a.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            n(c.buffer, a, l),
            c.version = a.version
        }
    }
    return {
        get: i,
        remove: s,
        update: o
    }
}
class qa extends Ni {
    constructor(t=1, e=1, n=1, i=1)
    {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        };
        const s = t / 2,
            o = e / 2,
            a = Math.floor(n),
            l = Math.floor(i),
            c = a + 1,
            h = l + 1,
            u = t / a,
            d = e / l,
            f = [],
            m = [],
            _ = [],
            g = [];
        for (let p = 0; p < h; p++) {
            const x = p * d - o;
            for (let v = 0; v < c; v++) {
                const y = v * u - s;
                m.push(y, -x, 0),
                _.push(0, 0, 1),
                g.push(v / a),
                g.push(1 - p / l)
            }
        }
        for (let p = 0; p < l; p++)
            for (let x = 0; x < a; x++) {
                const v = x + c * p,
                    y = x + c * (p + 1),
                    C = x + 1 + c * (p + 1),
                    A = x + 1 + c * p;
                f.push(v, y, A),
                f.push(y, C, A)
            }
        this.setIndex(f),
        this.setAttribute("position", new Di(m, 3)),
        this.setAttribute("normal", new Di(_, 3)),
        this.setAttribute("uv", new Di(g, 2))
    }
    copy(t)
    {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t)
    {
        return new qa(t.width, t.height, t.widthSegments, t.heightSegments)
    }
}
var Av = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`

    ,
    Cv = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`


































    ,
    Rv = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`

    ,
    Pv = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`

    ,
    Lv = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`






    ,
    Dv = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`

    ,
    Nv = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`












    ,
    Iv = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`


    ,
    Fv = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`

































    ,
    Uv = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`

    ,
    Ov = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`


    ,
    zv = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`


    ,
    Bv = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`













    ,
    kv = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`






























































    ,
    Hv = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`




















    ,
    Vv = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`













































    ,
    Gv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`


    ,
    Wv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`

    ,
    Xv = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`

    ,
    Yv = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`



    ,
    $v = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`



    ,
    qv = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`



    ,
    Kv = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`













    ,
    jv = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`









































































    ,
    Zv = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`




























































































    ,
    Jv = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`




























    ,
    Qv = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`



    ,
    ty = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`

    ,
    ey = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`


    ,
    ny = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`

    ,
    iy = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    sy = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`





















    ,
    ry = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`




























    ,
    oy = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`









    ,
    ay = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`










    ,
    ly = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`










    ,
    cy = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
















    ,
    hy = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`

    ,
    uy = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`

    ,
    dy = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`






    ,
    fy = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`








    ,
    py = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`











    ,
    my = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`


    ,
    gy = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`

    ,
    _y = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`













    ,
    xy = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`



















































































































    ,
    vy = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
































    ,
    yy = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
    ,
    My = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`











    ,
    Sy = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`



    ,
    Ty = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
















    ,
    Ey = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`





















































































    ,
    by = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`












































































































































































































































































































    ,
    wy = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`


















































































































    ,
    Ay = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`


















    ,
    Cy = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`




    ,
    Ry = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`

    ,
    Py = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`



    ,
    Ly = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`


    ,
    Dy = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`


    ,
    Ny = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`






    ,
    Iy = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`

    ,
    Fy = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`











    ,
    Uy = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`











    ,
    Oy = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`



    ,
    zy = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`

    ,
    By = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`





    ,
    ky = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`








    ,
    Hy = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`




    ,
    Vy = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`













    ,
    Gy = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`




    ,
    Wy = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`








































    ,
    Xy = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`














    ,
    Yy = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`





    ,
    $y = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`





    ,
    qy = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`





    ,
    Ky = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`





















    ,
    jy = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`

    ,
    Zy = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`



    ,
    Jy = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`








    ,
    Qy = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`




    ,
    tM = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`





    ,
    eM = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`




































































    ,
    nM = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`

    ,
    iM = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`







    ,
    sM = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`

    ,
    rM = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`






    ,
    oM = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`



    ,
    aM = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`

    ,
    lM = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`

























































































































































































    ,
    cM = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`








































    ,
    hM = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`































    ,
    uM = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`































    ,
    dM = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`




    ,
    fM = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`














    ,
    pM = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`







    ,
    mM = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`










    ,
    gM = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`





    ,
    _M = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`

    ,
    xM = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`

    ,
    vM = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
































































































    ,
    yM = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`




















    ,
    MM = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`


































































































































    ,
    SM = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`





































































    ,
    TM = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`





























































































    ,
    EM = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`






































































    ,
    bM = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`








    ;
const wM = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`




    ,
    AM = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`











    ,
    CM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`






    ,
    RM = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`






















    ,
    PM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`






    ,
    LM = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`









    ,
    DM = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`


























    ,
    NM = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`

































    ,
    IM = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`


























    ,
    FM = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`























    ,
    UM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`





    ,
    OM = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`








    ,
    zM = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`





















    ,
    BM = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`



























    ,
    kM = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`































    ,
    HM = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`















































    ,
    VM = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`






































    ,
    GM = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
























































    ,
    WM = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`

































    ,
    XM = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`













































    ,
    YM = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
































    ,
    $M = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`





















    ,
    qM = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`






































    ,
    KM = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`


























































    ,
    jM = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`










































    ,
    ZM = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`




























































































































    ,
    JM = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`




































    ,
    QM = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`




















































    ,
    tS = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`






























    ,
    eS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
























    ,
    nS = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`






















    ,
    iS = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`















    ,
    sS = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`

























    ,
    rS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
























    ,
    te = {
        alphahash_fragment: Av,
        alphahash_pars_fragment: Cv,
        alphamap_fragment: Rv,
        alphamap_pars_fragment: Pv,
        alphatest_fragment: Lv,
        alphatest_pars_fragment: Dv,
        aomap_fragment: Nv,
        aomap_pars_fragment: Iv,
        batching_pars_vertex: Fv,
        batching_vertex: Uv,
        begin_vertex: Ov,
        beginnormal_vertex: zv,
        bsdfs: Bv,
        iridescence_fragment: kv,
        bumpmap_pars_fragment: Hv,
        clipping_planes_fragment: Vv,
        clipping_planes_pars_fragment: Gv,
        clipping_planes_pars_vertex: Wv,
        clipping_planes_vertex: Xv,
        color_fragment: Yv,
        color_pars_fragment: $v,
        color_pars_vertex: qv,
        color_vertex: Kv,
        common: jv,
        cube_uv_reflection_fragment: Zv,
        defaultnormal_vertex: Jv,
        displacementmap_pars_vertex: Qv,
        displacementmap_vertex: ty,
        emissivemap_fragment: ey,
        emissivemap_pars_fragment: ny,
        colorspace_fragment: iy,
        colorspace_pars_fragment: sy,
        envmap_fragment: ry,
        envmap_common_pars_fragment: oy,
        envmap_pars_fragment: ay,
        envmap_pars_vertex: ly,
        envmap_physical_pars_fragment: vy,
        envmap_vertex: cy,
        fog_vertex: hy,
        fog_pars_vertex: uy,
        fog_fragment: dy,
        fog_pars_fragment: fy,
        gradientmap_pars_fragment: py,
        lightmap_pars_fragment: my,
        lights_lambert_fragment: gy,
        lights_lambert_pars_fragment: _y,
        lights_pars_begin: xy,
        lights_toon_fragment: yy,
        lights_toon_pars_fragment: My,
        lights_phong_fragment: Sy,
        lights_phong_pars_fragment: Ty,
        lights_physical_fragment: Ey,
        lights_physical_pars_fragment: by,
        lights_fragment_begin: wy,
        lights_fragment_maps: Ay,
        lights_fragment_end: Cy,
        logdepthbuf_fragment: Ry,
        logdepthbuf_pars_fragment: Py,
        logdepthbuf_pars_vertex: Ly,
        logdepthbuf_vertex: Dy,
        map_fragment: Ny,
        map_pars_fragment: Iy,
        map_particle_fragment: Fy,
        map_particle_pars_fragment: Uy,
        metalnessmap_fragment: Oy,
        metalnessmap_pars_fragment: zy,
        morphinstance_vertex: By,
        morphcolor_vertex: ky,
        morphnormal_vertex: Hy,
        morphtarget_pars_vertex: Vy,
        morphtarget_vertex: Gy,
        normal_fragment_begin: Wy,
        normal_fragment_maps: Xy,
        normal_pars_fragment: Yy,
        normal_pars_vertex: $y,
        normal_vertex: qy,
        normalmap_pars_fragment: Ky,
        clearcoat_normal_fragment_begin: jy,
        clearcoat_normal_fragment_maps: Zy,
        clearcoat_pars_fragment: Jy,
        iridescence_pars_fragment: Qy,
        opaque_fragment: tM,
        packing: eM,
        premultiplied_alpha_fragment: nM,
        project_vertex: iM,
        dithering_fragment: sM,
        dithering_pars_fragment: rM,
        roughnessmap_fragment: oM,
        roughnessmap_pars_fragment: aM,
        shadowmap_pars_fragment: lM,
        shadowmap_pars_vertex: cM,
        shadowmap_vertex: hM,
        shadowmask_pars_fragment: uM,
        skinbase_vertex: dM,
        skinning_pars_vertex: fM,
        skinning_vertex: pM,
        skinnormal_vertex: mM,
        specularmap_fragment: gM,
        specularmap_pars_fragment: _M,
        tonemapping_fragment: xM,
        tonemapping_pars_fragment: vM,
        transmission_fragment: yM,
        transmission_pars_fragment: MM,
        uv_pars_fragment: SM,
        uv_pars_vertex: TM,
        uv_vertex: EM,
        worldpos_vertex: bM,
        background_vert: wM,
        background_frag: AM,
        backgroundCube_vert: CM,
        backgroundCube_frag: RM,
        cube_vert: PM,
        cube_frag: LM,
        depth_vert: DM,
        depth_frag: NM,
        distanceRGBA_vert: IM,
        distanceRGBA_frag: FM,
        equirect_vert: UM,
        equirect_frag: OM,
        linedashed_vert: zM,
        linedashed_frag: BM,
        meshbasic_vert: kM,
        meshbasic_frag: HM,
        meshlambert_vert: VM,
        meshlambert_frag: GM,
        meshmatcap_vert: WM,
        meshmatcap_frag: XM,
        meshnormal_vert: YM,
        meshnormal_frag: $M,
        meshphong_vert: qM,
        meshphong_frag: KM,
        meshphysical_vert: jM,
        meshphysical_frag: ZM,
        meshtoon_vert: JM,
        meshtoon_frag: QM,
        points_vert: tS,
        points_frag: eS,
        shadow_vert: nS,
        shadow_frag: iS,
        sprite_vert: sS,
        sprite_frag: rS
    },
    _t = {
        common: {
            diffuse: {
                value: new Gt(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new re
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new re
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new re
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new re
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new re
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new re
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new re
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new re
            },
            normalScale: {
                value: new St(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new re
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new re
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new re
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new re
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Gt(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Gt(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new re
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new re
            }
        },
        sprite: {
            diffuse: {
                value: new Gt(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new St(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new re
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new re
            },
            alphaTest: {
                value: 0
            }
        }
    },
    Ui = {
        basic: {
            uniforms: An([_t.common, _t.specularmap, _t.envmap, _t.aomap, _t.lightmap, _t.fog]),
            vertexShader: te.meshbasic_vert,
            fragmentShader: te.meshbasic_frag
        },
        lambert: {
            uniforms: An([_t.common, _t.specularmap, _t.envmap, _t.aomap, _t.lightmap, _t.emissivemap, _t.bumpmap, _t.normalmap, _t.displacementmap, _t.fog, _t.lights, {
                emissive: {
                    value: new Gt(0)
                }
            }]),
            vertexShader: te.meshlambert_vert,
            fragmentShader: te.meshlambert_frag
        },
        phong: {
            uniforms: An([_t.common, _t.specularmap, _t.envmap, _t.aomap, _t.lightmap, _t.emissivemap, _t.bumpmap, _t.normalmap, _t.displacementmap, _t.fog, _t.lights, {
                emissive: {
                    value: new Gt(0)
                },
                specular: {
                    value: new Gt(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: te.meshphong_vert,
            fragmentShader: te.meshphong_frag
        },
        standard: {
            uniforms: An([_t.common, _t.envmap, _t.aomap, _t.lightmap, _t.emissivemap, _t.bumpmap, _t.normalmap, _t.displacementmap, _t.roughnessmap, _t.metalnessmap, _t.fog, _t.lights, {
                emissive: {
                    value: new Gt(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: te.meshphysical_vert,
            fragmentShader: te.meshphysical_frag
        },
        toon: {
            uniforms: An([_t.common, _t.aomap, _t.lightmap, _t.emissivemap, _t.bumpmap, _t.normalmap, _t.displacementmap, _t.gradientmap, _t.fog, _t.lights, {
                emissive: {
                    value: new Gt(0)
                }
            }]),
            vertexShader: te.meshtoon_vert,
            fragmentShader: te.meshtoon_frag
        },
        matcap: {
            uniforms: An([_t.common, _t.bumpmap, _t.normalmap, _t.displacementmap, _t.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: te.meshmatcap_vert,
            fragmentShader: te.meshmatcap_frag
        },
        points: {
            uniforms: An([_t.points, _t.fog]),
            vertexShader: te.points_vert,
            fragmentShader: te.points_frag
        },
        dashed: {
            uniforms: An([_t.common, _t.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: te.linedashed_vert,
            fragmentShader: te.linedashed_frag
        },
        depth: {
            uniforms: An([_t.common, _t.displacementmap]),
            vertexShader: te.depth_vert,
            fragmentShader: te.depth_frag
        },
        normal: {
            uniforms: An([_t.common, _t.bumpmap, _t.normalmap, _t.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: te.meshnormal_vert,
            fragmentShader: te.meshnormal_frag
        },
        sprite: {
            uniforms: An([_t.sprite, _t.fog]),
            vertexShader: te.sprite_vert,
            fragmentShader: te.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new re
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: te.background_vert,
            fragmentShader: te.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new re
                }
            },
            vertexShader: te.backgroundCube_vert,
            fragmentShader: te.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: te.cube_vert,
            fragmentShader: te.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: te.equirect_vert,
            fragmentShader: te.equirect_frag
        },
        distanceRGBA: {
            uniforms: An([_t.common, _t.displacementmap, {
                referencePosition: {
                    value: new O
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: te.distanceRGBA_vert,
            fragmentShader: te.distanceRGBA_frag
        },
        shadow: {
            uniforms: An([_t.lights, _t.fog, {
                color: {
                    value: new Gt(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: te.shadow_vert,
            fragmentShader: te.shadow_frag
        }
    };
Ui.physical = {
    uniforms: An([Ui.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new re
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new re
        },
        clearcoatNormalScale: {
            value: new St(1, 1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new re
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new re
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new re
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Gt(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new re
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new re
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new re
        },
        transmissionSamplerSize: {
            value: new St
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new re
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Gt(0)
        },
        specularColor: {
            value: new Gt(1, 1, 1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new re
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new re
        },
        anisotropyVector: {
            value: new St
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new re
        }
    }]),
    vertexShader: te.meshphysical_vert,
    fragmentShader: te.meshphysical_frag
};
const xl = {
        r: 0,
        b: 0,
        g: 0
    },
    ir = new Xi,
    oS = new le;
function aS(r, t, e, n, i, s, o) {
    const a = new Gt(0);
    let l = s === !0 ? 0 : 1,
        c,
        h,
        u = null,
        d = 0,
        f = null;
    function m(x) {
        let v = x.isScene === !0 ? x.background : null;
        return v && v.isTexture && (v = (x.backgroundBlurriness > 0 ? e : t).get(v)), v
    }
    function _(x) {
        let v = !1;
        const y = m(x);
        y === null ? p(a, l) : y && y.isColor && (p(y, 1), v = !0);
        const C = r.xr.getEnvironmentBlendMode();
        C === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : C === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o),
        (r.autoClear || v) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil))
    }
    function g(x, v) {
        const y = m(v);
        y && (y.isCubeTexture || y.mapping === Rc) ? (h === void 0 && (h = new Un(new $a(1, 1, 1), new On({
            name: "BackgroundCubeMaterial",
            uniforms: Ro(Ui.backgroundCube.uniforms),
            vertexShader: Ui.backgroundCube.vertexShader,
            fragmentShader: Ui.backgroundCube.fragmentShader,
            side: kn,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(C, A, T) {
            this.matrixWorld.copyPosition(T.matrixWorld)
        }, Object.defineProperty(h.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }), i.update(h)), ir.copy(v.backgroundRotation), ir.x *= -1, ir.y *= -1, ir.z *= -1, y.isCubeTexture && y.isRenderTargetTexture === !1 && (ir.y *= -1, ir.z *= -1), h.material.uniforms.envMap.value = y, h.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(oS.makeRotationFromEuler(ir)), h.material.toneMapped = me.getTransfer(y.colorSpace) !== Ne, (u !== y || d !== y.version || f !== r.toneMapping) && (h.material.needsUpdate = !0, u = y, d = y.version, f = r.toneMapping), h.layers.enableAll(), x.unshift(h, h.geometry, h.material, 0, 0, null)) : y && y.isTexture && (c === void 0 && (c = new Un(new qa(2, 2), new On({
            name: "BackgroundMaterial",
            uniforms: Ro(Ui.background.uniforms),
            vertexShader: Ui.background.vertexShader,
            fragmentShader: Ui.background.fragmentShader,
            side: _s,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }), i.update(c)), c.material.uniforms.t2D.value = y, c.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, c.material.toneMapped = me.getTransfer(y.colorSpace) !== Ne, y.matrixAutoUpdate === !0 && y.updateMatrix(), c.material.uniforms.uvTransform.value.copy(y.matrix), (u !== y || d !== y.version || f !== r.toneMapping) && (c.material.needsUpdate = !0, u = y, d = y.version, f = r.toneMapping), c.layers.enableAll(), x.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function p(x, v) {
        x.getRGB(xl, _g(r)),
        n.buffers.color.setClear(xl.r, xl.g, xl.b, v, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(x, v=1) {
            a.set(x),
            l = v,
            p(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(x) {
            l = x,
            p(a, l)
        },
        render: _,
        addToRenderList: g
    }
}
function lS(r, t) {
    const e = r.getParameter(r.MAX_VERTEX_ATTRIBS),
        n = {},
        i = d(null);
    let s = i,
        o = !1;
    function a(M, D, I, k, $) {
        let j = !1;
        const G = u(k, I, D);
        s !== G && (s = G, c(s.object)),
        j = f(M, k, I, $),
        j && m(M, k, I, $),
        $ !== null && t.update($, r.ELEMENT_ARRAY_BUFFER),
        (j || o) && (o = !1, y(M, D, I, k), $ !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get($).buffer))
    }
    function l() {
        return r.createVertexArray()
    }
    function c(M) {
        return r.bindVertexArray(M)
    }
    function h(M) {
        return r.deleteVertexArray(M)
    }
    function u(M, D, I) {
        const k = I.wireframe === !0;
        let $ = n[M.id];
        $ === void 0 && ($ = {}, n[M.id] = $);
        let j = $[D.id];
        j === void 0 && (j = {}, $[D.id] = j);
        let G = j[k];
        return G === void 0 && (G = d(l()), j[k] = G), G
    }
    function d(M) {
        const D = [],
            I = [],
            k = [];
        for (let $ = 0; $ < e; $++)
            D[$] = 0,
            I[$] = 0,
            k[$] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: D,
            enabledAttributes: I,
            attributeDivisors: k,
            object: M,
            attributes: {},
            index: null
        }
    }
    function f(M, D, I, k) {
        const $ = s.attributes,
            j = D.attributes;
        let G = 0;
        const H = I.getAttributes();
        for (const V in H)
            if (H[V].location >= 0) {
                const P = $[V];
                let ct = j[V];
                if (ct === void 0 && (V === "instanceMatrix" && M.instanceMatrix && (ct = M.instanceMatrix), V === "instanceColor" && M.instanceColor && (ct = M.instanceColor)), P === void 0 || P.attribute !== ct || ct && P.data !== ct.data)
                    return !0;
                G++
            }
        return s.attributesNum !== G || s.index !== k
    }
    function m(M, D, I, k) {
        const $ = {},
            j = D.attributes;
        let G = 0;
        const H = I.getAttributes();
        for (const V in H)
            if (H[V].location >= 0) {
                let P = j[V];
                P === void 0 && (V === "instanceMatrix" && M.instanceMatrix && (P = M.instanceMatrix), V === "instanceColor" && M.instanceColor && (P = M.instanceColor));
                const ct = {};
                ct.attribute = P,
                P && P.data && (ct.data = P.data),
                $[V] = ct,
                G++
            }
        s.attributes = $,
        s.attributesNum = G,
        s.index = k
    }
    function _() {
        const M = s.newAttributes;
        for (let D = 0, I = M.length; D < I; D++)
            M[D] = 0
    }
    function g(M) {
        p(M, 0)
    }
    function p(M, D) {
        const I = s.newAttributes,
            k = s.enabledAttributes,
            $ = s.attributeDivisors;
        I[M] = 1,
        k[M] === 0 && (r.enableVertexAttribArray(M), k[M] = 1),
        $[M] !== D && (r.vertexAttribDivisor(M, D), $[M] = D)
    }
    function x() {
        const M = s.newAttributes,
            D = s.enabledAttributes;
        for (let I = 0, k = D.length; I < k; I++)
            D[I] !== M[I] && (r.disableVertexAttribArray(I), D[I] = 0)
    }
    function v(M, D, I, k, $, j, G) {
        G === !0 ? r.vertexAttribIPointer(M, D, I, $, j) : r.vertexAttribPointer(M, D, I, k, $, j)
    }
    function y(M, D, I, k) {
        _();
        const $ = k.attributes,
            j = I.getAttributes(),
            G = D.defaultAttributeValues;
        for (const H in j) {
            const V = j[H];
            if (V.location >= 0) {
                let nt = $[H];
                if (nt === void 0 && (H === "instanceMatrix" && M.instanceMatrix && (nt = M.instanceMatrix), H === "instanceColor" && M.instanceColor && (nt = M.instanceColor)), nt !== void 0) {
                    const P = nt.normalized,
                        ct = nt.itemSize,
                        Ut = t.get(nt);
                    if (Ut === void 0)
                        continue;
                    const Zt = Ut.buffer,
                        J = Ut.type,
                        it = Ut.bytesPerElement,
                        ft = J === r.INT || J === r.UNSIGNED_INT || nt.gpuType === fd;
                    if (nt.isInterleavedBufferAttribute) {
                        const ut = nt.data,
                            Pt = ut.stride,
                            Nt = nt.offset;
                        if (ut.isInstancedInterleavedBuffer) {
                            for (let Kt = 0; Kt < V.locationSize; Kt++)
                                p(V.location + Kt, ut.meshPerAttribute);
                            M.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = ut.meshPerAttribute * ut.count)
                        } else
                            for (let Kt = 0; Kt < V.locationSize; Kt++)
                                g(V.location + Kt);
                        r.bindBuffer(r.ARRAY_BUFFER, Zt);
                        for (let Kt = 0; Kt < V.locationSize; Kt++)
                            v(V.location + Kt, ct / V.locationSize, J, P, Pt * it, (Nt + ct / V.locationSize * Kt) * it, ft)
                    } else {
                        if (nt.isInstancedBufferAttribute) {
                            for (let ut = 0; ut < V.locationSize; ut++)
                                p(V.location + ut, nt.meshPerAttribute);
                            M.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = nt.meshPerAttribute * nt.count)
                        } else
                            for (let ut = 0; ut < V.locationSize; ut++)
                                g(V.location + ut);
                        r.bindBuffer(r.ARRAY_BUFFER, Zt);
                        for (let ut = 0; ut < V.locationSize; ut++)
                            v(V.location + ut, ct / V.locationSize, J, P, ct * it, ct / V.locationSize * ut * it, ft)
                    }
                } else if (G !== void 0) {
                    const P = G[H];
                    if (P !== void 0)
                        switch (P.length) {
                        case 2:
                            r.vertexAttrib2fv(V.location, P);
                            break;
                        case 3:
                            r.vertexAttrib3fv(V.location, P);
                            break;
                        case 4:
                            r.vertexAttrib4fv(V.location, P);
                            break;
                        default:
                            r.vertexAttrib1fv(V.location, P)
                        }
                }
            }
        }
        x()
    }
    function C() {
        R();
        for (const M in n) {
            const D = n[M];
            for (const I in D) {
                const k = D[I];
                for (const $ in k)
                    h(k[$].object),
                    delete k[$];
                delete D[I]
            }
            delete n[M]
        }
    }
    function A(M) {
        if (n[M.id] === void 0)
            return;
        const D = n[M.id];
        for (const I in D) {
            const k = D[I];
            for (const $ in k)
                h(k[$].object),
                delete k[$];
            delete D[I]
        }
        delete n[M.id]
    }
    function T(M) {
        for (const D in n) {
            const I = n[D];
            if (I[M.id] === void 0)
                continue;
            const k = I[M.id];
            for (const $ in k)
                h(k[$].object),
                delete k[$];
            delete I[M.id]
        }
    }
    function R() {
        E(),
        o = !0,
        s !== i && (s = i, c(s.object))
    }
    function E() {
        i.geometry = null,
        i.program = null,
        i.wireframe = !1
    }
    return {
        setup: a,
        reset: R,
        resetDefaultState: E,
        dispose: C,
        releaseStatesOfGeometry: A,
        releaseStatesOfProgram: T,
        initAttributes: _,
        enableAttribute: g,
        disableUnusedAttributes: x
    }
}
function cS(r, t, e) {
    let n;
    function i(c) {
        n = c
    }
    function s(c, h) {
        r.drawArrays(n, c, h),
        e.update(h, n, 1)
    }
    function o(c, h, u) {
        u !== 0 && (r.drawArraysInstanced(n, c, h, u), e.update(h, n, u))
    }
    function a(c, h, u) {
        if (u === 0)
            return;
        t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, u);
        let f = 0;
        for (let m = 0; m < u; m++)
            f += h[m];
        e.update(f, n, 1)
    }
    function l(c, h, u, d) {
        if (u === 0)
            return;
        const f = t.get("WEBGL_multi_draw");
        if (f === null)
            for (let m = 0; m < c.length; m++)
                o(c[m], h[m], d[m]);
        else {
            f.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, d, 0, u);
            let m = 0;
            for (let _ = 0; _ < u; _++)
                m += h[_];
            for (let _ = 0; _ < d.length; _++)
                e.update(m, n, d[_])
        }
    }
    this.setMode = i,
    this.render = s,
    this.renderInstances = o,
    this.renderMultiDraw = a,
    this.renderMultiDrawInstances = l
}
function hS(r, t, e, n) {
    let i;
    function s() {
        if (i !== void 0)
            return i;
        if (t.has("EXT_texture_filter_anisotropic") === !0) {
            const A = t.get("EXT_texture_filter_anisotropic");
            i = r.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function o(A) {
        return !(A !== fi && n.convert(A) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function a(A) {
        const T = A === ms && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
        return !(A !== xs && n.convert(A) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && A !== Ci && !T)
    }
    function l(A) {
        if (A === "highp") {
            if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
                return "highp";
            A = "mediump"
        }
        return A === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let c = e.precision !== void 0 ? e.precision : "highp";
    const h = l(c);
    h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
    const u = e.logarithmicDepthBuffer === !0,
        d = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
        f = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        m = r.getParameter(r.MAX_TEXTURE_SIZE),
        _ = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
        g = r.getParameter(r.MAX_VERTEX_ATTRIBS),
        p = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
        x = r.getParameter(r.MAX_VARYING_VECTORS),
        v = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
        y = f > 0,
        C = r.getParameter(r.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: l,
        textureFormatReadable: o,
        textureTypeReadable: a,
        precision: c,
        logarithmicDepthBuffer: u,
        maxTextures: d,
        maxVertexTextures: f,
        maxTextureSize: m,
        maxCubemapSize: _,
        maxAttributes: g,
        maxVertexUniforms: p,
        maxVaryings: x,
        maxFragmentUniforms: v,
        vertexTextures: y,
        maxSamples: C
    }
}
function uS(r) {
    const t = this;
    let e = null,
        n = 0,
        i = !1,
        s = !1;
    const o = new Fs,
        a = new re,
        l = {
            value: null,
            needsUpdate: !1
        };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(u, d) {
        const f = u.length !== 0 || d || n !== 0 || i;
        return i = d, n = u.length, f
    },
    this.beginShadows = function() {
        s = !0,
        h(null)
    },
    this.endShadows = function() {
        s = !1
    },
    this.setGlobalState = function(u, d) {
        e = h(u, d, 0)
    },
    this.setState = function(u, d, f) {
        const m = u.clippingPlanes,
            _ = u.clipIntersection,
            g = u.clipShadows,
            p = r.get(u);
        if (!i || m === null || m.length === 0 || s && !g)
            s ? h(null) : c();
        else {
            const x = s ? 0 : n,
                v = x * 4;
            let y = p.clippingState || null;
            l.value = y,
            y = h(m, d, v, f);
            for (let C = 0; C !== v; ++C)
                y[C] = e[C];
            p.clippingState = y,
            this.numIntersection = _ ? this.numPlanes : 0,
            this.numPlanes += x
        }
    };
    function c() {
        l.value !== e && (l.value = e, l.needsUpdate = n > 0),
        t.numPlanes = n,
        t.numIntersection = 0
    }
    function h(u, d, f, m) {
        const _ = u !== null ? u.length : 0;
        let g = null;
        if (_ !== 0) {
            if (g = l.value, m !== !0 || g === null) {
                const p = f + _ * 4,
                    x = d.matrixWorldInverse;
                a.getNormalMatrix(x),
                (g === null || g.length < p) && (g = new Float32Array(p));
                for (let v = 0, y = f; v !== _; ++v, y += 4)
                    o.copy(u[v]).applyMatrix4(x, a),
                    o.normal.toArray(g, y),
                    g[y + 3] = o.constant
            }
            l.value = g,
            l.needsUpdate = !0
        }
        return t.numPlanes = _, t.numIntersection = 0, g
    }
}
function dS(r) {
    let t = new WeakMap;
    function e(o, a) {
        return a === Kh ? o.mapping = To : a === jh && (o.mapping = Eo), o
    }
    function n(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === Kh || a === jh)
                if (t.has(o)) {
                    const l = t.get(o).texture;
                    return e(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new Tv(l.height);
                        return c.fromEquirectangularTexture(r, o), t.set(o, c), o.addEventListener("dispose", i), e(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function i(o) {
        const a = o.target;
        a.removeEventListener("dispose", i);
        const l = t.get(a);
        l !== void 0 && (t.delete(a), l.dispose())
    }
    function s() {
        t = new WeakMap
    }
    return {
        get: n,
        dispose: s
    }
}
class Lc extends xg {
    constructor(t=-1, e=1, n=1, i=-1, s=.1, o=2e3)
    {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = t,
        this.right = e,
        this.top = n,
        this.bottom = i,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(t, e)
    {
        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this
    }
    setViewOffset(t, e, n, i, s, o)
    {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = t,
        this.view.fullHeight = e,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset()
    {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix()
    {
        const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
        let s = n - t,
            o = n + t,
            a = i + e,
            l = i - e;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX,
            o = s + c * this.view.width,
            a -= h * this.view.offsetY,
            l = a - h * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t)
    {
        const e = super.toJSON(t);
        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e
    }
}
const oo = 4,
    Zf = [.125, .215, .35, .446, .526, .582],
    fr = 20,
    ah = new Lc,
    Jf = new Gt;
let lh = null,
    ch = 0,
    hh = 0,
    uh = !1;
const lr = (1 + Math.sqrt(5)) / 2,
    Zr = 1 / lr,
    Qf = [new O(-lr, Zr, 0), new O(lr, Zr, 0), new O(-Zr, 0, lr), new O(Zr, 0, lr), new O(0, lr, -Zr), new O(0, lr, Zr), new O(-1, 1, -1), new O(1, 1, -1), new O(-1, 1, 1), new O(1, 1, 1)];
class tp {
    constructor(t)
    {
        this._renderer = t,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(t, e=0, n=.1, i=100)
    {
        lh = this._renderer.getRenderTarget(),
        ch = this._renderer.getActiveCubeFace(),
        hh = this._renderer.getActiveMipmapLevel(),
        uh = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0, this._sceneToCubeUV(t, n, i, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s
    }
    fromEquirectangular(t, e=null)
    {
        return this._fromTexture(t, e)
    }
    fromCubemap(t, e=null)
    {
        return this._fromTexture(t, e)
    }
    compileCubemapShader()
    {
        this._cubemapMaterial === null && (this._cubemapMaterial = ip(), this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader()
    {
        this._equirectMaterial === null && (this._equirectMaterial = np(), this._compileMaterial(this._equirectMaterial))
    }
    dispose()
    {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(t)
    {
        this._lodMax = Math.floor(Math.log2(t)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose()
    {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let t = 0; t < this._lodPlanes.length; t++)
            this._lodPlanes[t].dispose()
    }
    _cleanup(t)
    {
        this._renderer.setRenderTarget(lh, ch, hh),
        this._renderer.xr.enabled = uh,
        t.scissorTest = !1,
        vl(t, 0, 0, t.width, t.height)
    }
    _fromTexture(t, e)
    {
        t.mapping === To || t.mapping === Eo ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4),
        lh = this._renderer.getRenderTarget(),
        ch = this._renderer.getActiveCubeFace(),
        hh = this._renderer.getActiveMipmapLevel(),
        uh = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const n = e || this._allocateTargets();
        return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
    }
    _allocateTargets()
    {
        const t = 3 * Math.max(this._cubeSize, 112),
            e = 4 * this._cubeSize,
            n = {
                magFilter: ti,
                minFilter: ti,
                generateMipmaps: !1,
                type: ms,
                format: fi,
                colorSpace: dn,
                depthBuffer: !1
            },
            i = ep(t, e, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = ep(t, e, n);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = fS(s)),
            this._blurMaterial = pS(s, t, e)
        }
        return i
    }
    _compileMaterial(t)
    {
        const e = new Un(this._lodPlanes[0], t);
        this._renderer.compile(e, ah)
    }
    _sceneToCubeUV(t, e, n, i)
    {
        const a = new yn(90, 1, e, n),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            h = this._renderer,
            u = h.autoClear,
            d = h.toneMapping;
        h.getClearColor(Jf),
        h.toneMapping = Xs,
        h.autoClear = !1;
        const f = new zs({
                name: "PMREM.Background",
                side: kn,
                depthWrite: !1,
                depthTest: !1
            }),
            m = new Un(new $a, f);
        let _ = !1;
        const g = t.background;
        g ? g.isColor && (f.color.copy(g), t.background = null, _ = !0) : (f.color.copy(Jf), _ = !0);
        for (let p = 0; p < 6; p++) {
            const x = p % 3;
            x === 0 ? (a.up.set(0, l[p], 0), a.lookAt(c[p], 0, 0)) : x === 1 ? (a.up.set(0, 0, l[p]), a.lookAt(0, c[p], 0)) : (a.up.set(0, l[p], 0), a.lookAt(0, 0, c[p]));
            const v = this._cubeSize;
            vl(i, x * v, p > 2 ? v : 0, v, v),
            h.setRenderTarget(i),
            _ && h.render(m, a),
            h.render(t, a)
        }
        m.geometry.dispose(),
        m.material.dispose(),
        h.toneMapping = d,
        h.autoClear = u,
        t.background = g
    }
    _textureToCubeUV(t, e)
    {
        const n = this._renderer,
            i = t.mapping === To || t.mapping === Eo;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = ip()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = np());
        const s = i ? this._cubemapMaterial : this._equirectMaterial,
            o = new Un(this._lodPlanes[0], s),
            a = s.uniforms;
        a.envMap.value = t;
        const l = this._cubeSize;
        vl(e, 0, 0, 3 * l, 2 * l),
        n.setRenderTarget(e),
        n.render(o, ah)
    }
    _applyPMREM(t)
    {
        const e = this._renderer,
            n = e.autoClear;
        e.autoClear = !1;
        const i = this._lodPlanes.length;
        for (let s = 1; s < i; s++) {
            const o = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]),
                a = Qf[(i - s - 1) % Qf.length];
            this._blur(t, s - 1, s, o, a)
        }
        e.autoClear = n
    }
    _blur(t, e, n, i, s)
    {
        const o = this._pingPongRenderTarget;
        this._halfBlur(t, o, e, n, i, "latitudinal", s),
        this._halfBlur(o, t, n, n, i, "longitudinal", s)
    }
    _halfBlur(t, e, n, i, s, o, a)
    {
        const l = this._renderer,
            c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const h = 3,
            u = new Un(this._lodPlanes[i], c),
            d = c.uniforms,
            f = this._sizeLods[n] - 1,
            m = isFinite(s) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * fr - 1),
            _ = s / m,
            g = isFinite(s) ? 1 + Math.floor(h * _) : fr;
        g > fr && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${fr}`);
        const p = [];
        let x = 0;
        for (let T = 0; T < fr; ++T) {
            const R = T / _,
                E = Math.exp(-R * R / 2);
            p.push(E),
            T === 0 ? x += E : T < g && (x += 2 * E)
        }
        for (let T = 0; T < p.length; T++)
            p[T] = p[T] / x;
        d.envMap.value = t.texture,
        d.samples.value = g,
        d.weights.value = p,
        d.latitudinal.value = o === "latitudinal",
        a && (d.poleAxis.value = a);
        const {_lodMax: v} = this;
        d.dTheta.value = m,
        d.mipInt.value = v - n;
        const y = this._sizeLods[i],
            C = 3 * y * (i > v - oo ? i - v + oo : 0),
            A = 4 * (this._cubeSize - y);
        vl(e, C, A, 3 * y, 2 * y),
        l.setRenderTarget(e),
        l.render(u, ah)
    }
}
function fS(r) {
    const t = [],
        e = [],
        n = [];
    let i = r;
    const s = r - oo + 1 + Zf.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, i);
        e.push(a);
        let l = 1 / a;
        o > r - oo ? l = Zf[o - r + oo - 1] : o === 0 && (l = 0),
        n.push(l);
        const c = 1 / (a - 2),
            h = -c,
            u = 1 + c,
            d = [h, h, u, h, u, u, h, h, u, u, h, u],
            f = 6,
            m = 6,
            _ = 3,
            g = 2,
            p = 1,
            x = new Float32Array(_ * m * f),
            v = new Float32Array(g * m * f),
            y = new Float32Array(p * m * f);
        for (let A = 0; A < f; A++) {
            const T = A % 3 * 2 / 3 - 1,
                R = A > 2 ? 0 : -1,
                E = [T, R, 0, T + 2 / 3, R, 0, T + 2 / 3, R + 1, 0, T, R, 0, T + 2 / 3, R + 1, 0, T, R + 1, 0];
            x.set(E, _ * m * A),
            v.set(d, g * m * A);
            const M = [A, A, A, A, A, A];
            y.set(M, p * m * A)
        }
        const C = new Ni;
        C.setAttribute("position", new zn(x, _)),
        C.setAttribute("uv", new zn(v, g)),
        C.setAttribute("faceIndex", new zn(y, p)),
        t.push(C),
        i > oo && i--
    }
    return {
        lodPlanes: t,
        sizeLods: e,
        sigmas: n
    }
}
function ep(r, t, e) {
    const n = new Pi(r, t, e);
    return n.texture.mapping = Rc, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
}
function vl(r, t, e, n, i) {
    r.viewport.set(t, e, n, i),
    r.scissor.set(t, e, n, i)
}
function pS(r, t, e) {
    const n = new Float32Array(fr),
        i = new O(0, 1, 0);
    return new On({
        name: "SphericalGaussianBlur",
        defines: {
            n: fr,
            CUBEUV_TEXEL_WIDTH: 1 / t,
            CUBEUV_TEXEL_HEIGHT: 1 / e,
            CUBEUV_MAX_MIP: `${r}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: n
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: Ed(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`



























































        ,
        blending: ps,
        depthTest: !1,
        depthWrite: !1
    })
}
function np() {
    return new On({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: Ed(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`


















        ,
        blending: ps,
        depthTest: !1,
        depthWrite: !1
    })
}
function ip() {
    return new On({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: Ed(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`















        ,
        blending: ps,
        depthTest: !1,
        depthWrite: !1
    })
}
function Ed() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`






















































}
function mS(r) {
    let t = new WeakMap,
        e = null;
    function n(a) {
        if (a && a.isTexture) {
            const l = a.mapping,
                c = l === Kh || l === jh,
                h = l === To || l === Eo;
            if (c || h) {
                let u = t.get(a);
                const d = u !== void 0 ? u.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== d)
                    return e === null && (e = new tp(r)), u = c ? e.fromEquirectangular(a, u) : e.fromCubemap(a, u), u.texture.pmremVersion = a.pmremVersion, t.set(a, u), u.texture;
                if (u !== void 0)
                    return u.texture;
                {
                    const f = a.image;
                    return c && f && f.height > 0 || h && f && i(f) ? (e === null && (e = new tp(r)), u = c ? e.fromEquirectangular(a) : e.fromCubemap(a), u.texture.pmremVersion = a.pmremVersion, t.set(a, u), a.addEventListener("dispose", s), u.texture) : null
                }
            }
        }
        return a
    }
    function i(a) {
        let l = 0;
        const c = 6;
        for (let h = 0; h < c; h++)
            a[h] !== void 0 && l++;
        return l === c
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = t.get(l);
        c !== void 0 && (t.delete(l), c.dispose())
    }
    function o() {
        t = new WeakMap,
        e !== null && (e.dispose(), e = null)
    }
    return {
        get: n,
        dispose: o
    }
}
function gS(r) {
    const t = {};
    function e(n) {
        if (t[n] !== void 0)
            return t[n];
        let i;
        switch (n) {
        case "WEBGL_depth_texture":
            i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = r.getExtension(n)
        }
        return t[n] = i, i
    }
    return {
        has: function(n) {
            return e(n) !== null
        },
        init: function() {
            e("EXT_color_buffer_float"),
            e("WEBGL_clip_cull_distance"),
            e("OES_texture_float_linear"),
            e("EXT_color_buffer_half_float"),
            e("WEBGL_multisampled_render_to_texture"),
            e("WEBGL_render_shared_exponent")
        },
        get: function(n) {
            const i = e(n);
            return i === null && po("THREE.WebGLRenderer: " + n + " extension not supported."), i
        }
    }
}
function _S(r, t, e, n) {
    const i = {},
        s = new WeakMap;
    function o(u) {
        const d = u.target;
        d.index !== null && t.remove(d.index);
        for (const m in d.attributes)
            t.remove(d.attributes[m]);
        for (const m in d.morphAttributes) {
            const _ = d.morphAttributes[m];
            for (let g = 0, p = _.length; g < p; g++)
                t.remove(_[g])
        }
        d.removeEventListener("dispose", o),
        delete i[d.id];
        const f = s.get(d);
        f && (t.remove(f), s.delete(d)),
        n.releaseStatesOfGeometry(d),
        d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
        e.memory.geometries--
    }
    function a(u, d) {
        return i[d.id] === !0 || (d.addEventListener("dispose", o), i[d.id] = !0, e.memory.geometries++), d
    }
    function l(u) {
        const d = u.attributes;
        for (const m in d)
            t.update(d[m], r.ARRAY_BUFFER);
        const f = u.morphAttributes;
        for (const m in f) {
            const _ = f[m];
            for (let g = 0, p = _.length; g < p; g++)
                t.update(_[g], r.ARRAY_BUFFER)
        }
    }
    function c(u) {
        const d = [],
            f = u.index,
            m = u.attributes.position;
        let _ = 0;
        if (f !== null) {
            const x = f.array;
            _ = f.version;
            for (let v = 0, y = x.length; v < y; v += 3) {
                const C = x[v + 0],
                    A = x[v + 1],
                    T = x[v + 2];
                d.push(C, A, A, T, T, C)
            }
        } else if (m !== void 0) {
            const x = m.array;
            _ = m.version;
            for (let v = 0, y = x.length / 3 - 1; v < y; v += 3) {
                const C = v + 0,
                    A = v + 1,
                    T = v + 2;
                d.push(C, A, A, T, T, C)
            }
        } else
            return;
        const g = new (lg(d) ? gg : mg)(d, 1);
        g.version = _;
        const p = s.get(u);
        p && t.remove(p),
        s.set(u, g)
    }
    function h(u) {
        const d = s.get(u);
        if (d) {
            const f = u.index;
            f !== null && d.version < f.version && c(u)
        } else
            c(u);
        return s.get(u)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: h
    }
}
function xS(r, t, e) {
    let n;
    function i(d) {
        n = d
    }
    let s,
        o;
    function a(d) {
        s = d.type,
        o = d.bytesPerElement
    }
    function l(d, f) {
        r.drawElements(n, f, s, d * o),
        e.update(f, n, 1)
    }
    function c(d, f, m) {
        m !== 0 && (r.drawElementsInstanced(n, f, s, d * o, m), e.update(f, n, m))
    }
    function h(d, f, m) {
        if (m === 0)
            return;
        t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, s, d, 0, m);
        let g = 0;
        for (let p = 0; p < m; p++)
            g += f[p];
        e.update(g, n, 1)
    }
    function u(d, f, m, _) {
        if (m === 0)
            return;
        const g = t.get("WEBGL_multi_draw");
        if (g === null)
            for (let p = 0; p < d.length; p++)
                c(d[p] / o, f[p], _[p]);
        else {
            g.multiDrawElementsInstancedWEBGL(n, f, 0, s, d, 0, _, 0, m);
            let p = 0;
            for (let x = 0; x < m; x++)
                p += f[x];
            for (let x = 0; x < _.length; x++)
                e.update(p, n, _[x])
        }
    }
    this.setMode = i,
    this.setIndex = a,
    this.render = l,
    this.renderInstances = c,
    this.renderMultiDraw = h,
    this.renderMultiDrawInstances = u
}
function vS(r) {
    const t = {
            geometries: 0,
            textures: 0
        },
        e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
    function n(s, o, a) {
        switch (e.calls++, o) {
        case r.TRIANGLES:
            e.triangles += a * (s / 3);
            break;
        case r.LINES:
            e.lines += a * (s / 2);
            break;
        case r.LINE_STRIP:
            e.lines += a * (s - 1);
            break;
        case r.LINE_LOOP:
            e.lines += a * s;
            break;
        case r.POINTS:
            e.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function i() {
        e.calls = 0,
        e.triangles = 0,
        e.points = 0,
        e.lines = 0
    }
    return {
        memory: t,
        render: e,
        programs: null,
        autoReset: !0,
        reset: i,
        update: n
    }
}
function yS(r, t, e) {
    const n = new WeakMap,
        i = new Pe;
    function s(o, a, l) {
        const c = o.morphTargetInfluences,
            h = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color,
            u = h !== void 0 ? h.length : 0;
        let d = n.get(a);
        if (d === void 0 || d.count !== u) {
            let M = function() {
                R.dispose(),
                n.delete(a),
                a.removeEventListener("dispose", M)
            };
            var f = M;
            d !== void 0 && d.texture.dispose();
            const m = a.morphAttributes.position !== void 0,
                _ = a.morphAttributes.normal !== void 0,
                g = a.morphAttributes.color !== void 0,
                p = a.morphAttributes.position || [],
                x = a.morphAttributes.normal || [],
                v = a.morphAttributes.color || [];
            let y = 0;
            m === !0 && (y = 1),
            _ === !0 && (y = 2),
            g === !0 && (y = 3);
            let C = a.attributes.position.count * y,
                A = 1;
            C > t.maxTextureSize && (A = Math.ceil(C / t.maxTextureSize), C = t.maxTextureSize);
            const T = new Float32Array(C * A * 4 * u),
                R = new ug(T, C, A, u);
            R.type = Ci,
            R.needsUpdate = !0;
            const E = y * 4;
            for (let D = 0; D < u; D++) {
                const I = p[D],
                    k = x[D],
                    $ = v[D],
                    j = C * A * 4 * D;
                for (let G = 0; G < I.count; G++) {
                    const H = G * E;
                    m === !0 && (i.fromBufferAttribute(I, G), T[j + H + 0] = i.x, T[j + H + 1] = i.y, T[j + H + 2] = i.z, T[j + H + 3] = 0),
                    _ === !0 && (i.fromBufferAttribute(k, G), T[j + H + 4] = i.x, T[j + H + 5] = i.y, T[j + H + 6] = i.z, T[j + H + 7] = 0),
                    g === !0 && (i.fromBufferAttribute($, G), T[j + H + 8] = i.x, T[j + H + 9] = i.y, T[j + H + 10] = i.z, T[j + H + 11] = $.itemSize === 4 ? i.w : 1)
                }
            }
            d = {
                count: u,
                texture: R,
                size: new St(C, A)
            },
            n.set(a, d),
            a.addEventListener("dispose", M)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
            l.getUniforms().setValue(r, "morphTexture", o.morphTexture, e);
        else {
            let m = 0;
            for (let g = 0; g < c.length; g++)
                m += c[g];
            const _ = a.morphTargetsRelative ? 1 : 1 - m;
            l.getUniforms().setValue(r, "morphTargetBaseInfluence", _),
            l.getUniforms().setValue(r, "morphTargetInfluences", c)
        }
        l.getUniforms().setValue(r, "morphTargetsTexture", d.texture, e),
        l.getUniforms().setValue(r, "morphTargetsTextureSize", d.size)
    }
    return {
        update: s
    }
}
function MS(r, t, e, n) {
    let i = new WeakMap;
    function s(l) {
        const c = n.render.frame,
            h = l.geometry,
            u = t.get(l, h);
        if (i.get(u) !== c && (t.update(u), i.set(u, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), i.get(l) !== c && (e.update(l.instanceMatrix, r.ARRAY_BUFFER), l.instanceColor !== null && e.update(l.instanceColor, r.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
            const d = l.skeleton;
            i.get(d) !== c && (d.update(), i.set(d, c))
        }
        return u
    }
    function o() {
        i = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        e.remove(c.instanceMatrix),
        c.instanceColor !== null && e.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
class Mg extends an {
    constructor(t, e, n, i, s, o, a, l, c, h=fo)
    {
        if (h !== fo && h !== Ao)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        n === void 0 && h === fo && (n = Tr),
        n === void 0 && h === Ao && (n = wo),
        super(null, i, s, o, a, l, h, n, c),
        this.isDepthTexture = !0,
        this.image = {
            width: t,
            height: e
        },
        this.magFilter = a !== void 0 ? a : Fn,
        this.minFilter = l !== void 0 ? l : Fn,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(t)
    {
        return super.copy(t), this.compareFunction = t.compareFunction, this
    }
    toJSON(t)
    {
        const e = super.toJSON(t);
        return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e
    }
}
const Sg = new an,
    sp = new Mg(1, 1),
    Tg = new ug,
    Eg = new lv,
    bg = new vg,
    rp = [],
    op = [],
    ap = new Float32Array(16),
    lp = new Float32Array(9),
    cp = new Float32Array(4);
function ko(r, t, e) {
    const n = r[0];
    if (n <= 0 || n > 0)
        return r;
    const i = t * e;
    let s = rp[i];
    if (s === void 0 && (s = new Float32Array(i), rp[i] = s), t !== 0) {
        n.toArray(s, 0);
        for (let o = 1, a = 0; o !== t; ++o)
            a += e,
            r[o].toArray(s, a)
    }
    return s
}
function Qe(r, t) {
    if (r.length !== t.length)
        return !1;
    for (let e = 0, n = r.length; e < n; e++)
        if (r[e] !== t[e])
            return !1;
    return !0
}
function tn(r, t) {
    for (let e = 0, n = t.length; e < n; e++)
        r[e] = t[e]
}
function Dc(r, t) {
    let e = op[t];
    e === void 0 && (e = new Int32Array(t), op[t] = e);
    for (let n = 0; n !== t; ++n)
        e[n] = r.allocateTextureUnit();
    return e
}
function SS(r, t) {
    const e = this.cache;
    e[0] !== t && (r.uniform1f(this.addr, t), e[0] = t)
}
function TS(r, t) {
    const e = this.cache;
    if (t.x !== void 0)
        (e[0] !== t.x || e[1] !== t.y) && (r.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
    else {
        if (Qe(e, t))
            return;
        r.uniform2fv(this.addr, t),
        tn(e, t)
    }
}
function ES(r, t) {
    const e = this.cache;
    if (t.x !== void 0)
        (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
    else if (t.r !== void 0)
        (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (r.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
    else {
        if (Qe(e, t))
            return;
        r.uniform3fv(this.addr, t),
        tn(e, t)
    }
}
function bS(r, t) {
    const e = this.cache;
    if (t.x !== void 0)
        (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
    else {
        if (Qe(e, t))
            return;
        r.uniform4fv(this.addr, t),
        tn(e, t)
    }
}
function wS(r, t) {
    const e = this.cache,
        n = t.elements;
    if (n === void 0) {
        if (Qe(e, t))
            return;
        r.uniformMatrix2fv(this.addr, !1, t),
        tn(e, t)
    } else {
        if (Qe(e, n))
            return;
        cp.set(n),
        r.uniformMatrix2fv(this.addr, !1, cp),
        tn(e, n)
    }
}
function AS(r, t) {
    const e = this.cache,
        n = t.elements;
    if (n === void 0) {
        if (Qe(e, t))
            return;
        r.uniformMatrix3fv(this.addr, !1, t),
        tn(e, t)
    } else {
        if (Qe(e, n))
            return;
        lp.set(n),
        r.uniformMatrix3fv(this.addr, !1, lp),
        tn(e, n)
    }
}
function CS(r, t) {
    const e = this.cache,
        n = t.elements;
    if (n === void 0) {
        if (Qe(e, t))
            return;
        r.uniformMatrix4fv(this.addr, !1, t),
        tn(e, t)
    } else {
        if (Qe(e, n))
            return;
        ap.set(n),
        r.uniformMatrix4fv(this.addr, !1, ap),
        tn(e, n)
    }
}
function RS(r, t) {
    const e = this.cache;
    e[0] !== t && (r.uniform1i(this.addr, t), e[0] = t)
}
function PS(r, t) {
    const e = this.cache;
    if (t.x !== void 0)
        (e[0] !== t.x || e[1] !== t.y) && (r.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
    else {
        if (Qe(e, t))
            return;
        r.uniform2iv(this.addr, t),
        tn(e, t)
    }
}
function LS(r, t) {
    const e = this.cache;
    if (t.x !== void 0)
        (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
    else {
        if (Qe(e, t))
            return;
        r.uniform3iv(this.addr, t),
        tn(e, t)
    }
}
function DS(r, t) {
    const e = this.cache;
    if (t.x !== void 0)
        (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
    else {
        if (Qe(e, t))
            return;
        r.uniform4iv(this.addr, t),
        tn(e, t)
    }
}
function NS(r, t) {
    const e = this.cache;
    e[0] !== t && (r.uniform1ui(this.addr, t), e[0] = t)
}
function IS(r, t) {
    const e = this.cache;
    if (t.x !== void 0)
        (e[0] !== t.x || e[1] !== t.y) && (r.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
    else {
        if (Qe(e, t))
            return;
        r.uniform2uiv(this.addr, t),
        tn(e, t)
    }
}
function FS(r, t) {
    const e = this.cache;
    if (t.x !== void 0)
        (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
    else {
        if (Qe(e, t))
            return;
        r.uniform3uiv(this.addr, t),
        tn(e, t)
    }
}
function US(r, t) {
    const e = this.cache;
    if (t.x !== void 0)
        (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
    else {
        if (Qe(e, t))
            return;
        r.uniform4uiv(this.addr, t),
        tn(e, t)
    }
}
function OS(r, t, e) {
    const n = this.cache,
        i = e.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i);
    let s;
    this.type === r.SAMPLER_2D_SHADOW ? (sp.compareFunction = rg, s = sp) : s = Sg,
    e.setTexture2D(t || s, i)
}
function zS(r, t, e) {
    const n = this.cache,
        i = e.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i),
    e.setTexture3D(t || Eg, i)
}
function BS(r, t, e) {
    const n = this.cache,
        i = e.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i),
    e.setTextureCube(t || bg, i)
}
function kS(r, t, e) {
    const n = this.cache,
        i = e.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i),
    e.setTexture2DArray(t || Tg, i)
}
function HS(r) {
    switch (r) {
    case 5126:
        return SS;
    case 35664:
        return TS;
    case 35665:
        return ES;
    case 35666:
        return bS;
    case 35674:
        return wS;
    case 35675:
        return AS;
    case 35676:
        return CS;
    case 5124:
    case 35670:
        return RS;
    case 35667:
    case 35671:
        return PS;
    case 35668:
    case 35672:
        return LS;
    case 35669:
    case 35673:
        return DS;
    case 5125:
        return NS;
    case 36294:
        return IS;
    case 36295:
        return FS;
    case 36296:
        return US;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return OS;
    case 35679:
    case 36299:
    case 36307:
        return zS;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return BS;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return kS
    }
}
function VS(r, t) {
    r.uniform1fv(this.addr, t)
}
function GS(r, t) {
    const e = ko(t, this.size, 2);
    r.uniform2fv(this.addr, e)
}
function WS(r, t) {
    const e = ko(t, this.size, 3);
    r.uniform3fv(this.addr, e)
}
function XS(r, t) {
    const e = ko(t, this.size, 4);
    r.uniform4fv(this.addr, e)
}
function YS(r, t) {
    const e = ko(t, this.size, 4);
    r.uniformMatrix2fv(this.addr, !1, e)
}
function $S(r, t) {
    const e = ko(t, this.size, 9);
    r.uniformMatrix3fv(this.addr, !1, e)
}
function qS(r, t) {
    const e = ko(t, this.size, 16);
    r.uniformMatrix4fv(this.addr, !1, e)
}
function KS(r, t) {
    r.uniform1iv(this.addr, t)
}
function jS(r, t) {
    r.uniform2iv(this.addr, t)
}
function ZS(r, t) {
    r.uniform3iv(this.addr, t)
}
function JS(r, t) {
    r.uniform4iv(this.addr, t)
}
function QS(r, t) {
    r.uniform1uiv(this.addr, t)
}
function tT(r, t) {
    r.uniform2uiv(this.addr, t)
}
function eT(r, t) {
    r.uniform3uiv(this.addr, t)
}
function nT(r, t) {
    r.uniform4uiv(this.addr, t)
}
function iT(r, t, e) {
    const n = this.cache,
        i = t.length,
        s = Dc(e, i);
    Qe(n, s) || (r.uniform1iv(this.addr, s), tn(n, s));
    for (let o = 0; o !== i; ++o)
        e.setTexture2D(t[o] || Sg, s[o])
}
function sT(r, t, e) {
    const n = this.cache,
        i = t.length,
        s = Dc(e, i);
    Qe(n, s) || (r.uniform1iv(this.addr, s), tn(n, s));
    for (let o = 0; o !== i; ++o)
        e.setTexture3D(t[o] || Eg, s[o])
}
function rT(r, t, e) {
    const n = this.cache,
        i = t.length,
        s = Dc(e, i);
    Qe(n, s) || (r.uniform1iv(this.addr, s), tn(n, s));
    for (let o = 0; o !== i; ++o)
        e.setTextureCube(t[o] || bg, s[o])
}
function oT(r, t, e) {
    const n = this.cache,
        i = t.length,
        s = Dc(e, i);
    Qe(n, s) || (r.uniform1iv(this.addr, s), tn(n, s));
    for (let o = 0; o !== i; ++o)
        e.setTexture2DArray(t[o] || Tg, s[o])
}
function aT(r) {
    switch (r) {
    case 5126:
        return VS;
    case 35664:
        return GS;
    case 35665:
        return WS;
    case 35666:
        return XS;
    case 35674:
        return YS;
    case 35675:
        return $S;
    case 35676:
        return qS;
    case 5124:
    case 35670:
        return KS;
    case 35667:
    case 35671:
        return jS;
    case 35668:
    case 35672:
        return ZS;
    case 35669:
    case 35673:
        return JS;
    case 5125:
        return QS;
    case 36294:
        return tT;
    case 36295:
        return eT;
    case 36296:
        return nT;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return iT;
    case 35679:
    case 36299:
    case 36307:
        return sT;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return rT;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return oT
    }
}
class lT {
    constructor(t, e, n)
    {
        this.id = t,
        this.addr = n,
        this.cache = [],
        this.type = e.type,
        this.setValue = HS(e.type)
    }
}
class cT {
    constructor(t, e, n)
    {
        this.id = t,
        this.addr = n,
        this.cache = [],
        this.type = e.type,
        this.size = e.size,
        this.setValue = aT(e.type)
    }
}
class hT {
    constructor(t)
    {
        this.id = t,
        this.seq = [],
        this.map = {}
    }
    setValue(t, e, n)
    {
        const i = this.seq;
        for (let s = 0, o = i.length; s !== o; ++s) {
            const a = i[s];
            a.setValue(t, e[a.id], n)
        }
    }
}
const dh = /(\w+)(\])?(\[|\.)?/g;
function hp(r, t) {
    r.seq.push(t),
    r.map[t.id] = t
}
function uT(r, t, e) {
    const n = r.name,
        i = n.length;
    for (dh.lastIndex = 0;;) {
        const s = dh.exec(n),
            o = dh.lastIndex;
        let a = s[1];
        const l = s[2] === "]",
            c = s[3];
        if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === i) {
            hp(e, c === void 0 ? new lT(a, r, t) : new cT(a, r, t));
            break
        } else {
            let u = e.map[a];
            u === void 0 && (u = new hT(a), hp(e, u)),
            e = u
        }
    }
}
class Zl {
    constructor(t, e)
    {
        this.seq = [],
        this.map = {};
        const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
            const s = t.getActiveUniform(e, i),
                o = t.getUniformLocation(e, s.name);
            uT(s, o, this)
        }
    }
    setValue(t, e, n, i)
    {
        const s = this.map[e];
        s !== void 0 && s.setValue(t, n, i)
    }
    setOptional(t, e, n)
    {
        const i = e[n];
        i !== void 0 && this.setValue(t, n, i)
    }
    static upload(t, e, n, i)
    {
        for (let s = 0, o = e.length; s !== o; ++s) {
            const a = e[s],
                l = n[a.id];
            l.needsUpdate !== !1 && a.setValue(t, l.value, i)
        }
    }
    static seqWithValue(t, e)
    {
        const n = [];
        for (let i = 0, s = t.length; i !== s; ++i) {
            const o = t[i];
            o.id in e && n.push(o)
        }
        return n
    }
}
function up(r, t, e) {
    const n = r.createShader(t);
    return r.shaderSource(n, e), r.compileShader(n), n
}
const dT = 37297;
let fT = 0;
function pT(r, t) {
    const e = r.split(`
`
        ),
        n = [],
        i = Math.max(t - 6, 0),
        s = Math.min(t + 6, e.length);
    for (let o = i; o < s; o++) {
        const a = o + 1;
        n.push(`${a === t ? ">" : " "} ${a}: ${e[o]}`)
    }
    return n.join(`
`
    )
}
function mT(r) {
    const t = me.getPrimaries(me.workingColorSpace),
        e = me.getPrimaries(r);
    let n;
    switch (t === e ? n = "" : t === uc && e === hc ? n = "LinearDisplayP3ToLinearSRGB" : t === hc && e === uc && (n = "LinearSRGBToLinearDisplayP3"), r) {
    case dn:
    case Pc:
        return [n, "LinearTransferOETF"];
    case Ln:
    case Md:
        return [n, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", r), [n, "LinearTransferOETF"]
    }
}
function dp(r, t, e) {
    const n = r.getShaderParameter(t, r.COMPILE_STATUS),
        i = r.getShaderInfoLog(t).trim();
    if (n && i === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(i);
    if (s) {
        const o = parseInt(s[1]);
        return e.toUpperCase() + `

`

        + i + `

`

        + pT(r.getShaderSource(t), o)
    } else
        return i
}
function gT(r, t) {
    const e = mT(t);
    return `vec4 ${r}( vec4 value ) { return ${e[0]}( ${e[1]}( value ) ); }`
}
function _T(r, t) {
    let e;
    switch (t) {
    case vx:
        e = "Linear";
        break;
    case yx:
        e = "Reinhard";
        break;
    case Mx:
        e = "OptimizedCineon";
        break;
    case Sx:
        e = "ACESFilmic";
        break;
    case Ex:
        e = "AgX";
        break;
    case bx:
        e = "Neutral";
        break;
    case Tx:
        e = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
        e = "Linear"
    }
    return "vec3 " + r + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
}
const yl = new O;
function xT() {
    me.getLuminanceCoefficients(yl);
    const r = yl.x.toFixed(4),
        t = yl.y.toFixed(4),
        e = yl.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${r}, ${t}, ${e} );`, "	return dot( weights, rgb );", "}"].join(`
`
    )
}
function vT(r) {
    return [r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(oa).join(`
`
    )
}
function yT(r) {
    const t = [];
    for (const e in r) {
        const n = r[e];
        n !== !1 && t.push("#define " + e + " " + n)
    }
    return t.join(`
`
    )
}
function MT(r, t) {
    const e = {},
        n = r.getProgramParameter(t, r.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
        const s = r.getActiveAttrib(t, i),
            o = s.name;
        let a = 1;
        s.type === r.FLOAT_MAT2 && (a = 2),
        s.type === r.FLOAT_MAT3 && (a = 3),
        s.type === r.FLOAT_MAT4 && (a = 4),
        e[o] = {
            type: s.type,
            location: r.getAttribLocation(t, o),
            locationSize: a
        }
    }
    return e
}
function oa(r) {
    return r !== ""
}
function fp(r, t) {
    const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
    return r.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
}
function pp(r, t) {
    return r.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
}
const ST = /^[ \t]*#include +<([\w\d./]+)>/gm;
function wu(r) {
    return r.replace(ST, ET)
}
const TT = new Map;
function ET(r, t) {
    let e = te[t];
    if (e === void 0) {
        const n = TT.get(t);
        if (n !== void 0)
            e = te[n],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, n);
        else
            throw new Error("Can not resolve #include <" + t + ">")
    }
    return wu(e)
}
const bT = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function mp(r) {
    return r.replace(bT, wT)
}
function wT(r, t, e, n) {
    let i = "";
    for (let s = parseInt(t); s < parseInt(e); s++)
        i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return i
}
function gp(r) {
    let t = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`
    ;
    return r.precision === "highp" ? t += `
#define HIGH_PRECISION`
    : r.precision === "mediump" ? t += `
#define MEDIUM_PRECISION`
    : r.precision === "lowp" && (t += `
#define LOW_PRECISION`
    ), t
}
function AT(r) {
    let t = "SHADOWMAP_TYPE_BASIC";
    return r.shadowMapType === Xm ? t = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === X0 ? t = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === ss && (t = "SHADOWMAP_TYPE_VSM"), t
}
function CT(r) {
    let t = "ENVMAP_TYPE_CUBE";
    if (r.envMap)
        switch (r.envMapMode) {
        case To:
        case Eo:
            t = "ENVMAP_TYPE_CUBE";
            break;
        case Rc:
            t = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return t
}
function RT(r) {
    let t = "ENVMAP_MODE_REFLECTION";
    if (r.envMap)
        switch (r.envMapMode) {
        case Eo:
            t = "ENVMAP_MODE_REFRACTION";
            break
        }
    return t
}
function PT(r) {
    let t = "ENVMAP_BLENDING_NONE";
    if (r.envMap)
        switch (r.combine) {
        case Ym:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case _x:
            t = "ENVMAP_BLENDING_MIX";
            break;
        case xx:
            t = "ENVMAP_BLENDING_ADD";
            break
        }
    return t
}
function LT(r) {
    const t = r.envMapCubeUVHeight;
    if (t === null)
        return null;
    const e = Math.log2(t) - 2,
        n = 1 / t;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
        texelHeight: n,
        maxMip: e
    }
}
function DT(r, t, e, n) {
    const i = r.getContext(),
        s = e.defines;
    let o = e.vertexShader,
        a = e.fragmentShader;
    const l = AT(e),
        c = CT(e),
        h = RT(e),
        u = PT(e),
        d = LT(e),
        f = vT(e),
        m = yT(s),
        _ = i.createProgram();
    let g,
        p,
        x = e.glslVersion ? "#version " + e.glslVersion + `
`
        : "";
    e.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + e.shaderType, "#define SHADER_NAME " + e.shaderName, m].filter(oa).join(`
`
    ), g.length > 0 && (g += `
`
    ), p = ["#define SHADER_TYPE " + e.shaderType, "#define SHADER_NAME " + e.shaderName, m].filter(oa).join(`
`
    ), p.length > 0 && (p += `
`
    )) : (g = [gp(e), "#define SHADER_TYPE " + e.shaderType, "#define SHADER_NAME " + e.shaderName, m, e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", e.batching ? "#define USE_BATCHING" : "", e.batchingColor ? "#define USE_BATCHING_COLOR" : "", e.instancing ? "#define USE_INSTANCING" : "", e.instancingColor ? "#define USE_INSTANCING_COLOR" : "", e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + h : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.anisotropy ? "#define USE_ANISOTROPY" : "", e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.alphaHash ? "#define USE_ALPHAHASH" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", e.mapUv ? "#define MAP_UV " + e.mapUv : "", e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "", e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "", e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "", e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "", e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "", e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "", e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "", e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "", e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "", e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "", e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "", e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "", e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "", e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "", e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "", e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "", e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "", e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "", e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "", e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "", e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "", e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "", e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "", e.vertexColors ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUv1s ? "#define USE_UV1" : "", e.vertexUv2s ? "#define USE_UV2" : "", e.vertexUv3s ? "#define USE_UV3" : "", e.pointsUvs ? "#define USE_POINTS_UV" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", e.morphColors ? "#define USE_MORPHCOLORS" : "", e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "", e.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`
    ].filter(oa).join(`
`
    ), p = [gp(e), "#define SHADER_TYPE " + e.shaderType, "#define SHADER_NAME " + e.shaderName, m, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", e.map ? "#define USE_MAP" : "", e.matcap ? "#define USE_MATCAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + c : "", e.envMap ? "#define " + h : "", e.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.anisotropy ? "#define USE_ANISOTROPY" : "", e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", e.clearcoat ? "#define USE_CLEARCOAT" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.dispersion ? "#define USE_DISPERSION" : "", e.iridescence ? "#define USE_IRIDESCENCE" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.alphaTest ? "#define USE_ALPHATEST" : "", e.alphaHash ? "#define USE_ALPHAHASH" : "", e.sheen ? "#define USE_SHEEN" : "", e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "", e.vertexColors || e.instancingColor || e.batchingColor ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUv1s ? "#define USE_UV1" : "", e.vertexUv2s ? "#define USE_UV2" : "", e.vertexUv3s ? "#define USE_UV3" : "", e.pointsUvs ? "#define USE_POINTS_UV" : "", e.gradientMap ? "#define USE_GRADIENTMAP" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", e.toneMapping !== Xs ? "#define TONE_MAPPING" : "", e.toneMapping !== Xs ? te.tonemapping_pars_fragment : "", e.toneMapping !== Xs ? _T("toneMapping", e.toneMapping) : "", e.dithering ? "#define DITHERING" : "", e.opaque ? "#define OPAQUE" : "", te.colorspace_pars_fragment, gT("linearToOutputTexel", e.outputColorSpace), xT(), e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "", `
`
    ].filter(oa).join(`
`
    )),
    o = wu(o),
    o = fp(o, e),
    o = pp(o, e),
    a = wu(a),
    a = fp(a, e),
    a = pp(a, e),
    o = mp(o),
    a = mp(a),
    e.isRawShaderMaterial !== !0 && (x = `#version 300 es
`
    , g = [f, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`
    ) + `
`
    + g, p = ["#define varying in", e.glslVersion === Pf ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", e.glslVersion === Pf ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`
    ) + `
`
    + p);
    const v = x + g + o,
        y = x + p + a,
        C = up(i, i.VERTEX_SHADER, v),
        A = up(i, i.FRAGMENT_SHADER, y);
    i.attachShader(_, C),
    i.attachShader(_, A),
    e.index0AttributeName !== void 0 ? i.bindAttribLocation(_, 0, e.index0AttributeName) : e.morphTargets === !0 && i.bindAttribLocation(_, 0, "position"),
    i.linkProgram(_);
    function T(D) {
        if (r.debug.checkShaderErrors) {
            const I = i.getProgramInfoLog(_).trim(),
                k = i.getShaderInfoLog(C).trim(),
                $ = i.getShaderInfoLog(A).trim();
            let j = !0,
                G = !0;
            if (i.getProgramParameter(_, i.LINK_STATUS) === !1)
                if (j = !1, typeof r.debug.onShaderError == "function")
                    r.debug.onShaderError(i, _, C, A);
                else {
                    const H = dp(i, C, "vertex"),
                        V = dp(i, A, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(_, i.VALIDATE_STATUS) + `

Material Name: `

                    + D.name + `
Material Type: `
                    + D.type + `

Program Info Log: `

                    + I + `
`
                    + H + `
`
                    + V)
                }
            else
                I !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", I) : (k === "" || $ === "") && (G = !1);
            G && (D.diagnostics = {
                runnable: j,
                programLog: I,
                vertexShader: {
                    log: k,
                    prefix: g
                },
                fragmentShader: {
                    log: $,
                    prefix: p
                }
            })
        }
        i.deleteShader(C),
        i.deleteShader(A),
        R = new Zl(i, _),
        E = MT(i, _)
    }
    let R;
    this.getUniforms = function() {
        return R === void 0 && T(this), R
    };
    let E;
    this.getAttributes = function() {
        return E === void 0 && T(this), E
    };
    let M = e.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return M === !1 && (M = i.getProgramParameter(_, dT)), M
    }, this.destroy = function() {
        n.releaseStatesOfProgram(this),
        i.deleteProgram(_),
        this.program = void 0
    }, this.type = e.shaderType, this.name = e.shaderName, this.id = fT++, this.cacheKey = t, this.usedTimes = 1, this.program = _, this.vertexShader = C, this.fragmentShader = A, this
}
let NT = 0;
class IT {
    constructor()
    {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(t)
    {
        const e = t.vertexShader,
            n = t.fragmentShader,
            i = this._getShaderStage(e),
            s = this._getShaderStage(n),
            o = this._getShaderCacheForMaterial(t);
        return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this
    }
    remove(t)
    {
        const e = this.materialCache.get(t);
        for (const n of e)
            n.usedTimes--,
            n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(t), this
    }
    getVertexShaderID(t)
    {
        return this._getShaderStage(t.vertexShader).id
    }
    getFragmentShaderID(t)
    {
        return this._getShaderStage(t.fragmentShader).id
    }
    dispose()
    {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(t)
    {
        const e = this.materialCache;
        let n = e.get(t);
        return n === void 0 && (n = new Set, e.set(t, n)), n
    }
    _getShaderStage(t)
    {
        const e = this.shaderCache;
        let n = e.get(t);
        return n === void 0 && (n = new FT(t), e.set(t, n)), n
    }
}
class FT {
    constructor(t)
    {
        this.id = NT++,
        this.code = t,
        this.usedTimes = 0
    }
}
function UT(r, t, e, n, i, s, o) {
    const a = new fg,
        l = new IT,
        c = new Set,
        h = [],
        u = i.logarithmicDepthBuffer,
        d = i.vertexTextures;
    let f = i.precision;
    const m = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function _(E) {
        return c.add(E), E === 0 ? "uv" : `uv${E}`
    }
    function g(E, M, D, I, k) {
        const $ = I.fog,
            j = k.geometry,
            G = E.isMeshStandardMaterial ? I.environment : null,
            H = (E.isMeshStandardMaterial ? e : t).get(E.envMap || G),
            V = H && H.mapping === Rc ? H.image.height : null,
            nt = m[E.type];
        E.precision !== null && (f = i.getMaxPrecision(E.precision), f !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", f, "instead."));
        const P = j.morphAttributes.position || j.morphAttributes.normal || j.morphAttributes.color,
            ct = P !== void 0 ? P.length : 0;
        let Ut = 0;
        j.morphAttributes.position !== void 0 && (Ut = 1),
        j.morphAttributes.normal !== void 0 && (Ut = 2),
        j.morphAttributes.color !== void 0 && (Ut = 3);
        let Zt,
            J,
            it,
            ft;
        if (nt) {
            const ne = Ui[nt];
            Zt = ne.vertexShader,
            J = ne.fragmentShader
        } else
            Zt = E.vertexShader,
            J = E.fragmentShader,
            l.update(E),
            it = l.getVertexShaderID(E),
            ft = l.getFragmentShaderID(E);
        const ut = r.getRenderTarget(),
            Pt = k.isInstancedMesh === !0,
            Nt = k.isBatchedMesh === !0,
            Kt = !!E.map,
            Jt = !!E.matcap,
            N = !!H,
            zt = !!E.aoMap,
            Bt = !!E.lightMap,
            jt = !!E.bumpMap,
            yt = !!E.normalMap,
            q = !!E.displacementMap,
            Lt = !!E.emissiveMap,
            kt = !!E.metalnessMap,
            L = !!E.roughnessMap,
            b = E.anisotropy > 0,
            K = E.clearcoat > 0,
            st = E.dispersion > 0,
            rt = E.iridescence > 0,
            Q = E.sheen > 0,
            At = E.transmission > 0,
            at = b && !!E.anisotropyMap,
            dt = K && !!E.clearcoatMap,
            Ot = K && !!E.clearcoatNormalMap,
            lt = K && !!E.clearcoatRoughnessMap,
            xt = rt && !!E.iridescenceMap,
            It = rt && !!E.iridescenceThicknessMap,
            Xt = Q && !!E.sheenColorMap,
            vt = Q && !!E.sheenRoughnessMap,
            Wt = !!E.specularMap,
            Yt = !!E.specularColorMap,
            de = !!E.specularIntensityMap,
            S = At && !!E.transmissionMap,
            F = At && !!E.thicknessMap,
            Y = !!E.gradientMap,
            Z = !!E.alphaMap,
            et = E.alphaTest > 0,
            Tt = !!E.alphaHash,
            Ht = !!E.extensions;
        let Te = Xs;
        E.toneMapped && (ut === null || ut.isXRRenderTarget === !0) && (Te = r.toneMapping);
        const xe = {
            shaderID: nt,
            shaderType: E.type,
            shaderName: E.name,
            vertexShader: Zt,
            fragmentShader: J,
            defines: E.defines,
            customVertexShaderID: it,
            customFragmentShaderID: ft,
            isRawShaderMaterial: E.isRawShaderMaterial === !0,
            glslVersion: E.glslVersion,
            precision: f,
            batching: Nt,
            batchingColor: Nt && k._colorsTexture !== null,
            instancing: Pt,
            instancingColor: Pt && k.instanceColor !== null,
            instancingMorph: Pt && k.morphTexture !== null,
            supportsVertexTextures: d,
            outputColorSpace: ut === null ? r.outputColorSpace : ut.isXRRenderTarget === !0 ? ut.texture.colorSpace : dn,
            alphaToCoverage: !!E.alphaToCoverage,
            map: Kt,
            matcap: Jt,
            envMap: N,
            envMapMode: N && H.mapping,
            envMapCubeUVHeight: V,
            aoMap: zt,
            lightMap: Bt,
            bumpMap: jt,
            normalMap: yt,
            displacementMap: d && q,
            emissiveMap: Lt,
            normalMapObjectSpace: yt && E.normalMapType === Lx,
            normalMapTangentSpace: yt && E.normalMapType === yd,
            metalnessMap: kt,
            roughnessMap: L,
            anisotropy: b,
            anisotropyMap: at,
            clearcoat: K,
            clearcoatMap: dt,
            clearcoatNormalMap: Ot,
            clearcoatRoughnessMap: lt,
            dispersion: st,
            iridescence: rt,
            iridescenceMap: xt,
            iridescenceThicknessMap: It,
            sheen: Q,
            sheenColorMap: Xt,
            sheenRoughnessMap: vt,
            specularMap: Wt,
            specularColorMap: Yt,
            specularIntensityMap: de,
            transmission: At,
            transmissionMap: S,
            thicknessMap: F,
            gradientMap: Y,
            opaque: E.transparent === !1 && E.blending === uo && E.alphaToCoverage === !1,
            alphaMap: Z,
            alphaTest: et,
            alphaHash: Tt,
            combine: E.combine,
            mapUv: Kt && _(E.map.channel),
            aoMapUv: zt && _(E.aoMap.channel),
            lightMapUv: Bt && _(E.lightMap.channel),
            bumpMapUv: jt && _(E.bumpMap.channel),
            normalMapUv: yt && _(E.normalMap.channel),
            displacementMapUv: q && _(E.displacementMap.channel),
            emissiveMapUv: Lt && _(E.emissiveMap.channel),
            metalnessMapUv: kt && _(E.metalnessMap.channel),
            roughnessMapUv: L && _(E.roughnessMap.channel),
            anisotropyMapUv: at && _(E.anisotropyMap.channel),
            clearcoatMapUv: dt && _(E.clearcoatMap.channel),
            clearcoatNormalMapUv: Ot && _(E.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: lt && _(E.clearcoatRoughnessMap.channel),
            iridescenceMapUv: xt && _(E.iridescenceMap.channel),
            iridescenceThicknessMapUv: It && _(E.iridescenceThicknessMap.channel),
            sheenColorMapUv: Xt && _(E.sheenColorMap.channel),
            sheenRoughnessMapUv: vt && _(E.sheenRoughnessMap.channel),
            specularMapUv: Wt && _(E.specularMap.channel),
            specularColorMapUv: Yt && _(E.specularColorMap.channel),
            specularIntensityMapUv: de && _(E.specularIntensityMap.channel),
            transmissionMapUv: S && _(E.transmissionMap.channel),
            thicknessMapUv: F && _(E.thicknessMap.channel),
            alphaMapUv: Z && _(E.alphaMap.channel),
            vertexTangents: !!j.attributes.tangent && (yt || b),
            vertexColors: E.vertexColors,
            vertexAlphas: E.vertexColors === !0 && !!j.attributes.color && j.attributes.color.itemSize === 4,
            pointsUvs: k.isPoints === !0 && !!j.attributes.uv && (Kt || Z),
            fog: !!$,
            useFog: E.fog === !0,
            fogExp2: !!$ && $.isFogExp2,
            flatShading: E.flatShading === !0,
            sizeAttenuation: E.sizeAttenuation === !0,
            logarithmicDepthBuffer: u,
            skinning: k.isSkinnedMesh === !0,
            morphTargets: j.morphAttributes.position !== void 0,
            morphNormals: j.morphAttributes.normal !== void 0,
            morphColors: j.morphAttributes.color !== void 0,
            morphTargetsCount: ct,
            morphTextureStride: Ut,
            numDirLights: M.directional.length,
            numPointLights: M.point.length,
            numSpotLights: M.spot.length,
            numSpotLightMaps: M.spotLightMap.length,
            numRectAreaLights: M.rectArea.length,
            numHemiLights: M.hemi.length,
            numDirLightShadows: M.directionalShadowMap.length,
            numPointLightShadows: M.pointShadowMap.length,
            numSpotLightShadows: M.spotShadowMap.length,
            numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
            numLightProbes: M.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: E.dithering,
            shadowMapEnabled: r.shadowMap.enabled && D.length > 0,
            shadowMapType: r.shadowMap.type,
            toneMapping: Te,
            decodeVideoTexture: Kt && E.map.isVideoTexture === !0 && me.getTransfer(E.map.colorSpace) === Ne,
            premultipliedAlpha: E.premultipliedAlpha,
            doubleSided: E.side === wi,
            flipSided: E.side === kn,
            useDepthPacking: E.depthPacking >= 0,
            depthPacking: E.depthPacking || 0,
            index0AttributeName: E.index0AttributeName,
            extensionClipCullDistance: Ht && E.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Ht && E.extensions.multiDraw === !0 || Nt) && n.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: E.customProgramCacheKey()
        };
        return xe.vertexUv1s = c.has(1), xe.vertexUv2s = c.has(2), xe.vertexUv3s = c.has(3), c.clear(), xe
    }
    function p(E) {
        const M = [];
        if (E.shaderID ? M.push(E.shaderID) : (M.push(E.customVertexShaderID), M.push(E.customFragmentShaderID)), E.defines !== void 0)
            for (const D in E.defines)
                M.push(D),
                M.push(E.defines[D]);
        return E.isRawShaderMaterial === !1 && (x(M, E), v(M, E), M.push(r.outputColorSpace)), M.push(E.customProgramCacheKey), M.join()
    }
    function x(E, M) {
        E.push(M.precision),
        E.push(M.outputColorSpace),
        E.push(M.envMapMode),
        E.push(M.envMapCubeUVHeight),
        E.push(M.mapUv),
        E.push(M.alphaMapUv),
        E.push(M.lightMapUv),
        E.push(M.aoMapUv),
        E.push(M.bumpMapUv),
        E.push(M.normalMapUv),
        E.push(M.displacementMapUv),
        E.push(M.emissiveMapUv),
        E.push(M.metalnessMapUv),
        E.push(M.roughnessMapUv),
        E.push(M.anisotropyMapUv),
        E.push(M.clearcoatMapUv),
        E.push(M.clearcoatNormalMapUv),
        E.push(M.clearcoatRoughnessMapUv),
        E.push(M.iridescenceMapUv),
        E.push(M.iridescenceThicknessMapUv),
        E.push(M.sheenColorMapUv),
        E.push(M.sheenRoughnessMapUv),
        E.push(M.specularMapUv),
        E.push(M.specularColorMapUv),
        E.push(M.specularIntensityMapUv),
        E.push(M.transmissionMapUv),
        E.push(M.thicknessMapUv),
        E.push(M.combine),
        E.push(M.fogExp2),
        E.push(M.sizeAttenuation),
        E.push(M.morphTargetsCount),
        E.push(M.morphAttributeCount),
        E.push(M.numDirLights),
        E.push(M.numPointLights),
        E.push(M.numSpotLights),
        E.push(M.numSpotLightMaps),
        E.push(M.numHemiLights),
        E.push(M.numRectAreaLights),
        E.push(M.numDirLightShadows),
        E.push(M.numPointLightShadows),
        E.push(M.numSpotLightShadows),
        E.push(M.numSpotLightShadowsWithMaps),
        E.push(M.numLightProbes),
        E.push(M.shadowMapType),
        E.push(M.toneMapping),
        E.push(M.numClippingPlanes),
        E.push(M.numClipIntersection),
        E.push(M.depthPacking)
    }
    function v(E, M) {
        a.disableAll(),
        M.supportsVertexTextures && a.enable(0),
        M.instancing && a.enable(1),
        M.instancingColor && a.enable(2),
        M.instancingMorph && a.enable(3),
        M.matcap && a.enable(4),
        M.envMap && a.enable(5),
        M.normalMapObjectSpace && a.enable(6),
        M.normalMapTangentSpace && a.enable(7),
        M.clearcoat && a.enable(8),
        M.iridescence && a.enable(9),
        M.alphaTest && a.enable(10),
        M.vertexColors && a.enable(11),
        M.vertexAlphas && a.enable(12),
        M.vertexUv1s && a.enable(13),
        M.vertexUv2s && a.enable(14),
        M.vertexUv3s && a.enable(15),
        M.vertexTangents && a.enable(16),
        M.anisotropy && a.enable(17),
        M.alphaHash && a.enable(18),
        M.batching && a.enable(19),
        M.dispersion && a.enable(20),
        M.batchingColor && a.enable(21),
        E.push(a.mask),
        a.disableAll(),
        M.fog && a.enable(0),
        M.useFog && a.enable(1),
        M.flatShading && a.enable(2),
        M.logarithmicDepthBuffer && a.enable(3),
        M.skinning && a.enable(4),
        M.morphTargets && a.enable(5),
        M.morphNormals && a.enable(6),
        M.morphColors && a.enable(7),
        M.premultipliedAlpha && a.enable(8),
        M.shadowMapEnabled && a.enable(9),
        M.doubleSided && a.enable(10),
        M.flipSided && a.enable(11),
        M.useDepthPacking && a.enable(12),
        M.dithering && a.enable(13),
        M.transmission && a.enable(14),
        M.sheen && a.enable(15),
        M.opaque && a.enable(16),
        M.pointsUvs && a.enable(17),
        M.decodeVideoTexture && a.enable(18),
        M.alphaToCoverage && a.enable(19),
        E.push(a.mask)
    }
    function y(E) {
        const M = m[E.type];
        let D;
        if (M) {
            const I = Ui[M];
            D = pc.clone(I.uniforms)
        } else
            D = E.uniforms;
        return D
    }
    function C(E, M) {
        let D;
        for (let I = 0, k = h.length; I < k; I++) {
            const $ = h[I];
            if ($.cacheKey === M) {
                D = $,
                ++D.usedTimes;
                break
            }
        }
        return D === void 0 && (D = new DT(r, M, E, s), h.push(D)), D
    }
    function A(E) {
        if (--E.usedTimes === 0) {
            const M = h.indexOf(E);
            h[M] = h[h.length - 1],
            h.pop(),
            E.destroy()
        }
    }
    function T(E) {
        l.remove(E)
    }
    function R() {
        l.dispose()
    }
    return {
        getParameters: g,
        getProgramCacheKey: p,
        getUniforms: y,
        acquireProgram: C,
        releaseProgram: A,
        releaseShaderCache: T,
        programs: h,
        dispose: R
    }
}
function OT() {
    let r = new WeakMap;
    function t(s) {
        let o = r.get(s);
        return o === void 0 && (o = {}, r.set(s, o)), o
    }
    function e(s) {
        r.delete(s)
    }
    function n(s, o, a) {
        r.get(s)[o] = a
    }
    function i() {
        r = new WeakMap
    }
    return {
        get: t,
        remove: e,
        update: n,
        dispose: i
    }
}
function zT(r, t) {
    return r.groupOrder !== t.groupOrder ? r.groupOrder - t.groupOrder : r.renderOrder !== t.renderOrder ? r.renderOrder - t.renderOrder : r.material.id !== t.material.id ? r.material.id - t.material.id : r.z !== t.z ? r.z - t.z : r.id - t.id
}
function _p(r, t) {
    return r.groupOrder !== t.groupOrder ? r.groupOrder - t.groupOrder : r.renderOrder !== t.renderOrder ? r.renderOrder - t.renderOrder : r.z !== t.z ? t.z - r.z : r.id - t.id
}
function xp() {
    const r = [];
    let t = 0;
    const e = [],
        n = [],
        i = [];
    function s() {
        t = 0,
        e.length = 0,
        n.length = 0,
        i.length = 0
    }
    function o(u, d, f, m, _, g) {
        let p = r[t];
        return p === void 0 ? (p = {
            id: u.id,
            object: u,
            geometry: d,
            material: f,
            groupOrder: m,
            renderOrder: u.renderOrder,
            z: _,
            group: g
        }, r[t] = p) : (p.id = u.id, p.object = u, p.geometry = d, p.material = f, p.groupOrder = m, p.renderOrder = u.renderOrder, p.z = _, p.group = g), t++, p
    }
    function a(u, d, f, m, _, g) {
        const p = o(u, d, f, m, _, g);
        f.transmission > 0 ? n.push(p) : f.transparent === !0 ? i.push(p) : e.push(p)
    }
    function l(u, d, f, m, _, g) {
        const p = o(u, d, f, m, _, g);
        f.transmission > 0 ? n.unshift(p) : f.transparent === !0 ? i.unshift(p) : e.unshift(p)
    }
    function c(u, d) {
        e.length > 1 && e.sort(u || zT),
        n.length > 1 && n.sort(d || _p),
        i.length > 1 && i.sort(d || _p)
    }
    function h() {
        for (let u = t, d = r.length; u < d; u++) {
            const f = r[u];
            if (f.id === null)
                break;
            f.id = null,
            f.object = null,
            f.geometry = null,
            f.material = null,
            f.group = null
        }
    }
    return {
        opaque: e,
        transmissive: n,
        transparent: i,
        init: s,
        push: a,
        unshift: l,
        finish: h,
        sort: c
    }
}
function BT() {
    let r = new WeakMap;
    function t(n, i) {
        const s = r.get(n);
        let o;
        return s === void 0 ? (o = new xp, r.set(n, [o])) : i >= s.length ? (o = new xp, s.push(o)) : o = s[i], o
    }
    function e() {
        r = new WeakMap
    }
    return {
        get: t,
        dispose: e
    }
}
function kT() {
    const r = {};
    return {
        get: function(t) {
            if (r[t.id] !== void 0)
                return r[t.id];
            let e;
            switch (t.type) {
            case "DirectionalLight":
                e = {
                    direction: new O,
                    color: new Gt
                };
                break;
            case "SpotLight":
                e = {
                    position: new O,
                    direction: new O,
                    color: new Gt,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                e = {
                    position: new O,
                    color: new Gt,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                e = {
                    direction: new O,
                    skyColor: new Gt,
                    groundColor: new Gt
                };
                break;
            case "RectAreaLight":
                e = {
                    color: new Gt,
                    position: new O,
                    halfWidth: new O,
                    halfHeight: new O
                };
                break
            }
            return r[t.id] = e, e
        }
    }
}
function HT() {
    const r = {};
    return {
        get: function(t) {
            if (r[t.id] !== void 0)
                return r[t.id];
            let e;
            switch (t.type) {
            case "DirectionalLight":
                e = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new St
                };
                break;
            case "SpotLight":
                e = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new St
                };
                break;
            case "PointLight":
                e = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new St,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return r[t.id] = e, e
        }
    }
}
let VT = 0;
function GT(r, t) {
    return (t.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (r.map ? 1 : 0)
}
function WT(r) {
    const t = new kT,
        e = HT(),
        n = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
    for (let c = 0; c < 9; c++)
        n.probe.push(new O);
    const i = new O,
        s = new le,
        o = new le;
    function a(c) {
        let h = 0,
            u = 0,
            d = 0;
        for (let E = 0; E < 9; E++)
            n.probe[E].set(0, 0, 0);
        let f = 0,
            m = 0,
            _ = 0,
            g = 0,
            p = 0,
            x = 0,
            v = 0,
            y = 0,
            C = 0,
            A = 0,
            T = 0;
        c.sort(GT);
        for (let E = 0, M = c.length; E < M; E++) {
            const D = c[E],
                I = D.color,
                k = D.intensity,
                $ = D.distance,
                j = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
            if (D.isAmbientLight)
                h += I.r * k,
                u += I.g * k,
                d += I.b * k;
            else if (D.isLightProbe) {
                for (let G = 0; G < 9; G++)
                    n.probe[G].addScaledVector(D.sh.coefficients[G], k);
                T++
            } else if (D.isDirectionalLight) {
                const G = t.get(D);
                if (G.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow) {
                    const H = D.shadow,
                        V = e.get(D);
                    V.shadowIntensity = H.intensity,
                    V.shadowBias = H.bias,
                    V.shadowNormalBias = H.normalBias,
                    V.shadowRadius = H.radius,
                    V.shadowMapSize = H.mapSize,
                    n.directionalShadow[f] = V,
                    n.directionalShadowMap[f] = j,
                    n.directionalShadowMatrix[f] = D.shadow.matrix,
                    x++
                }
                n.directional[f] = G,
                f++
            } else if (D.isSpotLight) {
                const G = t.get(D);
                G.position.setFromMatrixPosition(D.matrixWorld),
                G.color.copy(I).multiplyScalar(k),
                G.distance = $,
                G.coneCos = Math.cos(D.angle),
                G.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)),
                G.decay = D.decay,
                n.spot[_] = G;
                const H = D.shadow;
                if (D.map && (n.spotLightMap[C] = D.map, C++, H.updateMatrices(D), D.castShadow && A++), n.spotLightMatrix[_] = H.matrix, D.castShadow) {
                    const V = e.get(D);
                    V.shadowIntensity = H.intensity,
                    V.shadowBias = H.bias,
                    V.shadowNormalBias = H.normalBias,
                    V.shadowRadius = H.radius,
                    V.shadowMapSize = H.mapSize,
                    n.spotShadow[_] = V,
                    n.spotShadowMap[_] = j,
                    y++
                }
                _++
            } else if (D.isRectAreaLight) {
                const G = t.get(D);
                G.color.copy(I).multiplyScalar(k),
                G.halfWidth.set(D.width * .5, 0, 0),
                G.halfHeight.set(0, D.height * .5, 0),
                n.rectArea[g] = G,
                g++
            } else if (D.isPointLight) {
                const G = t.get(D);
                if (G.color.copy(D.color).multiplyScalar(D.intensity), G.distance = D.distance, G.decay = D.decay, D.castShadow) {
                    const H = D.shadow,
                        V = e.get(D);
                    V.shadowIntensity = H.intensity,
                    V.shadowBias = H.bias,
                    V.shadowNormalBias = H.normalBias,
                    V.shadowRadius = H.radius,
                    V.shadowMapSize = H.mapSize,
                    V.shadowCameraNear = H.camera.near,
                    V.shadowCameraFar = H.camera.far,
                    n.pointShadow[m] = V,
                    n.pointShadowMap[m] = j,
                    n.pointShadowMatrix[m] = D.shadow.matrix,
                    v++
                }
                n.point[m] = G,
                m++
            } else if (D.isHemisphereLight) {
                const G = t.get(D);
                G.skyColor.copy(D.color).multiplyScalar(k),
                G.groundColor.copy(D.groundColor).multiplyScalar(k),
                n.hemi[p] = G,
                p++
            }
        }
        g > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = _t.LTC_FLOAT_1, n.rectAreaLTC2 = _t.LTC_FLOAT_2) : (n.rectAreaLTC1 = _t.LTC_HALF_1, n.rectAreaLTC2 = _t.LTC_HALF_2)),
        n.ambient[0] = h,
        n.ambient[1] = u,
        n.ambient[2] = d;
        const R = n.hash;
        (R.directionalLength !== f || R.pointLength !== m || R.spotLength !== _ || R.rectAreaLength !== g || R.hemiLength !== p || R.numDirectionalShadows !== x || R.numPointShadows !== v || R.numSpotShadows !== y || R.numSpotMaps !== C || R.numLightProbes !== T) && (n.directional.length = f, n.spot.length = _, n.rectArea.length = g, n.point.length = m, n.hemi.length = p, n.directionalShadow.length = x, n.directionalShadowMap.length = x, n.pointShadow.length = v, n.pointShadowMap.length = v, n.spotShadow.length = y, n.spotShadowMap.length = y, n.directionalShadowMatrix.length = x, n.pointShadowMatrix.length = v, n.spotLightMatrix.length = y + C - A, n.spotLightMap.length = C, n.numSpotLightShadowsWithMaps = A, n.numLightProbes = T, R.directionalLength = f, R.pointLength = m, R.spotLength = _, R.rectAreaLength = g, R.hemiLength = p, R.numDirectionalShadows = x, R.numPointShadows = v, R.numSpotShadows = y, R.numSpotMaps = C, R.numLightProbes = T, n.version = VT++)
    }
    function l(c, h) {
        let u = 0,
            d = 0,
            f = 0,
            m = 0,
            _ = 0;
        const g = h.matrixWorldInverse;
        for (let p = 0, x = c.length; p < x; p++) {
            const v = c[p];
            if (v.isDirectionalLight) {
                const y = n.directional[u];
                y.direction.setFromMatrixPosition(v.matrixWorld),
                i.setFromMatrixPosition(v.target.matrixWorld),
                y.direction.sub(i),
                y.direction.transformDirection(g),
                u++
            } else if (v.isSpotLight) {
                const y = n.spot[f];
                y.position.setFromMatrixPosition(v.matrixWorld),
                y.position.applyMatrix4(g),
                y.direction.setFromMatrixPosition(v.matrixWorld),
                i.setFromMatrixPosition(v.target.matrixWorld),
                y.direction.sub(i),
                y.direction.transformDirection(g),
                f++
            } else if (v.isRectAreaLight) {
                const y = n.rectArea[m];
                y.position.setFromMatrixPosition(v.matrixWorld),
                y.position.applyMatrix4(g),
                o.identity(),
                s.copy(v.matrixWorld),
                s.premultiply(g),
                o.extractRotation(s),
                y.halfWidth.set(v.width * .5, 0, 0),
                y.halfHeight.set(0, v.height * .5, 0),
                y.halfWidth.applyMatrix4(o),
                y.halfHeight.applyMatrix4(o),
                m++
            } else if (v.isPointLight) {
                const y = n.point[d];
                y.position.setFromMatrixPosition(v.matrixWorld),
                y.position.applyMatrix4(g),
                d++
            } else if (v.isHemisphereLight) {
                const y = n.hemi[_];
                y.direction.setFromMatrixPosition(v.matrixWorld),
                y.direction.transformDirection(g),
                _++
            }
        }
    }
    return {
        setup: a,
        setupView: l,
        state: n
    }
}
function vp(r) {
    const t = new WT(r),
        e = [],
        n = [];
    function i(h) {
        c.camera = h,
        e.length = 0,
        n.length = 0
    }
    function s(h) {
        e.push(h)
    }
    function o(h) {
        n.push(h)
    }
    function a() {
        t.setup(e)
    }
    function l(h) {
        t.setupView(e, h)
    }
    const c = {
        lightsArray: e,
        shadowsArray: n,
        camera: null,
        lights: t,
        transmissionRenderTarget: {}
    };
    return {
        init: i,
        state: c,
        setupLights: a,
        setupLightsView: l,
        pushLight: s,
        pushShadow: o
    }
}
function XT(r) {
    let t = new WeakMap;
    function e(i, s=0) {
        const o = t.get(i);
        let a;
        return o === void 0 ? (a = new vp(r), t.set(i, [a])) : s >= o.length ? (a = new vp(r), o.push(a)) : a = o[s], a
    }
    function n() {
        t = new WeakMap
    }
    return {
        get: e,
        dispose: n
    }
}
class YT extends Li {
    constructor(t)
    {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = Rx,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(t)
    }
    copy(t)
    {
        return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }
}
class $T extends Li {
    constructor(t)
    {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(t)
    }
    copy(t)
    {
        return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    }
}
const qT = `void main() {
	gl_Position = vec4( position, 1.0 );
}`

    ,
    KT = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`

























    ;
function jT(r, t, e) {
    let n = new Td;
    const i = new St,
        s = new St,
        o = new Pe,
        a = new YT({
            depthPacking: Px
        }),
        l = new $T,
        c = {},
        h = e.maxTextureSize,
        u = {
            [_s]: kn,
            [kn]: _s,
            [wi]: wi
        },
        d = new On({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new St
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: qT,
            fragmentShader: KT
        }),
        f = d.clone();
    f.defines.HORIZONTAL_PASS = 1;
    const m = new Ni;
    m.setAttribute("position", new zn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const _ = new Un(m, d),
        g = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = Xm;
    let p = this.type;
    this.render = function(A, T, R) {
        if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || A.length === 0)
            return;
        const E = r.getRenderTarget(),
            M = r.getActiveCubeFace(),
            D = r.getActiveMipmapLevel(),
            I = r.state;
        I.setBlending(ps),
        I.buffers.color.setClear(1, 1, 1, 1),
        I.buffers.depth.setTest(!0),
        I.setScissorTest(!1);
        const k = p !== ss && this.type === ss,
            $ = p === ss && this.type !== ss;
        for (let j = 0, G = A.length; j < G; j++) {
            const H = A[j],
                V = H.shadow;
            if (V === void 0) {
                console.warn("THREE.WebGLShadowMap:", H, "has no shadow.");
                continue
            }
            if (V.autoUpdate === !1 && V.needsUpdate === !1)
                continue;
            i.copy(V.mapSize);
            const nt = V.getFrameExtents();
            if (i.multiply(nt), s.copy(V.mapSize), (i.x > h || i.y > h) && (i.x > h && (s.x = Math.floor(h / nt.x), i.x = s.x * nt.x, V.mapSize.x = s.x), i.y > h && (s.y = Math.floor(h / nt.y), i.y = s.y * nt.y, V.mapSize.y = s.y)), V.map === null || k === !0 || $ === !0) {
                const ct = this.type !== ss ? {
                    minFilter: Fn,
                    magFilter: Fn
                } : {};
                V.map !== null && V.map.dispose(),
                V.map = new Pi(i.x, i.y, ct),
                V.map.texture.name = H.name + ".shadowMap",
                V.camera.updateProjectionMatrix()
            }
            r.setRenderTarget(V.map),
            r.clear();
            const P = V.getViewportCount();
            for (let ct = 0; ct < P; ct++) {
                const Ut = V.getViewport(ct);
                o.set(s.x * Ut.x, s.y * Ut.y, s.x * Ut.z, s.y * Ut.w),
                I.viewport(o),
                V.updateMatrices(H, ct),
                n = V.getFrustum(),
                y(T, R, V.camera, H, this.type)
            }
            V.isPointLightShadow !== !0 && this.type === ss && x(V, R),
            V.needsUpdate = !1
        }
        p = this.type,
        g.needsUpdate = !1,
        r.setRenderTarget(E, M, D)
    };
    function x(A, T) {
        const R = t.update(_);
        d.defines.VSM_SAMPLES !== A.blurSamples && (d.defines.VSM_SAMPLES = A.blurSamples, f.defines.VSM_SAMPLES = A.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0),
        A.mapPass === null && (A.mapPass = new Pi(i.x, i.y)),
        d.uniforms.shadow_pass.value = A.map.texture,
        d.uniforms.resolution.value = A.mapSize,
        d.uniforms.radius.value = A.radius,
        r.setRenderTarget(A.mapPass),
        r.clear(),
        r.renderBufferDirect(T, null, R, d, _, null),
        f.uniforms.shadow_pass.value = A.mapPass.texture,
        f.uniforms.resolution.value = A.mapSize,
        f.uniforms.radius.value = A.radius,
        r.setRenderTarget(A.map),
        r.clear(),
        r.renderBufferDirect(T, null, R, f, _, null)
    }
    function v(A, T, R, E) {
        let M = null;
        const D = R.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
        if (D !== void 0)
            M = D;
        else if (M = R.isPointLight === !0 ? l : a, r.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0) {
            const I = M.uuid,
                k = T.uuid;
            let $ = c[I];
            $ === void 0 && ($ = {}, c[I] = $);
            let j = $[k];
            j === void 0 && (j = M.clone(), $[k] = j, T.addEventListener("dispose", C)),
            M = j
        }
        if (M.visible = T.visible, M.wireframe = T.wireframe, E === ss ? M.side = T.shadowSide !== null ? T.shadowSide : T.side : M.side = T.shadowSide !== null ? T.shadowSide : u[T.side], M.alphaMap = T.alphaMap, M.alphaTest = T.alphaTest, M.map = T.map, M.clipShadows = T.clipShadows, M.clippingPlanes = T.clippingPlanes, M.clipIntersection = T.clipIntersection, M.displacementMap = T.displacementMap, M.displacementScale = T.displacementScale, M.displacementBias = T.displacementBias, M.wireframeLinewidth = T.wireframeLinewidth, M.linewidth = T.linewidth, R.isPointLight === !0 && M.isMeshDistanceMaterial === !0) {
            const I = r.properties.get(M);
            I.light = R
        }
        return M
    }
    function y(A, T, R, E, M) {
        if (A.visible === !1)
            return;
        if (A.layers.test(T.layers) && (A.isMesh || A.isLine || A.isPoints) && (A.castShadow || A.receiveShadow && M === ss) && (!A.frustumCulled || n.intersectsObject(A))) {
            A.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, A.matrixWorld);
            const k = t.update(A),
                $ = A.material;
            if (Array.isArray($)) {
                const j = k.groups;
                for (let G = 0, H = j.length; G < H; G++) {
                    const V = j[G],
                        nt = $[V.materialIndex];
                    if (nt && nt.visible) {
                        const P = v(A, nt, E, M);
                        A.onBeforeShadow(r, A, T, R, k, P, V),
                        r.renderBufferDirect(R, null, k, P, A, V),
                        A.onAfterShadow(r, A, T, R, k, P, V)
                    }
                }
            } else if ($.visible) {
                const j = v(A, $, E, M);
                A.onBeforeShadow(r, A, T, R, k, j, null),
                r.renderBufferDirect(R, null, k, j, A, null),
                A.onAfterShadow(r, A, T, R, k, j, null)
            }
        }
        const I = A.children;
        for (let k = 0, $ = I.length; k < $; k++)
            y(I[k], T, R, E, M)
    }
    function C(A) {
        A.target.removeEventListener("dispose", C);
        for (const R in c) {
            const E = c[R],
                M = A.target.uuid;
            M in E && (E[M].dispose(), delete E[M])
        }
    }
}
function ZT(r) {
    function t() {
        let S = !1;
        const F = new Pe;
        let Y = null;
        const Z = new Pe(0, 0, 0, 0);
        return {
            setMask: function(et) {
                Y !== et && !S && (r.colorMask(et, et, et, et), Y = et)
            },
            setLocked: function(et) {
                S = et
            },
            setClear: function(et, Tt, Ht, Te, xe) {
                xe === !0 && (et *= Te, Tt *= Te, Ht *= Te),
                F.set(et, Tt, Ht, Te),
                Z.equals(F) === !1 && (r.clearColor(et, Tt, Ht, Te), Z.copy(F))
            },
            reset: function() {
                S = !1,
                Y = null,
                Z.set(-1, 0, 0, 0)
            }
        }
    }
    function e() {
        let S = !1,
            F = null,
            Y = null,
            Z = null;
        return {
            setTest: function(et) {
                et ? ft(r.DEPTH_TEST) : ut(r.DEPTH_TEST)
            },
            setMask: function(et) {
                F !== et && !S && (r.depthMask(et), F = et)
            },
            setFunc: function(et) {
                if (Y !== et) {
                    switch (et) {
                    case hx:
                        r.depthFunc(r.NEVER);
                        break;
                    case ux:
                        r.depthFunc(r.ALWAYS);
                        break;
                    case dx:
                        r.depthFunc(r.LESS);
                        break;
                    case ac:
                        r.depthFunc(r.LEQUAL);
                        break;
                    case fx:
                        r.depthFunc(r.EQUAL);
                        break;
                    case px:
                        r.depthFunc(r.GEQUAL);
                        break;
                    case mx:
                        r.depthFunc(r.GREATER);
                        break;
                    case gx:
                        r.depthFunc(r.NOTEQUAL);
                        break;
                    default:
                        r.depthFunc(r.LEQUAL)
                    }
                    Y = et
                }
            },
            setLocked: function(et) {
                S = et
            },
            setClear: function(et) {
                Z !== et && (r.clearDepth(et), Z = et)
            },
            reset: function() {
                S = !1,
                F = null,
                Y = null,
                Z = null
            }
        }
    }
    function n() {
        let S = !1,
            F = null,
            Y = null,
            Z = null,
            et = null,
            Tt = null,
            Ht = null,
            Te = null,
            xe = null;
        return {
            setTest: function(ne) {
                S || (ne ? ft(r.STENCIL_TEST) : ut(r.STENCIL_TEST))
            },
            setMask: function(ne) {
                F !== ne && !S && (r.stencilMask(ne), F = ne)
            },
            setFunc: function(ne, Ct, Mt) {
                (Y !== ne || Z !== Ct || et !== Mt) && (r.stencilFunc(ne, Ct, Mt), Y = ne, Z = Ct, et = Mt)
            },
            setOp: function(ne, Ct, Mt) {
                (Tt !== ne || Ht !== Ct || Te !== Mt) && (r.stencilOp(ne, Ct, Mt), Tt = ne, Ht = Ct, Te = Mt)
            },
            setLocked: function(ne) {
                S = ne
            },
            setClear: function(ne) {
                xe !== ne && (r.clearStencil(ne), xe = ne)
            },
            reset: function() {
                S = !1,
                F = null,
                Y = null,
                Z = null,
                et = null,
                Tt = null,
                Ht = null,
                Te = null,
                xe = null
            }
        }
    }
    const i = new t,
        s = new e,
        o = new n,
        a = new WeakMap,
        l = new WeakMap;
    let c = {},
        h = {},
        u = new WeakMap,
        d = [],
        f = null,
        m = !1,
        _ = null,
        g = null,
        p = null,
        x = null,
        v = null,
        y = null,
        C = null,
        A = new Gt(0, 0, 0),
        T = 0,
        R = !1,
        E = null,
        M = null,
        D = null,
        I = null,
        k = null;
    const $ = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let j = !1,
        G = 0;
    const H = r.getParameter(r.VERSION);
    H.indexOf("WebGL") !== -1 ? (G = parseFloat(/^WebGL (\d)/.exec(H)[1]), j = G >= 1) : H.indexOf("OpenGL ES") !== -1 && (G = parseFloat(/^OpenGL ES (\d)/.exec(H)[1]), j = G >= 2);
    let V = null,
        nt = {};
    const P = r.getParameter(r.SCISSOR_BOX),
        ct = r.getParameter(r.VIEWPORT),
        Ut = new Pe().fromArray(P),
        Zt = new Pe().fromArray(ct);
    function J(S, F, Y, Z) {
        const et = new Uint8Array(4),
            Tt = r.createTexture();
        r.bindTexture(S, Tt),
        r.texParameteri(S, r.TEXTURE_MIN_FILTER, r.NEAREST),
        r.texParameteri(S, r.TEXTURE_MAG_FILTER, r.NEAREST);
        for (let Ht = 0; Ht < Y; Ht++)
            S === r.TEXTURE_3D || S === r.TEXTURE_2D_ARRAY ? r.texImage3D(F, 0, r.RGBA, 1, 1, Z, 0, r.RGBA, r.UNSIGNED_BYTE, et) : r.texImage2D(F + Ht, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, et);
        return Tt
    }
    const it = {};
    it[r.TEXTURE_2D] = J(r.TEXTURE_2D, r.TEXTURE_2D, 1),
    it[r.TEXTURE_CUBE_MAP] = J(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    it[r.TEXTURE_2D_ARRAY] = J(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1),
    it[r.TEXTURE_3D] = J(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1),
    i.setClear(0, 0, 0, 1),
    s.setClear(1),
    o.setClear(0),
    ft(r.DEPTH_TEST),
    s.setFunc(ac),
    jt(!1),
    yt(Sf),
    ft(r.CULL_FACE),
    zt(ps);
    function ft(S) {
        c[S] !== !0 && (r.enable(S), c[S] = !0)
    }
    function ut(S) {
        c[S] !== !1 && (r.disable(S), c[S] = !1)
    }
    function Pt(S, F) {
        return h[S] !== F ? (r.bindFramebuffer(S, F), h[S] = F, S === r.DRAW_FRAMEBUFFER && (h[r.FRAMEBUFFER] = F), S === r.FRAMEBUFFER && (h[r.DRAW_FRAMEBUFFER] = F), !0) : !1
    }
    function Nt(S, F) {
        let Y = d,
            Z = !1;
        if (S) {
            Y = u.get(F),
            Y === void 0 && (Y = [], u.set(F, Y));
            const et = S.textures;
            if (Y.length !== et.length || Y[0] !== r.COLOR_ATTACHMENT0) {
                for (let Tt = 0, Ht = et.length; Tt < Ht; Tt++)
                    Y[Tt] = r.COLOR_ATTACHMENT0 + Tt;
                Y.length = et.length,
                Z = !0
            }
        } else
            Y[0] !== r.BACK && (Y[0] = r.BACK, Z = !0);
        Z && r.drawBuffers(Y)
    }
    function Kt(S) {
        return f !== S ? (r.useProgram(S), f = S, !0) : !1
    }
    const Jt = {
        [dr]: r.FUNC_ADD,
        [$0]: r.FUNC_SUBTRACT,
        [q0]: r.FUNC_REVERSE_SUBTRACT
    };
    Jt[K0] = r.MIN,
    Jt[j0] = r.MAX;
    const N = {
        [Z0]: r.ZERO,
        [J0]: r.ONE,
        [Q0]: r.SRC_COLOR,
        [$h]: r.SRC_ALPHA,
        [rx]: r.SRC_ALPHA_SATURATE,
        [ix]: r.DST_COLOR,
        [ex]: r.DST_ALPHA,
        [tx]: r.ONE_MINUS_SRC_COLOR,
        [qh]: r.ONE_MINUS_SRC_ALPHA,
        [sx]: r.ONE_MINUS_DST_COLOR,
        [nx]: r.ONE_MINUS_DST_ALPHA,
        [ox]: r.CONSTANT_COLOR,
        [ax]: r.ONE_MINUS_CONSTANT_COLOR,
        [lx]: r.CONSTANT_ALPHA,
        [cx]: r.ONE_MINUS_CONSTANT_ALPHA
    };
    function zt(S, F, Y, Z, et, Tt, Ht, Te, xe, ne) {
        if (S === ps) {
            m === !0 && (ut(r.BLEND), m = !1);
            return
        }
        if (m === !1 && (ft(r.BLEND), m = !0), S !== Y0) {
            if (S !== _ || ne !== R) {
                if ((g !== dr || v !== dr) && (r.blendEquation(r.FUNC_ADD), g = dr, v = dr), ne)
                    switch (S) {
                    case uo:
                        r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Yh:
                        r.blendFunc(r.ONE, r.ONE);
                        break;
                    case Tf:
                        r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                        break;
                    case Ef:
                        r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", S);
                        break
                    }
                else
                    switch (S) {
                    case uo:
                        r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Yh:
                        r.blendFunc(r.SRC_ALPHA, r.ONE);
                        break;
                    case Tf:
                        r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                        break;
                    case Ef:
                        r.blendFunc(r.ZERO, r.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", S);
                        break
                    }
                p = null,
                x = null,
                y = null,
                C = null,
                A.set(0, 0, 0),
                T = 0,
                _ = S,
                R = ne
            }
            return
        }
        et = et || F,
        Tt = Tt || Y,
        Ht = Ht || Z,
        (F !== g || et !== v) && (r.blendEquationSeparate(Jt[F], Jt[et]), g = F, v = et),
        (Y !== p || Z !== x || Tt !== y || Ht !== C) && (r.blendFuncSeparate(N[Y], N[Z], N[Tt], N[Ht]), p = Y, x = Z, y = Tt, C = Ht),
        (Te.equals(A) === !1 || xe !== T) && (r.blendColor(Te.r, Te.g, Te.b, xe), A.copy(Te), T = xe),
        _ = S,
        R = !1
    }
    function Bt(S, F) {
        S.side === wi ? ut(r.CULL_FACE) : ft(r.CULL_FACE);
        let Y = S.side === kn;
        F && (Y = !Y),
        jt(Y),
        S.blending === uo && S.transparent === !1 ? zt(ps) : zt(S.blending, S.blendEquation, S.blendSrc, S.blendDst, S.blendEquationAlpha, S.blendSrcAlpha, S.blendDstAlpha, S.blendColor, S.blendAlpha, S.premultipliedAlpha),
        s.setFunc(S.depthFunc),
        s.setTest(S.depthTest),
        s.setMask(S.depthWrite),
        i.setMask(S.colorWrite);
        const Z = S.stencilWrite;
        o.setTest(Z),
        Z && (o.setMask(S.stencilWriteMask), o.setFunc(S.stencilFunc, S.stencilRef, S.stencilFuncMask), o.setOp(S.stencilFail, S.stencilZFail, S.stencilZPass)),
        Lt(S.polygonOffset, S.polygonOffsetFactor, S.polygonOffsetUnits),
        S.alphaToCoverage === !0 ? ft(r.SAMPLE_ALPHA_TO_COVERAGE) : ut(r.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function jt(S) {
        E !== S && (S ? r.frontFace(r.CW) : r.frontFace(r.CCW), E = S)
    }
    function yt(S) {
        S !== G0 ? (ft(r.CULL_FACE), S !== M && (S === Sf ? r.cullFace(r.BACK) : S === W0 ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : ut(r.CULL_FACE),
        M = S
    }
    function q(S) {
        S !== D && (j && r.lineWidth(S), D = S)
    }
    function Lt(S, F, Y) {
        S ? (ft(r.POLYGON_OFFSET_FILL), (I !== F || k !== Y) && (r.polygonOffset(F, Y), I = F, k = Y)) : ut(r.POLYGON_OFFSET_FILL)
    }
    function kt(S) {
        S ? ft(r.SCISSOR_TEST) : ut(r.SCISSOR_TEST)
    }
    function L(S) {
        S === void 0 && (S = r.TEXTURE0 + $ - 1),
        V !== S && (r.activeTexture(S), V = S)
    }
    function b(S, F, Y) {
        Y === void 0 && (V === null ? Y = r.TEXTURE0 + $ - 1 : Y = V);
        let Z = nt[Y];
        Z === void 0 && (Z = {
            type: void 0,
            texture: void 0
        }, nt[Y] = Z),
        (Z.type !== S || Z.texture !== F) && (V !== Y && (r.activeTexture(Y), V = Y), r.bindTexture(S, F || it[S]), Z.type = S, Z.texture = F)
    }
    function K() {
        const S = nt[V];
        S !== void 0 && S.type !== void 0 && (r.bindTexture(S.type, null), S.type = void 0, S.texture = void 0)
    }
    function st() {
        try {
            r.compressedTexImage2D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function rt() {
        try {
            r.compressedTexImage3D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function Q() {
        try {
            r.texSubImage2D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function At() {
        try {
            r.texSubImage3D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function at() {
        try {
            r.compressedTexSubImage2D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function dt() {
        try {
            r.compressedTexSubImage3D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function Ot() {
        try {
            r.texStorage2D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function lt() {
        try {
            r.texStorage3D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function xt() {
        try {
            r.texImage2D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function It() {
        try {
            r.texImage3D.apply(r, arguments)
        } catch (S) {
            console.error("THREE.WebGLState:", S)
        }
    }
    function Xt(S) {
        Ut.equals(S) === !1 && (r.scissor(S.x, S.y, S.z, S.w), Ut.copy(S))
    }
    function vt(S) {
        Zt.equals(S) === !1 && (r.viewport(S.x, S.y, S.z, S.w), Zt.copy(S))
    }
    function Wt(S, F) {
        let Y = l.get(F);
        Y === void 0 && (Y = new WeakMap, l.set(F, Y));
        let Z = Y.get(S);
        Z === void 0 && (Z = r.getUniformBlockIndex(F, S.name), Y.set(S, Z))
    }
    function Yt(S, F) {
        const Z = l.get(F).get(S);
        a.get(F) !== Z && (r.uniformBlockBinding(F, Z, S.__bindingPointIndex), a.set(F, Z))
    }
    function de() {
        r.disable(r.BLEND),
        r.disable(r.CULL_FACE),
        r.disable(r.DEPTH_TEST),
        r.disable(r.POLYGON_OFFSET_FILL),
        r.disable(r.SCISSOR_TEST),
        r.disable(r.STENCIL_TEST),
        r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
        r.blendEquation(r.FUNC_ADD),
        r.blendFunc(r.ONE, r.ZERO),
        r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
        r.blendColor(0, 0, 0, 0),
        r.colorMask(!0, !0, !0, !0),
        r.clearColor(0, 0, 0, 0),
        r.depthMask(!0),
        r.depthFunc(r.LESS),
        r.clearDepth(1),
        r.stencilMask(4294967295),
        r.stencilFunc(r.ALWAYS, 0, 4294967295),
        r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
        r.clearStencil(0),
        r.cullFace(r.BACK),
        r.frontFace(r.CCW),
        r.polygonOffset(0, 0),
        r.activeTexture(r.TEXTURE0),
        r.bindFramebuffer(r.FRAMEBUFFER, null),
        r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        r.bindFramebuffer(r.READ_FRAMEBUFFER, null),
        r.useProgram(null),
        r.lineWidth(1),
        r.scissor(0, 0, r.canvas.width, r.canvas.height),
        r.viewport(0, 0, r.canvas.width, r.canvas.height),
        c = {},
        V = null,
        nt = {},
        h = {},
        u = new WeakMap,
        d = [],
        f = null,
        m = !1,
        _ = null,
        g = null,
        p = null,
        x = null,
        v = null,
        y = null,
        C = null,
        A = new Gt(0, 0, 0),
        T = 0,
        R = !1,
        E = null,
        M = null,
        D = null,
        I = null,
        k = null,
        Ut.set(0, 0, r.canvas.width, r.canvas.height),
        Zt.set(0, 0, r.canvas.width, r.canvas.height),
        i.reset(),
        s.reset(),
        o.reset()
    }
    return {
        buffers: {
            color: i,
            depth: s,
            stencil: o
        },
        enable: ft,
        disable: ut,
        bindFramebuffer: Pt,
        drawBuffers: Nt,
        useProgram: Kt,
        setBlending: zt,
        setMaterial: Bt,
        setFlipSided: jt,
        setCullFace: yt,
        setLineWidth: q,
        setPolygonOffset: Lt,
        setScissorTest: kt,
        activeTexture: L,
        bindTexture: b,
        unbindTexture: K,
        compressedTexImage2D: st,
        compressedTexImage3D: rt,
        texImage2D: xt,
        texImage3D: It,
        updateUBOMapping: Wt,
        uniformBlockBinding: Yt,
        texStorage2D: Ot,
        texStorage3D: lt,
        texSubImage2D: Q,
        texSubImage3D: At,
        compressedTexSubImage2D: at,
        compressedTexSubImage3D: dt,
        scissor: Xt,
        viewport: vt,
        reset: de
    }
}
function yp(r, t, e, n) {
    const i = JT(n);
    switch (e) {
    case Jm:
        return r * t;
    case tg:
        return r * t;
    case eg:
        return r * t * 2;
    case gd:
        return r * t / i.components * i.byteLength;
    case _d:
        return r * t / i.components * i.byteLength;
    case ng:
        return r * t * 2 / i.components * i.byteLength;
    case xd:
        return r * t * 2 / i.components * i.byteLength;
    case Qm:
        return r * t * 3 / i.components * i.byteLength;
    case fi:
        return r * t * 4 / i.components * i.byteLength;
    case vd:
        return r * t * 4 / i.components * i.byteLength;
    case Yl:
    case $l:
        return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case ql:
    case Kl:
        return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case Jh:
    case tu:
        return Math.max(r, 16) * Math.max(t, 8) / 4;
    case Zh:
    case Qh:
        return Math.max(r, 8) * Math.max(t, 8) / 2;
    case eu:
    case nu:
        return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case iu:
        return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case su:
        return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case ru:
        return Math.floor((r + 4) / 5) * Math.floor((t + 3) / 4) * 16;
    case ou:
        return Math.floor((r + 4) / 5) * Math.floor((t + 4) / 5) * 16;
    case au:
        return Math.floor((r + 5) / 6) * Math.floor((t + 4) / 5) * 16;
    case lu:
        return Math.floor((r + 5) / 6) * Math.floor((t + 5) / 6) * 16;
    case cu:
        return Math.floor((r + 7) / 8) * Math.floor((t + 4) / 5) * 16;
    case hu:
        return Math.floor((r + 7) / 8) * Math.floor((t + 5) / 6) * 16;
    case uu:
        return Math.floor((r + 7) / 8) * Math.floor((t + 7) / 8) * 16;
    case du:
        return Math.floor((r + 9) / 10) * Math.floor((t + 4) / 5) * 16;
    case fu:
        return Math.floor((r + 9) / 10) * Math.floor((t + 5) / 6) * 16;
    case pu:
        return Math.floor((r + 9) / 10) * Math.floor((t + 7) / 8) * 16;
    case mu:
        return Math.floor((r + 9) / 10) * Math.floor((t + 9) / 10) * 16;
    case gu:
        return Math.floor((r + 11) / 12) * Math.floor((t + 9) / 10) * 16;
    case _u:
        return Math.floor((r + 11) / 12) * Math.floor((t + 11) / 12) * 16;
    case jl:
    case xu:
    case vu:
        return Math.ceil(r / 4) * Math.ceil(t / 4) * 16;
    case ig:
    case yu:
        return Math.ceil(r / 4) * Math.ceil(t / 4) * 8;
    case Mu:
    case Su:
        return Math.ceil(r / 4) * Math.ceil(t / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${e} format.`)
}
function JT(r) {
    switch (r) {
    case xs:
    case Km:
        return {
            byteLength: 1,
            components: 1
        };
    case La:
    case jm:
    case ms:
        return {
            byteLength: 2,
            components: 1
        };
    case pd:
    case md:
        return {
            byteLength: 2,
            components: 4
        };
    case Tr:
    case fd:
    case Ci:
        return {
            byteLength: 4,
            components: 1
        };
    case Zm:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${r}.`)
}
function QT(r, t, e, n, i, s, o) {
    const a = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
        l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
        c = new St,
        h = new WeakMap;
    let u;
    const d = new WeakMap;
    let f = !1;
    try {
        f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
    } catch {}
    function m(L, b) {
        return f ? new OffscreenCanvas(L, b) : Ia("canvas")
    }
    function _(L, b, K) {
        let st = 1;
        const rt = kt(L);
        if ((rt.width > K || rt.height > K) && (st = K / Math.max(rt.width, rt.height)), st < 1)
            if (typeof HTMLImageElement < "u" && L instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && L instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && L instanceof ImageBitmap || typeof VideoFrame < "u" && L instanceof VideoFrame) {
                const Q = Math.floor(st * rt.width),
                    At = Math.floor(st * rt.height);
                u === void 0 && (u = m(Q, At));
                const at = b ? m(Q, At) : u;
                return at.width = Q, at.height = At, at.getContext("2d").drawImage(L, 0, 0, Q, At), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + rt.width + "x" + rt.height + ") to (" + Q + "x" + At + ")."), at
            } else
                return "data" in L && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + rt.width + "x" + rt.height + ")."), L;
        return L
    }
    function g(L) {
        return L.generateMipmaps && L.minFilter !== Fn && L.minFilter !== ti
    }
    function p(L) {
        r.generateMipmap(L)
    }
    function x(L, b, K, st, rt=!1) {
        if (L !== null) {
            if (r[L] !== void 0)
                return r[L];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + L + "'")
        }
        let Q = b;
        if (b === r.RED && (K === r.FLOAT && (Q = r.R32F), K === r.HALF_FLOAT && (Q = r.R16F), K === r.UNSIGNED_BYTE && (Q = r.R8)), b === r.RED_INTEGER && (K === r.UNSIGNED_BYTE && (Q = r.R8UI), K === r.UNSIGNED_SHORT && (Q = r.R16UI), K === r.UNSIGNED_INT && (Q = r.R32UI), K === r.BYTE && (Q = r.R8I), K === r.SHORT && (Q = r.R16I), K === r.INT && (Q = r.R32I)), b === r.RG && (K === r.FLOAT && (Q = r.RG32F), K === r.HALF_FLOAT && (Q = r.RG16F), K === r.UNSIGNED_BYTE && (Q = r.RG8)), b === r.RG_INTEGER && (K === r.UNSIGNED_BYTE && (Q = r.RG8UI), K === r.UNSIGNED_SHORT && (Q = r.RG16UI), K === r.UNSIGNED_INT && (Q = r.RG32UI), K === r.BYTE && (Q = r.RG8I), K === r.SHORT && (Q = r.RG16I), K === r.INT && (Q = r.RG32I)), b === r.RGB && K === r.UNSIGNED_INT_5_9_9_9_REV && (Q = r.RGB9_E5), b === r.RGBA) {
            const At = rt ? cc : me.getTransfer(st);
            K === r.FLOAT && (Q = r.RGBA32F),
            K === r.HALF_FLOAT && (Q = r.RGBA16F),
            K === r.UNSIGNED_BYTE && (Q = At === Ne ? r.SRGB8_ALPHA8 : r.RGBA8),
            K === r.UNSIGNED_SHORT_4_4_4_4 && (Q = r.RGBA4),
            K === r.UNSIGNED_SHORT_5_5_5_1 && (Q = r.RGB5_A1)
        }
        return (Q === r.R16F || Q === r.R32F || Q === r.RG16F || Q === r.RG32F || Q === r.RGBA16F || Q === r.RGBA32F) && t.get("EXT_color_buffer_float"), Q
    }
    function v(L, b) {
        let K;
        return L ? b === null || b === Tr || b === wo ? K = r.DEPTH24_STENCIL8 : b === Ci ? K = r.DEPTH32F_STENCIL8 : b === La && (K = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : b === null || b === Tr || b === wo ? K = r.DEPTH_COMPONENT24 : b === Ci ? K = r.DEPTH_COMPONENT32F : b === La && (K = r.DEPTH_COMPONENT16), K
    }
    function y(L, b) {
        return g(L) === !0 || L.isFramebufferTexture && L.minFilter !== Fn && L.minFilter !== ti ? Math.log2(Math.max(b.width, b.height)) + 1 : L.mipmaps !== void 0 && L.mipmaps.length > 0 ? L.mipmaps.length : L.isCompressedTexture && Array.isArray(L.image) ? b.mipmaps.length : 1
    }
    function C(L) {
        const b = L.target;
        b.removeEventListener("dispose", C),
        T(b),
        b.isVideoTexture && h.delete(b)
    }
    function A(L) {
        const b = L.target;
        b.removeEventListener("dispose", A),
        E(b)
    }
    function T(L) {
        const b = n.get(L);
        if (b.__webglInit === void 0)
            return;
        const K = L.source,
            st = d.get(K);
        if (st) {
            const rt = st[b.__cacheKey];
            rt.usedTimes--,
            rt.usedTimes === 0 && R(L),
            Object.keys(st).length === 0 && d.delete(K)
        }
        n.remove(L)
    }
    function R(L) {
        const b = n.get(L);
        r.deleteTexture(b.__webglTexture);
        const K = L.source,
            st = d.get(K);
        delete st[b.__cacheKey],
        o.memory.textures--
    }
    function E(L) {
        const b = n.get(L);
        if (L.depthTexture && L.depthTexture.dispose(), L.isWebGLCubeRenderTarget)
            for (let st = 0; st < 6; st++) {
                if (Array.isArray(b.__webglFramebuffer[st]))
                    for (let rt = 0; rt < b.__webglFramebuffer[st].length; rt++)
                        r.deleteFramebuffer(b.__webglFramebuffer[st][rt]);
                else
                    r.deleteFramebuffer(b.__webglFramebuffer[st]);
                b.__webglDepthbuffer && r.deleteRenderbuffer(b.__webglDepthbuffer[st])
            }
        else {
            if (Array.isArray(b.__webglFramebuffer))
                for (let st = 0; st < b.__webglFramebuffer.length; st++)
                    r.deleteFramebuffer(b.__webglFramebuffer[st]);
            else
                r.deleteFramebuffer(b.__webglFramebuffer);
            if (b.__webglDepthbuffer && r.deleteRenderbuffer(b.__webglDepthbuffer), b.__webglMultisampledFramebuffer && r.deleteFramebuffer(b.__webglMultisampledFramebuffer), b.__webglColorRenderbuffer)
                for (let st = 0; st < b.__webglColorRenderbuffer.length; st++)
                    b.__webglColorRenderbuffer[st] && r.deleteRenderbuffer(b.__webglColorRenderbuffer[st]);
            b.__webglDepthRenderbuffer && r.deleteRenderbuffer(b.__webglDepthRenderbuffer)
        }
        const K = L.textures;
        for (let st = 0, rt = K.length; st < rt; st++) {
            const Q = n.get(K[st]);
            Q.__webglTexture && (r.deleteTexture(Q.__webglTexture), o.memory.textures--),
            n.remove(K[st])
        }
        n.remove(L)
    }
    let M = 0;
    function D() {
        M = 0
    }
    function I() {
        const L = M;
        return L >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + L + " texture units while this GPU supports only " + i.maxTextures), M += 1, L
    }
    function k(L) {
        const b = [];
        return b.push(L.wrapS), b.push(L.wrapT), b.push(L.wrapR || 0), b.push(L.magFilter), b.push(L.minFilter), b.push(L.anisotropy), b.push(L.internalFormat), b.push(L.format), b.push(L.type), b.push(L.generateMipmaps), b.push(L.premultiplyAlpha), b.push(L.flipY), b.push(L.unpackAlignment), b.push(L.colorSpace), b.join()
    }
    function $(L, b) {
        const K = n.get(L);
        if (L.isVideoTexture && q(L), L.isRenderTargetTexture === !1 && L.version > 0 && K.__version !== L.version) {
            const st = L.image;
            if (st === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (st.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Zt(K, L, b);
                return
            }
        }
        e.bindTexture(r.TEXTURE_2D, K.__webglTexture, r.TEXTURE0 + b)
    }
    function j(L, b) {
        const K = n.get(L);
        if (L.version > 0 && K.__version !== L.version) {
            Zt(K, L, b);
            return
        }
        e.bindTexture(r.TEXTURE_2D_ARRAY, K.__webglTexture, r.TEXTURE0 + b)
    }
    function G(L, b) {
        const K = n.get(L);
        if (L.version > 0 && K.__version !== L.version) {
            Zt(K, L, b);
            return
        }
        e.bindTexture(r.TEXTURE_3D, K.__webglTexture, r.TEXTURE0 + b)
    }
    function H(L, b) {
        const K = n.get(L);
        if (L.version > 0 && K.__version !== L.version) {
            J(K, L, b);
            return
        }
        e.bindTexture(r.TEXTURE_CUBE_MAP, K.__webglTexture, r.TEXTURE0 + b)
    }
    const V = {
            [bo]: r.REPEAT,
            [Os]: r.CLAMP_TO_EDGE,
            [lc]: r.MIRRORED_REPEAT
        },
        nt = {
            [Fn]: r.NEAREST,
            [qm]: r.NEAREST_MIPMAP_NEAREST,
            [ra]: r.NEAREST_MIPMAP_LINEAR,
            [ti]: r.LINEAR,
            [Xl]: r.LINEAR_MIPMAP_NEAREST,
            [hs]: r.LINEAR_MIPMAP_LINEAR
        },
        P = {
            [Dx]: r.NEVER,
            [zx]: r.ALWAYS,
            [Nx]: r.LESS,
            [rg]: r.LEQUAL,
            [Ix]: r.EQUAL,
            [Ox]: r.GEQUAL,
            [Fx]: r.GREATER,
            [Ux]: r.NOTEQUAL
        };
    function ct(L, b) {
        if (b.type === Ci && t.has("OES_texture_float_linear") === !1 && (b.magFilter === ti || b.magFilter === Xl || b.magFilter === ra || b.magFilter === hs || b.minFilter === ti || b.minFilter === Xl || b.minFilter === ra || b.minFilter === hs) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(L, r.TEXTURE_WRAP_S, V[b.wrapS]), r.texParameteri(L, r.TEXTURE_WRAP_T, V[b.wrapT]), (L === r.TEXTURE_3D || L === r.TEXTURE_2D_ARRAY) && r.texParameteri(L, r.TEXTURE_WRAP_R, V[b.wrapR]), r.texParameteri(L, r.TEXTURE_MAG_FILTER, nt[b.magFilter]), r.texParameteri(L, r.TEXTURE_MIN_FILTER, nt[b.minFilter]), b.compareFunction && (r.texParameteri(L, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(L, r.TEXTURE_COMPARE_FUNC, P[b.compareFunction])), t.has("EXT_texture_filter_anisotropic") === !0) {
            if (b.magFilter === Fn || b.minFilter !== ra && b.minFilter !== hs || b.type === Ci && t.has("OES_texture_float_linear") === !1)
                return;
            if (b.anisotropy > 1 || n.get(b).__currentAnisotropy) {
                const K = t.get("EXT_texture_filter_anisotropic");
                r.texParameterf(L, K.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, i.getMaxAnisotropy())),
                n.get(b).__currentAnisotropy = b.anisotropy
            }
        }
    }
    function Ut(L, b) {
        let K = !1;
        L.__webglInit === void 0 && (L.__webglInit = !0, b.addEventListener("dispose", C));
        const st = b.source;
        let rt = d.get(st);
        rt === void 0 && (rt = {}, d.set(st, rt));
        const Q = k(b);
        if (Q !== L.__cacheKey) {
            rt[Q] === void 0 && (rt[Q] = {
                texture: r.createTexture(),
                usedTimes: 0
            }, o.memory.textures++, K = !0),
            rt[Q].usedTimes++;
            const At = rt[L.__cacheKey];
            At !== void 0 && (rt[L.__cacheKey].usedTimes--, At.usedTimes === 0 && R(b)),
            L.__cacheKey = Q,
            L.__webglTexture = rt[Q].texture
        }
        return K
    }
    function Zt(L, b, K) {
        let st = r.TEXTURE_2D;
        (b.isDataArrayTexture || b.isCompressedArrayTexture) && (st = r.TEXTURE_2D_ARRAY),
        b.isData3DTexture && (st = r.TEXTURE_3D);
        const rt = Ut(L, b),
            Q = b.source;
        e.bindTexture(st, L.__webglTexture, r.TEXTURE0 + K);
        const At = n.get(Q);
        if (Q.version !== At.__version || rt === !0) {
            e.activeTexture(r.TEXTURE0 + K);
            const at = me.getPrimaries(me.workingColorSpace),
                dt = b.colorSpace === Us ? null : me.getPrimaries(b.colorSpace),
                Ot = b.colorSpace === Us || at === dt ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, b.flipY),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha),
            r.pixelStorei(r.UNPACK_ALIGNMENT, b.unpackAlignment),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ot);
            let lt = _(b.image, !1, i.maxTextureSize);
            lt = Lt(b, lt);
            const xt = s.convert(b.format, b.colorSpace),
                It = s.convert(b.type);
            let Xt = x(b.internalFormat, xt, It, b.colorSpace, b.isVideoTexture);
            ct(st, b);
            let vt;
            const Wt = b.mipmaps,
                Yt = b.isVideoTexture !== !0,
                de = At.__version === void 0 || rt === !0,
                S = Q.dataReady,
                F = y(b, lt);
            if (b.isDepthTexture)
                Xt = v(b.format === Ao, b.type),
                de && (Yt ? e.texStorage2D(r.TEXTURE_2D, 1, Xt, lt.width, lt.height) : e.texImage2D(r.TEXTURE_2D, 0, Xt, lt.width, lt.height, 0, xt, It, null));
            else if (b.isDataTexture)
                if (Wt.length > 0) {
                    Yt && de && e.texStorage2D(r.TEXTURE_2D, F, Xt, Wt[0].width, Wt[0].height);
                    for (let Y = 0, Z = Wt.length; Y < Z; Y++)
                        vt = Wt[Y],
                        Yt ? S && e.texSubImage2D(r.TEXTURE_2D, Y, 0, 0, vt.width, vt.height, xt, It, vt.data) : e.texImage2D(r.TEXTURE_2D, Y, Xt, vt.width, vt.height, 0, xt, It, vt.data);
                    b.generateMipmaps = !1
                } else
                    Yt ? (de && e.texStorage2D(r.TEXTURE_2D, F, Xt, lt.width, lt.height), S && e.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, lt.width, lt.height, xt, It, lt.data)) : e.texImage2D(r.TEXTURE_2D, 0, Xt, lt.width, lt.height, 0, xt, It, lt.data);
            else if (b.isCompressedTexture)
                if (b.isCompressedArrayTexture) {
                    Yt && de && e.texStorage3D(r.TEXTURE_2D_ARRAY, F, Xt, Wt[0].width, Wt[0].height, lt.depth);
                    for (let Y = 0, Z = Wt.length; Y < Z; Y++)
                        if (vt = Wt[Y], b.format !== fi)
                            if (xt !== null)
                                if (Yt) {
                                    if (S)
                                        if (b.layerUpdates.size > 0) {
                                            const et = yp(vt.width, vt.height, b.format, b.type);
                                            for (const Tt of b.layerUpdates) {
                                                const Ht = vt.data.subarray(Tt * et / vt.data.BYTES_PER_ELEMENT, (Tt + 1) * et / vt.data.BYTES_PER_ELEMENT);
                                                e.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, Y, 0, 0, Tt, vt.width, vt.height, 1, xt, Ht, 0, 0)
                                            }
                                            b.clearLayerUpdates()
                                        } else
                                            e.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, Y, 0, 0, 0, vt.width, vt.height, lt.depth, xt, vt.data, 0, 0)
                                } else
                                    e.compressedTexImage3D(r.TEXTURE_2D_ARRAY, Y, Xt, vt.width, vt.height, lt.depth, 0, vt.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            Yt ? S && e.texSubImage3D(r.TEXTURE_2D_ARRAY, Y, 0, 0, 0, vt.width, vt.height, lt.depth, xt, It, vt.data) : e.texImage3D(r.TEXTURE_2D_ARRAY, Y, Xt, vt.width, vt.height, lt.depth, 0, xt, It, vt.data)
                } else {
                    Yt && de && e.texStorage2D(r.TEXTURE_2D, F, Xt, Wt[0].width, Wt[0].height);
                    for (let Y = 0, Z = Wt.length; Y < Z; Y++)
                        vt = Wt[Y],
                        b.format !== fi ? xt !== null ? Yt ? S && e.compressedTexSubImage2D(r.TEXTURE_2D, Y, 0, 0, vt.width, vt.height, xt, vt.data) : e.compressedTexImage2D(r.TEXTURE_2D, Y, Xt, vt.width, vt.height, 0, vt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Yt ? S && e.texSubImage2D(r.TEXTURE_2D, Y, 0, 0, vt.width, vt.height, xt, It, vt.data) : e.texImage2D(r.TEXTURE_2D, Y, Xt, vt.width, vt.height, 0, xt, It, vt.data)
                }
            else if (b.isDataArrayTexture)
                if (Yt) {
                    if (de && e.texStorage3D(r.TEXTURE_2D_ARRAY, F, Xt, lt.width, lt.height, lt.depth), S)
                        if (b.layerUpdates.size > 0) {
                            const Y = yp(lt.width, lt.height, b.format, b.type);
                            for (const Z of b.layerUpdates) {
                                const et = lt.data.subarray(Z * Y / lt.data.BYTES_PER_ELEMENT, (Z + 1) * Y / lt.data.BYTES_PER_ELEMENT);
                                e.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, Z, lt.width, lt.height, 1, xt, It, et)
                            }
                            b.clearLayerUpdates()
                        } else
                            e.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, lt.width, lt.height, lt.depth, xt, It, lt.data)
                } else
                    e.texImage3D(r.TEXTURE_2D_ARRAY, 0, Xt, lt.width, lt.height, lt.depth, 0, xt, It, lt.data);
            else if (b.isData3DTexture)
                Yt ? (de && e.texStorage3D(r.TEXTURE_3D, F, Xt, lt.width, lt.height, lt.depth), S && e.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, lt.width, lt.height, lt.depth, xt, It, lt.data)) : e.texImage3D(r.TEXTURE_3D, 0, Xt, lt.width, lt.height, lt.depth, 0, xt, It, lt.data);
            else if (b.isFramebufferTexture) {
                if (de)
                    if (Yt)
                        e.texStorage2D(r.TEXTURE_2D, F, Xt, lt.width, lt.height);
                    else {
                        let Y = lt.width,
                            Z = lt.height;
                        for (let et = 0; et < F; et++)
                            e.texImage2D(r.TEXTURE_2D, et, Xt, Y, Z, 0, xt, It, null),
                            Y >>= 1,
                            Z >>= 1
                    }
            } else if (Wt.length > 0) {
                if (Yt && de) {
                    const Y = kt(Wt[0]);
                    e.texStorage2D(r.TEXTURE_2D, F, Xt, Y.width, Y.height)
                }
                for (let Y = 0, Z = Wt.length; Y < Z; Y++)
                    vt = Wt[Y],
                    Yt ? S && e.texSubImage2D(r.TEXTURE_2D, Y, 0, 0, xt, It, vt) : e.texImage2D(r.TEXTURE_2D, Y, Xt, xt, It, vt);
                b.generateMipmaps = !1
            } else if (Yt) {
                if (de) {
                    const Y = kt(lt);
                    e.texStorage2D(r.TEXTURE_2D, F, Xt, Y.width, Y.height)
                }
                S && e.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, xt, It, lt)
            } else
                e.texImage2D(r.TEXTURE_2D, 0, Xt, xt, It, lt);
            g(b) && p(st),
            At.__version = Q.version,
            b.onUpdate && b.onUpdate(b)
        }
        L.__version = b.version
    }
    function J(L, b, K) {
        if (b.image.length !== 6)
            return;
        const st = Ut(L, b),
            rt = b.source;
        e.bindTexture(r.TEXTURE_CUBE_MAP, L.__webglTexture, r.TEXTURE0 + K);
        const Q = n.get(rt);
        if (rt.version !== Q.__version || st === !0) {
            e.activeTexture(r.TEXTURE0 + K);
            const At = me.getPrimaries(me.workingColorSpace),
                at = b.colorSpace === Us ? null : me.getPrimaries(b.colorSpace),
                dt = b.colorSpace === Us || At === at ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, b.flipY),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha),
            r.pixelStorei(r.UNPACK_ALIGNMENT, b.unpackAlignment),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, dt);
            const Ot = b.isCompressedTexture || b.image[0].isCompressedTexture,
                lt = b.image[0] && b.image[0].isDataTexture,
                xt = [];
            for (let Z = 0; Z < 6; Z++)
                !Ot && !lt ? xt[Z] = _(b.image[Z], !0, i.maxCubemapSize) : xt[Z] = lt ? b.image[Z].image : b.image[Z],
                xt[Z] = Lt(b, xt[Z]);
            const It = xt[0],
                Xt = s.convert(b.format, b.colorSpace),
                vt = s.convert(b.type),
                Wt = x(b.internalFormat, Xt, vt, b.colorSpace),
                Yt = b.isVideoTexture !== !0,
                de = Q.__version === void 0 || st === !0,
                S = rt.dataReady;
            let F = y(b, It);
            ct(r.TEXTURE_CUBE_MAP, b);
            let Y;
            if (Ot) {
                Yt && de && e.texStorage2D(r.TEXTURE_CUBE_MAP, F, Wt, It.width, It.height);
                for (let Z = 0; Z < 6; Z++) {
                    Y = xt[Z].mipmaps;
                    for (let et = 0; et < Y.length; et++) {
                        const Tt = Y[et];
                        b.format !== fi ? Xt !== null ? Yt ? S && e.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, et, 0, 0, Tt.width, Tt.height, Xt, Tt.data) : e.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, et, Wt, Tt.width, Tt.height, 0, Tt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Yt ? S && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, et, 0, 0, Tt.width, Tt.height, Xt, vt, Tt.data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, et, Wt, Tt.width, Tt.height, 0, Xt, vt, Tt.data)
                    }
                }
            } else {
                if (Y = b.mipmaps, Yt && de) {
                    Y.length > 0 && F++;
                    const Z = kt(xt[0]);
                    e.texStorage2D(r.TEXTURE_CUBE_MAP, F, Wt, Z.width, Z.height)
                }
                for (let Z = 0; Z < 6; Z++)
                    if (lt) {
                        Yt ? S && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, 0, 0, xt[Z].width, xt[Z].height, Xt, vt, xt[Z].data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, Wt, xt[Z].width, xt[Z].height, 0, Xt, vt, xt[Z].data);
                        for (let et = 0; et < Y.length; et++) {
                            const Ht = Y[et].image[Z].image;
                            Yt ? S && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, et + 1, 0, 0, Ht.width, Ht.height, Xt, vt, Ht.data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, et + 1, Wt, Ht.width, Ht.height, 0, Xt, vt, Ht.data)
                        }
                    } else {
                        Yt ? S && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, 0, 0, Xt, vt, xt[Z]) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, Wt, Xt, vt, xt[Z]);
                        for (let et = 0; et < Y.length; et++) {
                            const Tt = Y[et];
                            Yt ? S && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, et + 1, 0, 0, Xt, vt, Tt.image[Z]) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, et + 1, Wt, Xt, vt, Tt.image[Z])
                        }
                    }
            }
            g(b) && p(r.TEXTURE_CUBE_MAP),
            Q.__version = rt.version,
            b.onUpdate && b.onUpdate(b)
        }
        L.__version = b.version
    }
    function it(L, b, K, st, rt, Q) {
        const At = s.convert(K.format, K.colorSpace),
            at = s.convert(K.type),
            dt = x(K.internalFormat, At, at, K.colorSpace);
        if (!n.get(b).__hasExternalTextures) {
            const lt = Math.max(1, b.width >> Q),
                xt = Math.max(1, b.height >> Q);
            rt === r.TEXTURE_3D || rt === r.TEXTURE_2D_ARRAY ? e.texImage3D(rt, Q, dt, lt, xt, b.depth, 0, At, at, null) : e.texImage2D(rt, Q, dt, lt, xt, 0, At, at, null)
        }
        e.bindFramebuffer(r.FRAMEBUFFER, L),
        yt(b) ? a.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, st, rt, n.get(K).__webglTexture, 0, jt(b)) : (rt === r.TEXTURE_2D || rt >= r.TEXTURE_CUBE_MAP_POSITIVE_X && rt <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, st, rt, n.get(K).__webglTexture, Q),
        e.bindFramebuffer(r.FRAMEBUFFER, null)
    }
    function ft(L, b, K) {
        if (r.bindRenderbuffer(r.RENDERBUFFER, L), b.depthBuffer) {
            const st = b.depthTexture,
                rt = st && st.isDepthTexture ? st.type : null,
                Q = v(b.stencilBuffer, rt),
                At = b.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                at = jt(b);
            yt(b) ? a.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, at, Q, b.width, b.height) : K ? r.renderbufferStorageMultisample(r.RENDERBUFFER, at, Q, b.width, b.height) : r.renderbufferStorage(r.RENDERBUFFER, Q, b.width, b.height),
            r.framebufferRenderbuffer(r.FRAMEBUFFER, At, r.RENDERBUFFER, L)
        } else {
            const st = b.textures;
            for (let rt = 0; rt < st.length; rt++) {
                const Q = st[rt],
                    At = s.convert(Q.format, Q.colorSpace),
                    at = s.convert(Q.type),
                    dt = x(Q.internalFormat, At, at, Q.colorSpace),
                    Ot = jt(b);
                K && yt(b) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Ot, dt, b.width, b.height) : yt(b) ? a.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Ot, dt, b.width, b.height) : r.renderbufferStorage(r.RENDERBUFFER, dt, b.width, b.height)
            }
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null)
    }
    function ut(L, b) {
        if (b && b.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (e.bindFramebuffer(r.FRAMEBUFFER, L), !(b.depthTexture && b.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!n.get(b.depthTexture).__webglTexture || b.depthTexture.image.width !== b.width || b.depthTexture.image.height !== b.height) && (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0),
        $(b.depthTexture, 0);
        const st = n.get(b.depthTexture).__webglTexture,
            rt = jt(b);
        if (b.depthTexture.format === fo)
            yt(b) ? a.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, st, 0, rt) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, st, 0);
        else if (b.depthTexture.format === Ao)
            yt(b) ? a.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, st, 0, rt) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, st, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Pt(L) {
        const b = n.get(L),
            K = L.isWebGLCubeRenderTarget === !0;
        if (L.depthTexture && !b.__autoAllocateDepthBuffer) {
            if (K)
                throw new Error("target.depthTexture not supported in Cube render targets");
            ut(b.__webglFramebuffer, L)
        } else if (K) {
            b.__webglDepthbuffer = [];
            for (let st = 0; st < 6; st++)
                e.bindFramebuffer(r.FRAMEBUFFER, b.__webglFramebuffer[st]),
                b.__webglDepthbuffer[st] = r.createRenderbuffer(),
                ft(b.__webglDepthbuffer[st], L, !1)
        } else
            e.bindFramebuffer(r.FRAMEBUFFER, b.__webglFramebuffer),
            b.__webglDepthbuffer = r.createRenderbuffer(),
            ft(b.__webglDepthbuffer, L, !1);
        e.bindFramebuffer(r.FRAMEBUFFER, null)
    }
    function Nt(L, b, K) {
        const st = n.get(L);
        b !== void 0 && it(st.__webglFramebuffer, L, L.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0),
        K !== void 0 && Pt(L)
    }
    function Kt(L) {
        const b = L.texture,
            K = n.get(L),
            st = n.get(b);
        L.addEventListener("dispose", A);
        const rt = L.textures,
            Q = L.isWebGLCubeRenderTarget === !0,
            At = rt.length > 1;
        if (At || (st.__webglTexture === void 0 && (st.__webglTexture = r.createTexture()), st.__version = b.version, o.memory.textures++), Q) {
            K.__webglFramebuffer = [];
            for (let at = 0; at < 6; at++)
                if (b.mipmaps && b.mipmaps.length > 0) {
                    K.__webglFramebuffer[at] = [];
                    for (let dt = 0; dt < b.mipmaps.length; dt++)
                        K.__webglFramebuffer[at][dt] = r.createFramebuffer()
                } else
                    K.__webglFramebuffer[at] = r.createFramebuffer()
        } else {
            if (b.mipmaps && b.mipmaps.length > 0) {
                K.__webglFramebuffer = [];
                for (let at = 0; at < b.mipmaps.length; at++)
                    K.__webglFramebuffer[at] = r.createFramebuffer()
            } else
                K.__webglFramebuffer = r.createFramebuffer();
            if (At)
                for (let at = 0, dt = rt.length; at < dt; at++) {
                    const Ot = n.get(rt[at]);
                    Ot.__webglTexture === void 0 && (Ot.__webglTexture = r.createTexture(), o.memory.textures++)
                }
            if (L.samples > 0 && yt(L) === !1) {
                K.__webglMultisampledFramebuffer = r.createFramebuffer(),
                K.__webglColorRenderbuffer = [],
                e.bindFramebuffer(r.FRAMEBUFFER, K.__webglMultisampledFramebuffer);
                for (let at = 0; at < rt.length; at++) {
                    const dt = rt[at];
                    K.__webglColorRenderbuffer[at] = r.createRenderbuffer(),
                    r.bindRenderbuffer(r.RENDERBUFFER, K.__webglColorRenderbuffer[at]);
                    const Ot = s.convert(dt.format, dt.colorSpace),
                        lt = s.convert(dt.type),
                        xt = x(dt.internalFormat, Ot, lt, dt.colorSpace, L.isXRRenderTarget === !0),
                        It = jt(L);
                    r.renderbufferStorageMultisample(r.RENDERBUFFER, It, xt, L.width, L.height),
                    r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + at, r.RENDERBUFFER, K.__webglColorRenderbuffer[at])
                }
                r.bindRenderbuffer(r.RENDERBUFFER, null),
                L.depthBuffer && (K.__webglDepthRenderbuffer = r.createRenderbuffer(), ft(K.__webglDepthRenderbuffer, L, !0)),
                e.bindFramebuffer(r.FRAMEBUFFER, null)
            }
        }
        if (Q) {
            e.bindTexture(r.TEXTURE_CUBE_MAP, st.__webglTexture),
            ct(r.TEXTURE_CUBE_MAP, b);
            for (let at = 0; at < 6; at++)
                if (b.mipmaps && b.mipmaps.length > 0)
                    for (let dt = 0; dt < b.mipmaps.length; dt++)
                        it(K.__webglFramebuffer[at][dt], L, b, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + at, dt);
                else
                    it(K.__webglFramebuffer[at], L, b, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + at, 0);
            g(b) && p(r.TEXTURE_CUBE_MAP),
            e.unbindTexture()
        } else if (At) {
            for (let at = 0, dt = rt.length; at < dt; at++) {
                const Ot = rt[at],
                    lt = n.get(Ot);
                e.bindTexture(r.TEXTURE_2D, lt.__webglTexture),
                ct(r.TEXTURE_2D, Ot),
                it(K.__webglFramebuffer, L, Ot, r.COLOR_ATTACHMENT0 + at, r.TEXTURE_2D, 0),
                g(Ot) && p(r.TEXTURE_2D)
            }
            e.unbindTexture()
        } else {
            let at = r.TEXTURE_2D;
            if ((L.isWebGL3DRenderTarget || L.isWebGLArrayRenderTarget) && (at = L.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), e.bindTexture(at, st.__webglTexture), ct(at, b), b.mipmaps && b.mipmaps.length > 0)
                for (let dt = 0; dt < b.mipmaps.length; dt++)
                    it(K.__webglFramebuffer[dt], L, b, r.COLOR_ATTACHMENT0, at, dt);
            else
                it(K.__webglFramebuffer, L, b, r.COLOR_ATTACHMENT0, at, 0);
            g(b) && p(at),
            e.unbindTexture()
        }
        L.depthBuffer && Pt(L)
    }
    function Jt(L) {
        const b = L.textures;
        for (let K = 0, st = b.length; K < st; K++) {
            const rt = b[K];
            if (g(rt)) {
                const Q = L.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D,
                    At = n.get(rt).__webglTexture;
                e.bindTexture(Q, At),
                p(Q),
                e.unbindTexture()
            }
        }
    }
    const N = [],
        zt = [];
    function Bt(L) {
        if (L.samples > 0) {
            if (yt(L) === !1) {
                const b = L.textures,
                    K = L.width,
                    st = L.height;
                let rt = r.COLOR_BUFFER_BIT;
                const Q = L.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                    At = n.get(L),
                    at = b.length > 1;
                if (at)
                    for (let dt = 0; dt < b.length; dt++)
                        e.bindFramebuffer(r.FRAMEBUFFER, At.__webglMultisampledFramebuffer),
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + dt, r.RENDERBUFFER, null),
                        e.bindFramebuffer(r.FRAMEBUFFER, At.__webglFramebuffer),
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + dt, r.TEXTURE_2D, null, 0);
                e.bindFramebuffer(r.READ_FRAMEBUFFER, At.__webglMultisampledFramebuffer),
                e.bindFramebuffer(r.DRAW_FRAMEBUFFER, At.__webglFramebuffer);
                for (let dt = 0; dt < b.length; dt++) {
                    if (L.resolveDepthBuffer && (L.depthBuffer && (rt |= r.DEPTH_BUFFER_BIT), L.stencilBuffer && L.resolveStencilBuffer && (rt |= r.STENCIL_BUFFER_BIT)), at) {
                        r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, At.__webglColorRenderbuffer[dt]);
                        const Ot = n.get(b[dt]).__webglTexture;
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, Ot, 0)
                    }
                    r.blitFramebuffer(0, 0, K, st, 0, 0, K, st, rt, r.NEAREST),
                    l === !0 && (N.length = 0, zt.length = 0, N.push(r.COLOR_ATTACHMENT0 + dt), L.depthBuffer && L.resolveDepthBuffer === !1 && (N.push(Q), zt.push(Q), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, zt)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, N))
                }
                if (e.bindFramebuffer(r.READ_FRAMEBUFFER, null), e.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), at)
                    for (let dt = 0; dt < b.length; dt++) {
                        e.bindFramebuffer(r.FRAMEBUFFER, At.__webglMultisampledFramebuffer),
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + dt, r.RENDERBUFFER, At.__webglColorRenderbuffer[dt]);
                        const Ot = n.get(b[dt]).__webglTexture;
                        e.bindFramebuffer(r.FRAMEBUFFER, At.__webglFramebuffer),
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + dt, r.TEXTURE_2D, Ot, 0)
                    }
                e.bindFramebuffer(r.DRAW_FRAMEBUFFER, At.__webglMultisampledFramebuffer)
            } else if (L.depthBuffer && L.resolveDepthBuffer === !1 && l) {
                const b = L.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
                r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [b])
            }
        }
    }
    function jt(L) {
        return Math.min(i.maxSamples, L.samples)
    }
    function yt(L) {
        const b = n.get(L);
        return L.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && b.__useRenderToTexture !== !1
    }
    function q(L) {
        const b = o.render.frame;
        h.get(L) !== b && (h.set(L, b), L.update())
    }
    function Lt(L, b) {
        const K = L.colorSpace,
            st = L.format,
            rt = L.type;
        return L.isCompressedTexture === !0 || L.isVideoTexture === !0 || K !== dn && K !== Us && (me.getTransfer(K) === Ne ? (st !== fi || rt !== xs) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", K)), b
    }
    function kt(L) {
        return typeof HTMLImageElement < "u" && L instanceof HTMLImageElement ? (c.width = L.naturalWidth || L.width, c.height = L.naturalHeight || L.height) : typeof VideoFrame < "u" && L instanceof VideoFrame ? (c.width = L.displayWidth, c.height = L.displayHeight) : (c.width = L.width, c.height = L.height), c
    }
    this.allocateTextureUnit = I,
    this.resetTextureUnits = D,
    this.setTexture2D = $,
    this.setTexture2DArray = j,
    this.setTexture3D = G,
    this.setTextureCube = H,
    this.rebindTextures = Nt,
    this.setupRenderTarget = Kt,
    this.updateRenderTargetMipmap = Jt,
    this.updateMultisampleRenderTarget = Bt,
    this.setupDepthRenderbuffer = Pt,
    this.setupFrameBufferTexture = it,
    this.useMultisampledRTT = yt
}
function tE(r, t) {
    function e(n, i=Us) {
        let s;
        const o = me.getTransfer(i);
        if (n === xs)
            return r.UNSIGNED_BYTE;
        if (n === pd)
            return r.UNSIGNED_SHORT_4_4_4_4;
        if (n === md)
            return r.UNSIGNED_SHORT_5_5_5_1;
        if (n === Zm)
            return r.UNSIGNED_INT_5_9_9_9_REV;
        if (n === Km)
            return r.BYTE;
        if (n === jm)
            return r.SHORT;
        if (n === La)
            return r.UNSIGNED_SHORT;
        if (n === fd)
            return r.INT;
        if (n === Tr)
            return r.UNSIGNED_INT;
        if (n === Ci)
            return r.FLOAT;
        if (n === ms)
            return r.HALF_FLOAT;
        if (n === Jm)
            return r.ALPHA;
        if (n === Qm)
            return r.RGB;
        if (n === fi)
            return r.RGBA;
        if (n === tg)
            return r.LUMINANCE;
        if (n === eg)
            return r.LUMINANCE_ALPHA;
        if (n === fo)
            return r.DEPTH_COMPONENT;
        if (n === Ao)
            return r.DEPTH_STENCIL;
        if (n === gd)
            return r.RED;
        if (n === _d)
            return r.RED_INTEGER;
        if (n === ng)
            return r.RG;
        if (n === xd)
            return r.RG_INTEGER;
        if (n === vd)
            return r.RGBA_INTEGER;
        if (n === Yl || n === $l || n === ql || n === Kl)
            if (o === Ne)
                if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
                    if (n === Yl)
                        return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === $l)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === ql)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === Kl)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (s = t.get("WEBGL_compressed_texture_s3tc"), s !== null) {
                if (n === Yl)
                    return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === $l)
                    return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === ql)
                    return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === Kl)
                    return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (n === Zh || n === Jh || n === Qh || n === tu)
            if (s = t.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
                if (n === Zh)
                    return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === Jh)
                    return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === Qh)
                    return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === tu)
                    return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (n === eu || n === nu || n === iu)
            if (s = t.get("WEBGL_compressed_texture_etc"), s !== null) {
                if (n === eu || n === nu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (n === iu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (n === su || n === ru || n === ou || n === au || n === lu || n === cu || n === hu || n === uu || n === du || n === fu || n === pu || n === mu || n === gu || n === _u)
            if (s = t.get("WEBGL_compressed_texture_astc"), s !== null) {
                if (n === su)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === ru)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === ou)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === au)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === lu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === cu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === hu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === uu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === du)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === fu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === pu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === mu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === gu)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === _u)
                    return o === Ne ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (n === jl || n === xu || n === vu)
            if (s = t.get("EXT_texture_compression_bptc"), s !== null) {
                if (n === jl)
                    return o === Ne ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === xu)
                    return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === vu)
                    return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (n === ig || n === yu || n === Mu || n === Su)
            if (s = t.get("EXT_texture_compression_rgtc"), s !== null) {
                if (n === jl)
                    return s.COMPRESSED_RED_RGTC1_EXT;
                if (n === yu)
                    return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === Mu)
                    return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Su)
                    return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return n === wo ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null
    }
    return {
        convert: e
    }
}
class eE extends yn {
    constructor(t=[])
    {
        super(),
        this.isArrayCamera = !0,
        this.cameras = t
    }
}
class ds extends He {
    constructor()
    {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const nE = {
    type: "move"
};
class fh {
    constructor()
    {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace()
    {
        return this._hand === null && (this._hand = new ds, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace()
    {
        return this._targetRay === null && (this._targetRay = new ds, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new O, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new O), this._targetRay
    }
    getGripSpace()
    {
        return this._grip === null && (this._grip = new ds, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new O, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new O), this._grip
    }
    dispatchEvent(t)
    {
        return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this
    }
    connect(t)
    {
        if (t && t.hand) {
            const e = this._hand;
            if (e)
                for (const n of t.hand.values())
                    this._getHandJoint(e, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: t
        }), this
    }
    disconnect(t)
    {
        return this.dispatchEvent({
            type: "disconnected",
            data: t
        }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
    }
    update(t, e, n)
    {
        let i = null,
            s = null,
            o = null;
        const a = this._targetRay,
            l = this._grip,
            c = this._hand;
        if (t && e.session.visibilityState !== "visible-blurred") {
            if (c && t.hand) {
                o = !0;
                for (const _ of t.hand.values()) {
                    const g = e.getJointPose(_, n),
                        p = this._getHandJoint(c, _);
                    g !== null && (p.matrix.fromArray(g.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, p.jointRadius = g.radius),
                    p.visible = g !== null
                }
                const h = c.joints["index-finger-tip"],
                    u = c.joints["thumb-tip"],
                    d = h.position.distanceTo(u.position),
                    f = .02,
                    m = .005;
                c.inputState.pinching && d > f + m ? (c.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this
                })) : !c.inputState.pinching && d <= f - m && (c.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this
                }))
            } else
                l !== null && t.gripSpace && (s = e.getPose(t.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (i = e.getPose(t.targetRaySpace, n), i === null && s !== null && (i = s), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(nE)))
        }
        return a !== null && (a.visible = i !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this
    }
    _getHandJoint(t, e)
    {
        if (t.joints[e.jointName] === void 0) {
            const n = new ds;
            n.matrixAutoUpdate = !1,
            n.visible = !1,
            t.joints[e.jointName] = n,
            t.add(n)
        }
        return t.joints[e.jointName]
    }
}
const iE = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`




    ,
    sE = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`


















    ;
class rE {
    constructor()
    {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(t, e, n)
    {
        if (this.texture === null) {
            const i = new an,
                s = t.properties.get(i);
            s.__webglTexture = e.texture,
            (e.depthNear != n.depthNear || e.depthFar != n.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar),
            this.texture = i
        }
    }
    getMesh(t)
    {
        if (this.texture !== null && this.mesh === null) {
            const e = t.cameras[0].viewport,
                n = new On({
                    vertexShader: iE,
                    fragmentShader: sE,
                    uniforms: {
                        depthColor: {
                            value: this.texture
                        },
                        depthWidth: {
                            value: e.z
                        },
                        depthHeight: {
                            value: e.w
                        }
                    }
                });
            this.mesh = new Un(new qa(20, 20), n)
        }
        return this.mesh
    }
    reset()
    {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture()
    {
        return this.texture
    }
}
class oE extends Rr {
    constructor(t, e)
    {
        super();
        const n = this;
        let i = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = 1,
            c = null,
            h = null,
            u = null,
            d = null,
            f = null,
            m = null;
        const _ = new rE,
            g = e.getContextAttributes();
        let p = null,
            x = null;
        const v = [],
            y = [],
            C = new St;
        let A = null;
        const T = new yn;
        T.layers.enable(1),
        T.viewport = new Pe;
        const R = new yn;
        R.layers.enable(2),
        R.viewport = new Pe;
        const E = [T, R],
            M = new eE;
        M.layers.enable(1),
        M.layers.enable(2);
        let D = null,
            I = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(J) {
            let it = v[J];
            return it === void 0 && (it = new fh, v[J] = it), it.getTargetRaySpace()
        },
        this.getControllerGrip = function(J) {
            let it = v[J];
            return it === void 0 && (it = new fh, v[J] = it), it.getGripSpace()
        },
        this.getHand = function(J) {
            let it = v[J];
            return it === void 0 && (it = new fh, v[J] = it), it.getHandSpace()
        };
        function k(J) {
            const it = y.indexOf(J.inputSource);
            if (it === -1)
                return;
            const ft = v[it];
            ft !== void 0 && (ft.update(J.inputSource, J.frame, c || o), ft.dispatchEvent({
                type: J.type,
                data: J.inputSource
            }))
        }
        function $() {
            i.removeEventListener("select", k),
            i.removeEventListener("selectstart", k),
            i.removeEventListener("selectend", k),
            i.removeEventListener("squeeze", k),
            i.removeEventListener("squeezestart", k),
            i.removeEventListener("squeezeend", k),
            i.removeEventListener("end", $),
            i.removeEventListener("inputsourceschange", j);
            for (let J = 0; J < v.length; J++) {
                const it = y[J];
                it !== null && (y[J] = null, v[J].disconnect(it))
            }
            D = null,
            I = null,
            _.reset(),
            t.setRenderTarget(p),
            f = null,
            d = null,
            u = null,
            i = null,
            x = null,
            Zt.stop(),
            n.isPresenting = !1,
            t.setPixelRatio(A),
            t.setSize(C.width, C.height, !1),
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(J) {
            s = J,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        },
        this.setReferenceSpaceType = function(J) {
            a = J,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        },
        this.getReferenceSpace = function() {
            return c || o
        },
        this.setReferenceSpace = function(J) {
            c = J
        },
        this.getBaseLayer = function() {
            return d !== null ? d : f
        },
        this.getBinding = function() {
            return u
        },
        this.getFrame = function() {
            return m
        },
        this.getSession = function() {
            return i
        },
        this.setSession = async function(J) {
            if (i = J, i !== null) {
                if (p = t.getRenderTarget(), i.addEventListener("select", k), i.addEventListener("selectstart", k), i.addEventListener("selectend", k), i.addEventListener("squeeze", k), i.addEventListener("squeezestart", k), i.addEventListener("squeezeend", k), i.addEventListener("end", $), i.addEventListener("inputsourceschange", j), g.xrCompatible !== !0 && await e.makeXRCompatible(), A = t.getPixelRatio(), t.getSize(C), i.renderState.layers === void 0) {
                    const it = {
                        antialias: g.antialias,
                        alpha: !0,
                        depth: g.depth,
                        stencil: g.stencil,
                        framebufferScaleFactor: s
                    };
                    f = new XRWebGLLayer(i, e, it),
                    i.updateRenderState({
                        baseLayer: f
                    }),
                    t.setPixelRatio(1),
                    t.setSize(f.framebufferWidth, f.framebufferHeight, !1),
                    x = new Pi(f.framebufferWidth, f.framebufferHeight, {
                        format: fi,
                        type: xs,
                        colorSpace: t.outputColorSpace,
                        stencilBuffer: g.stencil
                    })
                } else {
                    let it = null,
                        ft = null,
                        ut = null;
                    g.depth && (ut = g.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, it = g.stencil ? Ao : fo, ft = g.stencil ? wo : Tr);
                    const Pt = {
                        colorFormat: e.RGBA8,
                        depthFormat: ut,
                        scaleFactor: s
                    };
                    u = new XRWebGLBinding(i, e),
                    d = u.createProjectionLayer(Pt),
                    i.updateRenderState({
                        layers: [d]
                    }),
                    t.setPixelRatio(1),
                    t.setSize(d.textureWidth, d.textureHeight, !1),
                    x = new Pi(d.textureWidth, d.textureHeight, {
                        format: fi,
                        type: xs,
                        depthTexture: new Mg(d.textureWidth, d.textureHeight, ft, void 0, void 0, void 0, void 0, void 0, void 0, it),
                        stencilBuffer: g.stencil,
                        colorSpace: t.outputColorSpace,
                        samples: g.antialias ? 4 : 0,
                        resolveDepthBuffer: d.ignoreDepthValues === !1
                    })
                }
                x.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await i.requestReferenceSpace(a),
                Zt.setContext(i),
                Zt.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        },
        this.getEnvironmentBlendMode = function() {
            if (i !== null)
                return i.environmentBlendMode
        },
        this.getDepthTexture = function() {
            return _.getDepthTexture()
        };
        function j(J) {
            for (let it = 0; it < J.removed.length; it++) {
                const ft = J.removed[it],
                    ut = y.indexOf(ft);
                ut >= 0 && (y[ut] = null, v[ut].disconnect(ft))
            }
            for (let it = 0; it < J.added.length; it++) {
                const ft = J.added[it];
                let ut = y.indexOf(ft);
                if (ut === -1) {
                    for (let Nt = 0; Nt < v.length; Nt++)
                        if (Nt >= y.length) {
                            y.push(ft),
                            ut = Nt;
                            break
                        } else if (y[Nt] === null) {
                            y[Nt] = ft,
                            ut = Nt;
                            break
                        }
                    if (ut === -1)
                        break
                }
                const Pt = v[ut];
                Pt && Pt.connect(ft)
            }
        }
        const G = new O,
            H = new O;
        function V(J, it, ft) {
            G.setFromMatrixPosition(it.matrixWorld),
            H.setFromMatrixPosition(ft.matrixWorld);
            const ut = G.distanceTo(H),
                Pt = it.projectionMatrix.elements,
                Nt = ft.projectionMatrix.elements,
                Kt = Pt[14] / (Pt[10] - 1),
                Jt = Pt[14] / (Pt[10] + 1),
                N = (Pt[9] + 1) / Pt[5],
                zt = (Pt[9] - 1) / Pt[5],
                Bt = (Pt[8] - 1) / Pt[0],
                jt = (Nt[8] + 1) / Nt[0],
                yt = Kt * Bt,
                q = Kt * jt,
                Lt = ut / (-Bt + jt),
                kt = Lt * -Bt;
            it.matrixWorld.decompose(J.position, J.quaternion, J.scale),
            J.translateX(kt),
            J.translateZ(Lt),
            J.matrixWorld.compose(J.position, J.quaternion, J.scale),
            J.matrixWorldInverse.copy(J.matrixWorld).invert();
            const L = Kt + Lt,
                b = Jt + Lt,
                K = yt - kt,
                st = q + (ut - kt),
                rt = N * Jt / b * L,
                Q = zt * Jt / b * L;
            J.projectionMatrix.makePerspective(K, st, rt, Q, L, b),
            J.projectionMatrixInverse.copy(J.projectionMatrix).invert()
        }
        function nt(J, it) {
            it === null ? J.matrixWorld.copy(J.matrix) : J.matrixWorld.multiplyMatrices(it.matrixWorld, J.matrix),
            J.matrixWorldInverse.copy(J.matrixWorld).invert()
        }
        this.updateCamera = function(J) {
            if (i === null)
                return;
            _.texture !== null && (J.near = _.depthNear, J.far = _.depthFar),
            M.near = R.near = T.near = J.near,
            M.far = R.far = T.far = J.far,
            (D !== M.near || I !== M.far) && (i.updateRenderState({
                depthNear: M.near,
                depthFar: M.far
            }), D = M.near, I = M.far, T.near = D, T.far = I, R.near = D, R.far = I, T.updateProjectionMatrix(), R.updateProjectionMatrix(), J.updateProjectionMatrix());
            const it = J.parent,
                ft = M.cameras;
            nt(M, it);
            for (let ut = 0; ut < ft.length; ut++)
                nt(ft[ut], it);
            ft.length === 2 ? V(M, T, R) : M.projectionMatrix.copy(T.projectionMatrix),
            P(J, M, it)
        };
        function P(J, it, ft) {
            ft === null ? J.matrix.copy(it.matrixWorld) : (J.matrix.copy(ft.matrixWorld), J.matrix.invert(), J.matrix.multiply(it.matrixWorld)),
            J.matrix.decompose(J.position, J.quaternion, J.scale),
            J.updateMatrixWorld(!0),
            J.projectionMatrix.copy(it.projectionMatrix),
            J.projectionMatrixInverse.copy(it.projectionMatrixInverse),
            J.isPerspectiveCamera && (J.fov = Co * 2 * Math.atan(1 / J.projectionMatrix.elements[5]), J.zoom = 1)
        }
        this.getCamera = function() {
            return M
        },
        this.getFoveation = function() {
            if (!(d === null && f === null))
                return l
        },
        this.setFoveation = function(J) {
            l = J,
            d !== null && (d.fixedFoveation = J),
            f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = J)
        },
        this.hasDepthSensing = function() {
            return _.texture !== null
        },
        this.getDepthSensingMesh = function() {
            return _.getMesh(M)
        };
        let ct = null;
        function Ut(J, it) {
            if (h = it.getViewerPose(c || o), m = it, h !== null) {
                const ft = h.views;
                f !== null && (t.setRenderTargetFramebuffer(x, f.framebuffer), t.setRenderTarget(x));
                let ut = !1;
                ft.length !== M.cameras.length && (M.cameras.length = 0, ut = !0);
                for (let Nt = 0; Nt < ft.length; Nt++) {
                    const Kt = ft[Nt];
                    let Jt = null;
                    if (f !== null)
                        Jt = f.getViewport(Kt);
                    else {
                        const zt = u.getViewSubImage(d, Kt);
                        Jt = zt.viewport,
                        Nt === 0 && (t.setRenderTargetTextures(x, zt.colorTexture, d.ignoreDepthValues ? void 0 : zt.depthStencilTexture), t.setRenderTarget(x))
                    }
                    let N = E[Nt];
                    N === void 0 && (N = new yn, N.layers.enable(Nt), N.viewport = new Pe, E[Nt] = N),
                    N.matrix.fromArray(Kt.transform.matrix),
                    N.matrix.decompose(N.position, N.quaternion, N.scale),
                    N.projectionMatrix.fromArray(Kt.projectionMatrix),
                    N.projectionMatrixInverse.copy(N.projectionMatrix).invert(),
                    N.viewport.set(Jt.x, Jt.y, Jt.width, Jt.height),
                    Nt === 0 && (M.matrix.copy(N.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)),
                    ut === !0 && M.cameras.push(N)
                }
                const Pt = i.enabledFeatures;
                if (Pt && Pt.includes("depth-sensing")) {
                    const Nt = u.getDepthInformation(ft[0]);
                    Nt && Nt.isValid && Nt.texture && _.init(t, Nt, i.renderState)
                }
            }
            for (let ft = 0; ft < v.length; ft++) {
                const ut = y[ft],
                    Pt = v[ft];
                ut !== null && Pt !== void 0 && Pt.update(ut, it, c || o)
            }
            ct && ct(J, it),
            it.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: it
            }),
            m = null
        }
        const Zt = new yg;
        Zt.setAnimationLoop(Ut),
        this.setAnimationLoop = function(J) {
            ct = J
        },
        this.dispose = function() {}
    }
}
const sr = new Xi,
    aE = new le;
function lE(r, t) {
    function e(g, p) {
        g.matrixAutoUpdate === !0 && g.updateMatrix(),
        p.value.copy(g.matrix)
    }
    function n(g, p) {
        p.color.getRGB(g.fogColor.value, _g(r)),
        p.isFog ? (g.fogNear.value = p.near, g.fogFar.value = p.far) : p.isFogExp2 && (g.fogDensity.value = p.density)
    }
    function i(g, p, x, v, y) {
        p.isMeshBasicMaterial || p.isMeshLambertMaterial ? s(g, p) : p.isMeshToonMaterial ? (s(g, p), u(g, p)) : p.isMeshPhongMaterial ? (s(g, p), h(g, p)) : p.isMeshStandardMaterial ? (s(g, p), d(g, p), p.isMeshPhysicalMaterial && f(g, p, y)) : p.isMeshMatcapMaterial ? (s(g, p), m(g, p)) : p.isMeshDepthMaterial ? s(g, p) : p.isMeshDistanceMaterial ? (s(g, p), _(g, p)) : p.isMeshNormalMaterial ? s(g, p) : p.isLineBasicMaterial ? (o(g, p), p.isLineDashedMaterial && a(g, p)) : p.isPointsMaterial ? l(g, p, x, v) : p.isSpriteMaterial ? c(g, p) : p.isShadowMaterial ? (g.color.value.copy(p.color), g.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
    }
    function s(g, p) {
        g.opacity.value = p.opacity,
        p.color && g.diffuse.value.copy(p.color),
        p.emissive && g.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
        p.map && (g.map.value = p.map, e(p.map, g.mapTransform)),
        p.alphaMap && (g.alphaMap.value = p.alphaMap, e(p.alphaMap, g.alphaMapTransform)),
        p.bumpMap && (g.bumpMap.value = p.bumpMap, e(p.bumpMap, g.bumpMapTransform), g.bumpScale.value = p.bumpScale, p.side === kn && (g.bumpScale.value *= -1)),
        p.normalMap && (g.normalMap.value = p.normalMap, e(p.normalMap, g.normalMapTransform), g.normalScale.value.copy(p.normalScale), p.side === kn && g.normalScale.value.negate()),
        p.displacementMap && (g.displacementMap.value = p.displacementMap, e(p.displacementMap, g.displacementMapTransform), g.displacementScale.value = p.displacementScale, g.displacementBias.value = p.displacementBias),
        p.emissiveMap && (g.emissiveMap.value = p.emissiveMap, e(p.emissiveMap, g.emissiveMapTransform)),
        p.specularMap && (g.specularMap.value = p.specularMap, e(p.specularMap, g.specularMapTransform)),
        p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
        const x = t.get(p),
            v = x.envMap,
            y = x.envMapRotation;
        v && (g.envMap.value = v, sr.copy(y), sr.x *= -1, sr.y *= -1, sr.z *= -1, v.isCubeTexture && v.isRenderTargetTexture === !1 && (sr.y *= -1, sr.z *= -1), g.envMapRotation.value.setFromMatrix4(aE.makeRotationFromEuler(sr)), g.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, g.reflectivity.value = p.reflectivity, g.ior.value = p.ior, g.refractionRatio.value = p.refractionRatio),
        p.lightMap && (g.lightMap.value = p.lightMap, g.lightMapIntensity.value = p.lightMapIntensity, e(p.lightMap, g.lightMapTransform)),
        p.aoMap && (g.aoMap.value = p.aoMap, g.aoMapIntensity.value = p.aoMapIntensity, e(p.aoMap, g.aoMapTransform))
    }
    function o(g, p) {
        g.diffuse.value.copy(p.color),
        g.opacity.value = p.opacity,
        p.map && (g.map.value = p.map, e(p.map, g.mapTransform))
    }
    function a(g, p) {
        g.dashSize.value = p.dashSize,
        g.totalSize.value = p.dashSize + p.gapSize,
        g.scale.value = p.scale
    }
    function l(g, p, x, v) {
        g.diffuse.value.copy(p.color),
        g.opacity.value = p.opacity,
        g.size.value = p.size * x,
        g.scale.value = v * .5,
        p.map && (g.map.value = p.map, e(p.map, g.uvTransform)),
        p.alphaMap && (g.alphaMap.value = p.alphaMap, e(p.alphaMap, g.alphaMapTransform)),
        p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest)
    }
    function c(g, p) {
        g.diffuse.value.copy(p.color),
        g.opacity.value = p.opacity,
        g.rotation.value = p.rotation,
        p.map && (g.map.value = p.map, e(p.map, g.mapTransform)),
        p.alphaMap && (g.alphaMap.value = p.alphaMap, e(p.alphaMap, g.alphaMapTransform)),
        p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest)
    }
    function h(g, p) {
        g.specular.value.copy(p.specular),
        g.shininess.value = Math.max(p.shininess, 1e-4)
    }
    function u(g, p) {
        p.gradientMap && (g.gradientMap.value = p.gradientMap)
    }
    function d(g, p) {
        g.metalness.value = p.metalness,
        p.metalnessMap && (g.metalnessMap.value = p.metalnessMap, e(p.metalnessMap, g.metalnessMapTransform)),
        g.roughness.value = p.roughness,
        p.roughnessMap && (g.roughnessMap.value = p.roughnessMap, e(p.roughnessMap, g.roughnessMapTransform)),
        p.envMap && (g.envMapIntensity.value = p.envMapIntensity)
    }
    function f(g, p, x) {
        g.ior.value = p.ior,
        p.sheen > 0 && (g.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), g.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (g.sheenColorMap.value = p.sheenColorMap, e(p.sheenColorMap, g.sheenColorMapTransform)), p.sheenRoughnessMap && (g.sheenRoughnessMap.value = p.sheenRoughnessMap, e(p.sheenRoughnessMap, g.sheenRoughnessMapTransform))),
        p.clearcoat > 0 && (g.clearcoat.value = p.clearcoat, g.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (g.clearcoatMap.value = p.clearcoatMap, e(p.clearcoatMap, g.clearcoatMapTransform)), p.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, e(p.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (g.clearcoatNormalMap.value = p.clearcoatNormalMap, e(p.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === kn && g.clearcoatNormalScale.value.negate())),
        p.dispersion > 0 && (g.dispersion.value = p.dispersion),
        p.iridescence > 0 && (g.iridescence.value = p.iridescence, g.iridescenceIOR.value = p.iridescenceIOR, g.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (g.iridescenceMap.value = p.iridescenceMap, e(p.iridescenceMap, g.iridescenceMapTransform)), p.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = p.iridescenceThicknessMap, e(p.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))),
        p.transmission > 0 && (g.transmission.value = p.transmission, g.transmissionSamplerMap.value = x.texture, g.transmissionSamplerSize.value.set(x.width, x.height), p.transmissionMap && (g.transmissionMap.value = p.transmissionMap, e(p.transmissionMap, g.transmissionMapTransform)), g.thickness.value = p.thickness, p.thicknessMap && (g.thicknessMap.value = p.thicknessMap, e(p.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = p.attenuationDistance, g.attenuationColor.value.copy(p.attenuationColor)),
        p.anisotropy > 0 && (g.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (g.anisotropyMap.value = p.anisotropyMap, e(p.anisotropyMap, g.anisotropyMapTransform))),
        g.specularIntensity.value = p.specularIntensity,
        g.specularColor.value.copy(p.specularColor),
        p.specularColorMap && (g.specularColorMap.value = p.specularColorMap, e(p.specularColorMap, g.specularColorMapTransform)),
        p.specularIntensityMap && (g.specularIntensityMap.value = p.specularIntensityMap, e(p.specularIntensityMap, g.specularIntensityMapTransform))
    }
    function m(g, p) {
        p.matcap && (g.matcap.value = p.matcap)
    }
    function _(g, p) {
        const x = t.get(p).light;
        g.referencePosition.value.setFromMatrixPosition(x.matrixWorld),
        g.nearDistance.value = x.shadow.camera.near,
        g.farDistance.value = x.shadow.camera.far
    }
    return {
        refreshFogUniforms: n,
        refreshMaterialUniforms: i
    }
}
function cE(r, t, e, n) {
    let i = {},
        s = {},
        o = [];
    const a = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(x, v) {
        const y = v.program;
        n.uniformBlockBinding(x, y)
    }
    function c(x, v) {
        let y = i[x.id];
        y === void 0 && (m(x), y = h(x), i[x.id] = y, x.addEventListener("dispose", g));
        const C = v.program;
        n.updateUBOMapping(x, C);
        const A = t.render.frame;
        s[x.id] !== A && (d(x), s[x.id] = A)
    }
    function h(x) {
        const v = u();
        x.__bindingPointIndex = v;
        const y = r.createBuffer(),
            C = x.__size,
            A = x.usage;
        return r.bindBuffer(r.UNIFORM_BUFFER, y), r.bufferData(r.UNIFORM_BUFFER, C, A), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, v, y), y
    }
    function u() {
        for (let x = 0; x < a; x++)
            if (o.indexOf(x) === -1)
                return o.push(x), x;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
    }
    function d(x) {
        const v = i[x.id],
            y = x.uniforms,
            C = x.__cache;
        r.bindBuffer(r.UNIFORM_BUFFER, v);
        for (let A = 0, T = y.length; A < T; A++) {
            const R = Array.isArray(y[A]) ? y[A] : [y[A]];
            for (let E = 0, M = R.length; E < M; E++) {
                const D = R[E];
                if (f(D, A, E, C) === !0) {
                    const I = D.__offset,
                        k = Array.isArray(D.value) ? D.value : [D.value];
                    let $ = 0;
                    for (let j = 0; j < k.length; j++) {
                        const G = k[j],
                            H = _(G);
                        typeof G == "number" || typeof G == "boolean" ? (D.__data[0] = G, r.bufferSubData(r.UNIFORM_BUFFER, I + $, D.__data)) : G.isMatrix3 ? (D.__data[0] = G.elements[0], D.__data[1] = G.elements[1], D.__data[2] = G.elements[2], D.__data[3] = 0, D.__data[4] = G.elements[3], D.__data[5] = G.elements[4], D.__data[6] = G.elements[5], D.__data[7] = 0, D.__data[8] = G.elements[6], D.__data[9] = G.elements[7], D.__data[10] = G.elements[8], D.__data[11] = 0) : (G.toArray(D.__data, $), $ += H.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    r.bufferSubData(r.UNIFORM_BUFFER, I, D.__data)
                }
            }
        }
        r.bindBuffer(r.UNIFORM_BUFFER, null)
    }
    function f(x, v, y, C) {
        const A = x.value,
            T = v + "_" + y;
        if (C[T] === void 0)
            return typeof A == "number" || typeof A == "boolean" ? C[T] = A : C[T] = A.clone(), !0;
        {
            const R = C[T];
            if (typeof A == "number" || typeof A == "boolean") {
                if (R !== A)
                    return C[T] = A, !0
            } else if (R.equals(A) === !1)
                return R.copy(A), !0
        }
        return !1
    }
    function m(x) {
        const v = x.uniforms;
        let y = 0;
        const C = 16;
        for (let T = 0, R = v.length; T < R; T++) {
            const E = Array.isArray(v[T]) ? v[T] : [v[T]];
            for (let M = 0, D = E.length; M < D; M++) {
                const I = E[M],
                    k = Array.isArray(I.value) ? I.value : [I.value];
                for (let $ = 0, j = k.length; $ < j; $++) {
                    const G = k[$],
                        H = _(G),
                        V = y % C,
                        nt = V % H.boundary,
                        P = V + nt;
                    y += nt,
                    P !== 0 && C - P < H.storage && (y += C - P),
                    I.__data = new Float32Array(H.storage / Float32Array.BYTES_PER_ELEMENT),
                    I.__offset = y,
                    y += H.storage
                }
            }
        }
        const A = y % C;
        return A > 0 && (y += C - A), x.__size = y, x.__cache = {}, this
    }
    function _(x) {
        const v = {
            boundary: 0,
            storage: 0
        };
        return typeof x == "number" || typeof x == "boolean" ? (v.boundary = 4, v.storage = 4) : x.isVector2 ? (v.boundary = 8, v.storage = 8) : x.isVector3 || x.isColor ? (v.boundary = 16, v.storage = 12) : x.isVector4 ? (v.boundary = 16, v.storage = 16) : x.isMatrix3 ? (v.boundary = 48, v.storage = 48) : x.isMatrix4 ? (v.boundary = 64, v.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x), v
    }
    function g(x) {
        const v = x.target;
        v.removeEventListener("dispose", g);
        const y = o.indexOf(v.__bindingPointIndex);
        o.splice(y, 1),
        r.deleteBuffer(i[v.id]),
        delete i[v.id],
        delete s[v.id]
    }
    function p() {
        for (const x in i)
            r.deleteBuffer(i[x]);
        o = [],
        i = {},
        s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: p
    }
}
class wg {
    constructor(t={})
    {
        const {canvas: e=ev(), context: n=null, depth: i=!0, stencil: s=!1, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: h="default", failIfMajorPerformanceCaveat: u=!1} = t;
        this.isWebGLRenderer = !0;
        let d;
        if (n !== null) {
            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            d = n.getContextAttributes().alpha
        } else
            d = o;
        const f = new Uint32Array(4),
            m = new Int32Array(4);
        let _ = null,
            g = null;
        const p = [],
            x = [];
        this.domElement = e,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = Ln,
        this.toneMapping = Xs,
        this.toneMappingExposure = 1;
        const v = this;
        let y = !1,
            C = 0,
            A = 0,
            T = null,
            R = -1,
            E = null;
        const M = new Pe,
            D = new Pe;
        let I = null;
        const k = new Gt(0);
        let $ = 0,
            j = e.width,
            G = e.height,
            H = 1,
            V = null,
            nt = null;
        const P = new Pe(0, 0, j, G),
            ct = new Pe(0, 0, j, G);
        let Ut = !1;
        const Zt = new Td;
        let J = !1,
            it = !1;
        const ft = new le,
            ut = new O,
            Pt = new Pe,
            Nt = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
        let Kt = !1;
        function Jt() {
            return T === null ? H : 1
        }
        let N = n;
        function zt(w, U) {
            return e.getContext(w, U)
        }
        try {
            const w = {
                alpha: !0,
                depth: i,
                stencil: s,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: h,
                failIfMajorPerformanceCaveat: u
            };
            if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${dd}`), e.addEventListener("webglcontextlost", Y, !1), e.addEventListener("webglcontextrestored", Z, !1), e.addEventListener("webglcontextcreationerror", et, !1), N === null) {
                const U = "webgl2";
                if (N = zt(U, w), N === null)
                    throw zt(U) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (w) {
            throw console.error("THREE.WebGLRenderer: " + w.message), w
        }
        let Bt,
            jt,
            yt,
            q,
            Lt,
            kt,
            L,
            b,
            K,
            st,
            rt,
            Q,
            At,
            at,
            dt,
            Ot,
            lt,
            xt,
            It,
            Xt,
            vt,
            Wt,
            Yt,
            de;
        function S() {
            Bt = new gS(N),
            Bt.init(),
            Wt = new tE(N, Bt),
            jt = new hS(N, Bt, t, Wt),
            yt = new ZT(N),
            q = new vS(N),
            Lt = new OT,
            kt = new QT(N, Bt, yt, Lt, jt, Wt, q),
            L = new dS(v),
            b = new mS(v),
            K = new wv(N),
            Yt = new lS(N, K),
            st = new _S(N, K, q, Yt),
            rt = new MS(N, st, K, q),
            It = new yS(N, jt, kt),
            Ot = new uS(Lt),
            Q = new UT(v, L, b, Bt, jt, Yt, Ot),
            At = new lE(v, Lt),
            at = new BT,
            dt = new XT(Bt),
            xt = new aS(v, L, b, yt, rt, d, l),
            lt = new jT(v, rt, jt),
            de = new cE(N, q, jt, yt),
            Xt = new cS(N, Bt, q),
            vt = new xS(N, Bt, q),
            q.programs = Q.programs,
            v.capabilities = jt,
            v.extensions = Bt,
            v.properties = Lt,
            v.renderLists = at,
            v.shadowMap = lt,
            v.state = yt,
            v.info = q
        }
        S();
        const F = new oE(v, N);
        this.xr = F,
        this.getContext = function() {
            return N
        },
        this.getContextAttributes = function() {
            return N.getContextAttributes()
        },
        this.forceContextLoss = function() {
            const w = Bt.get("WEBGL_lose_context");
            w && w.loseContext()
        },
        this.forceContextRestore = function() {
            const w = Bt.get("WEBGL_lose_context");
            w && w.restoreContext()
        },
        this.getPixelRatio = function() {
            return H
        },
        this.setPixelRatio = function(w) {
            w !== void 0 && (H = w, this.setSize(j, G, !1))
        },
        this.getSize = function(w) {
            return w.set(j, G)
        },
        this.setSize = function(w, U, X=!0) {
            if (F.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            j = w,
            G = U,
            e.width = Math.floor(w * H),
            e.height = Math.floor(U * H),
            X === !0 && (e.style.width = w + "px", e.style.height = U + "px"),
            this.setViewport(0, 0, w, U)
        },
        this.getDrawingBufferSize = function(w) {
            return w.set(j * H, G * H).floor()
        },
        this.setDrawingBufferSize = function(w, U, X) {
            j = w,
            G = U,
            H = X,
            e.width = Math.floor(w * X),
            e.height = Math.floor(U * X),
            this.setViewport(0, 0, w, U)
        },
        this.getCurrentViewport = function(w) {
            return w.copy(M)
        },
        this.getViewport = function(w) {
            return w.copy(P)
        },
        this.setViewport = function(w, U, X, W) {
            w.isVector4 ? P.set(w.x, w.y, w.z, w.w) : P.set(w, U, X, W),
            yt.viewport(M.copy(P).multiplyScalar(H).round())
        },
        this.getScissor = function(w) {
            return w.copy(ct)
        },
        this.setScissor = function(w, U, X, W) {
            w.isVector4 ? ct.set(w.x, w.y, w.z, w.w) : ct.set(w, U, X, W),
            yt.scissor(D.copy(ct).multiplyScalar(H).round())
        },
        this.getScissorTest = function() {
            return Ut
        },
        this.setScissorTest = function(w) {
            yt.setScissorTest(Ut = w)
        },
        this.setOpaqueSort = function(w) {
            V = w
        },
        this.setTransparentSort = function(w) {
            nt = w
        },
        this.getClearColor = function(w) {
            return w.copy(xt.getClearColor())
        },
        this.setClearColor = function() {
            xt.setClearColor.apply(xt, arguments)
        },
        this.getClearAlpha = function() {
            return xt.getClearAlpha()
        },
        this.setClearAlpha = function() {
            xt.setClearAlpha.apply(xt, arguments)
        },
        this.clear = function(w=!0, U=!0, X=!0) {
            let W = 0;
            if (w) {
                let z = !1;
                if (T !== null) {
                    const ot = T.texture.format;
                    z = ot === vd || ot === xd || ot === _d
                }
                if (z) {
                    const ot = T.texture.type,
                        mt = ot === xs || ot === Tr || ot === La || ot === wo || ot === pd || ot === md,
                        bt = xt.getClearColor(),
                        gt = xt.getClearAlpha(),
                        Et = bt.r,
                        Ft = bt.g,
                        Vt = bt.b;
                    mt ? (f[0] = Et, f[1] = Ft, f[2] = Vt, f[3] = gt, N.clearBufferuiv(N.COLOR, 0, f)) : (m[0] = Et, m[1] = Ft, m[2] = Vt, m[3] = gt, N.clearBufferiv(N.COLOR, 0, m))
                } else
                    W |= N.COLOR_BUFFER_BIT
            }
            U && (W |= N.DEPTH_BUFFER_BIT),
            X && (W |= N.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)),
            N.clear(W)
        },
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        },
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        },
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        },
        this.dispose = function() {
            e.removeEventListener("webglcontextlost", Y, !1),
            e.removeEventListener("webglcontextrestored", Z, !1),
            e.removeEventListener("webglcontextcreationerror", et, !1),
            at.dispose(),
            dt.dispose(),
            Lt.dispose(),
            L.dispose(),
            b.dispose(),
            rt.dispose(),
            Yt.dispose(),
            de.dispose(),
            Q.dispose(),
            F.dispose(),
            F.removeEventListener("sessionstart", Mt),
            F.removeEventListener("sessionend", Qt),
            ht.stop()
        };
        function Y(w) {
            w.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            y = !0
        }
        function Z() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            y = !1;
            const w = q.autoReset,
                U = lt.enabled,
                X = lt.autoUpdate,
                W = lt.needsUpdate,
                z = lt.type;
            S(),
            q.autoReset = w,
            lt.enabled = U,
            lt.autoUpdate = X,
            lt.needsUpdate = W,
            lt.type = z
        }
        function et(w) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", w.statusMessage)
        }
        function Tt(w) {
            const U = w.target;
            U.removeEventListener("dispose", Tt),
            Ht(U)
        }
        function Ht(w) {
            Te(w),
            Lt.remove(w)
        }
        function Te(w) {
            const U = Lt.get(w).programs;
            U !== void 0 && (U.forEach(function(X) {
                Q.releaseProgram(X)
            }), w.isShaderMaterial && Q.releaseShaderCache(w))
        }
        this.renderBufferDirect = function(w, U, X, W, z, ot) {
            U === null && (U = Nt);
            const mt = z.isMesh && z.matrixWorld.determinant() < 0,
                bt = Ce(w, U, X, W, z);
            yt.setMaterial(W, mt);
            let gt = X.index,
                Et = 1;
            if (W.wireframe === !0) {
                if (gt = st.getWireframeAttribute(X), gt === void 0)
                    return;
                Et = 2
            }
            const Ft = X.drawRange,
                Vt = X.attributes.position;
            let fe = Ft.start * Et,
                Ee = (Ft.start + Ft.count) * Et;
            ot !== null && (fe = Math.max(fe, ot.start * Et), Ee = Math.min(Ee, (ot.start + ot.count) * Et)),
            gt !== null ? (fe = Math.max(fe, 0), Ee = Math.min(Ee, gt.count)) : Vt != null && (fe = Math.max(fe, 0), Ee = Math.min(Ee, Vt.count));
            const pe = Ee - fe;
            if (pe < 0 || pe === 1 / 0)
                return;
            Yt.setup(z, W, bt, X, gt);
            let je,
                ce = Xt;
            if (gt !== null && (je = K.get(gt), ce = vt, ce.setIndex(je)), z.isMesh)
                W.wireframe === !0 ? (yt.setLineWidth(W.wireframeLinewidth * Jt()), ce.setMode(N.LINES)) : ce.setMode(N.TRIANGLES);
            else if (z.isLine) {
                let Rt = W.linewidth;
                Rt === void 0 && (Rt = 1),
                yt.setLineWidth(Rt * Jt()),
                z.isLineSegments ? ce.setMode(N.LINES) : z.isLineLoop ? ce.setMode(N.LINE_LOOP) : ce.setMode(N.LINE_STRIP)
            } else
                z.isPoints ? ce.setMode(N.POINTS) : z.isSprite && ce.setMode(N.TRIANGLES);
            if (z.isBatchedMesh)
                if (z._multiDrawInstances !== null)
                    ce.renderMultiDrawInstances(z._multiDrawStarts, z._multiDrawCounts, z._multiDrawCount, z._multiDrawInstances);
                else if (Bt.get("WEBGL_multi_draw"))
                    ce.renderMultiDraw(z._multiDrawStarts, z._multiDrawCounts, z._multiDrawCount);
                else {
                    const Rt = z._multiDrawStarts,
                        cn = z._multiDrawCounts,
                        ge = z._multiDrawCount,
                        xi = gt ? K.get(gt).bytesPerElement : 1,
                        Dr = Lt.get(W).currentProgram.getUniforms();
                    for (let $n = 0; $n < ge; $n++)
                        Dr.setValue(N, "_gl_DrawID", $n),
                        ce.render(Rt[$n] / xi, cn[$n])
                }
            else if (z.isInstancedMesh)
                ce.renderInstances(fe, pe, z.count);
            else if (X.isInstancedBufferGeometry) {
                const Rt = X._maxInstanceCount !== void 0 ? X._maxInstanceCount : 1 / 0,
                    cn = Math.min(X.instanceCount, Rt);
                ce.renderInstances(fe, pe, cn)
            } else
                ce.render(fe, pe)
        };
        function xe(w, U, X) {
            w.transparent === !0 && w.side === wi && w.forceSinglePass === !1 ? (w.side = kn, w.needsUpdate = !0, Ae(w, U, X), w.side = _s, w.needsUpdate = !0, Ae(w, U, X), w.side = wi) : Ae(w, U, X)
        }
        this.compile = function(w, U, X=null) {
            X === null && (X = w),
            g = dt.get(X),
            g.init(U),
            x.push(g),
            X.traverseVisible(function(z) {
                z.isLight && z.layers.test(U.layers) && (g.pushLight(z), z.castShadow && g.pushShadow(z))
            }),
            w !== X && w.traverseVisible(function(z) {
                z.isLight && z.layers.test(U.layers) && (g.pushLight(z), z.castShadow && g.pushShadow(z))
            }),
            g.setupLights();
            const W = new Set;
            return w.traverse(function(z) {
                const ot = z.material;
                if (ot)
                    if (Array.isArray(ot))
                        for (let mt = 0; mt < ot.length; mt++) {
                            const bt = ot[mt];
                            xe(bt, X, z),
                            W.add(bt)
                        }
                    else
                        xe(ot, X, z),
                        W.add(ot)
            }), x.pop(), g = null, W
        },
        this.compileAsync = function(w, U, X=null) {
            const W = this.compile(w, U, X);
            return new Promise(z => {
                function ot() {
                    if (W.forEach(function(mt) {
                        Lt.get(mt).currentProgram.isReady() && W.delete(mt)
                    }), W.size === 0) {
                        z(w);
                        return
                    }
                    setTimeout(ot, 10)
                }
                Bt.get("KHR_parallel_shader_compile") !== null ? ot() : setTimeout(ot, 10)
            })
        };
        let ne = null;
        function Ct(w) {
            ne && ne(w)
        }
        function Mt() {
            ht.stop()
        }
        function Qt() {
            ht.start()
        }
        const ht = new yg;
        ht.setAnimationLoop(Ct),
        typeof self < "u" && ht.setContext(self),
        this.setAnimationLoop = function(w) {
            ne = w,
            F.setAnimationLoop(w),
            w === null ? ht.stop() : ht.start()
        },
        F.addEventListener("sessionstart", Mt),
        F.addEventListener("sessionend", Qt),
        this.render = function(w, U) {
            if (U !== void 0 && U.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (y === !0)
                return;
            if (w.matrixWorldAutoUpdate === !0 && w.updateMatrixWorld(), U.parent === null && U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(), F.enabled === !0 && F.isPresenting === !0 && (F.cameraAutoUpdate === !0 && F.updateCamera(U), U = F.getCamera()), w.isScene === !0 && w.onBeforeRender(v, w, U, T), g = dt.get(w, x.length), g.init(U), x.push(g), ft.multiplyMatrices(U.projectionMatrix, U.matrixWorldInverse), Zt.setFromProjectionMatrix(ft), it = this.localClippingEnabled, J = Ot.init(this.clippingPlanes, it), _ = at.get(w, p.length), _.init(), p.push(_), F.enabled === !0 && F.isPresenting === !0) {
                const ot = v.xr.getDepthSensingMesh();
                ot !== null && $t(ot, U, -1 / 0, v.sortObjects)
            }
            $t(w, U, 0, v.sortObjects),
            _.finish(),
            v.sortObjects === !0 && _.sort(V, nt),
            Kt = F.enabled === !1 || F.isPresenting === !1 || F.hasDepthSensing() === !1,
            Kt && xt.addToRenderList(_, w),
            this.info.render.frame++,
            J === !0 && Ot.beginShadows();
            const X = g.state.shadowsArray;
            lt.render(X, w, U),
            J === !0 && Ot.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const W = _.opaque,
                z = _.transmissive;
            if (g.setupLights(), U.isArrayCamera) {
                const ot = U.cameras;
                if (z.length > 0)
                    for (let mt = 0, bt = ot.length; mt < bt; mt++) {
                        const gt = ot[mt];
                        qt(W, z, w, gt)
                    }
                Kt && xt.render(w);
                for (let mt = 0, bt = ot.length; mt < bt; mt++) {
                    const gt = ot[mt];
                    Dt(_, w, gt, gt.viewport)
                }
            } else
                z.length > 0 && qt(W, z, w, U),
                Kt && xt.render(w),
                Dt(_, w, U);
            T !== null && (kt.updateMultisampleRenderTarget(T), kt.updateRenderTargetMipmap(T)),
            w.isScene === !0 && w.onAfterRender(v, w, U),
            Yt.resetDefaultState(),
            R = -1,
            E = null,
            x.pop(),
            x.length > 0 ? (g = x[x.length - 1], J === !0 && Ot.setGlobalState(v.clippingPlanes, g.state.camera)) : g = null,
            p.pop(),
            p.length > 0 ? _ = p[p.length - 1] : _ = null
        };
        function $t(w, U, X, W) {
            if (w.visible === !1)
                return;
            if (w.layers.test(U.layers)) {
                if (w.isGroup)
                    X = w.renderOrder;
                else if (w.isLOD)
                    w.autoUpdate === !0 && w.update(U);
                else if (w.isLight)
                    g.pushLight(w),
                    w.castShadow && g.pushShadow(w);
                else if (w.isSprite) {
                    if (!w.frustumCulled || Zt.intersectsSprite(w)) {
                        W && Pt.setFromMatrixPosition(w.matrixWorld).applyMatrix4(ft);
                        const mt = rt.update(w),
                            bt = w.material;
                        bt.visible && _.push(w, mt, bt, X, Pt.z, null)
                    }
                } else if ((w.isMesh || w.isLine || w.isPoints) && (!w.frustumCulled || Zt.intersectsObject(w))) {
                    const mt = rt.update(w),
                        bt = w.material;
                    if (W && (w.boundingSphere !== void 0 ? (w.boundingSphere === null && w.computeBoundingSphere(), Pt.copy(w.boundingSphere.center)) : (mt.boundingSphere === null && mt.computeBoundingSphere(), Pt.copy(mt.boundingSphere.center)), Pt.applyMatrix4(w.matrixWorld).applyMatrix4(ft)), Array.isArray(bt)) {
                        const gt = mt.groups;
                        for (let Et = 0, Ft = gt.length; Et < Ft; Et++) {
                            const Vt = gt[Et],
                                fe = bt[Vt.materialIndex];
                            fe && fe.visible && _.push(w, mt, fe, X, Pt.z, Vt)
                        }
                    } else
                        bt.visible && _.push(w, mt, bt, X, Pt.z, null)
                }
            }
            const ot = w.children;
            for (let mt = 0, bt = ot.length; mt < bt; mt++)
                $t(ot[mt], U, X, W)
        }
        function Dt(w, U, X, W) {
            const z = w.opaque,
                ot = w.transmissive,
                mt = w.transparent;
            g.setupLightsView(X),
            J === !0 && Ot.setGlobalState(v.clippingPlanes, X),
            W && yt.viewport(M.copy(W)),
            z.length > 0 && Oe(z, U, X),
            ot.length > 0 && Oe(ot, U, X),
            mt.length > 0 && Oe(mt, U, X),
            yt.buffers.depth.setTest(!0),
            yt.buffers.depth.setMask(!0),
            yt.buffers.color.setMask(!0),
            yt.setPolygonOffset(!1)
        }
        function qt(w, U, X, W) {
            if ((X.isScene === !0 ? X.overrideMaterial : null) !== null)
                return;
            g.state.transmissionRenderTarget[W.id] === void 0 && (g.state.transmissionRenderTarget[W.id] = new Pi(1, 1, {
                generateMipmaps: !0,
                type: Bt.has("EXT_color_buffer_half_float") || Bt.has("EXT_color_buffer_float") ? ms : xs,
                minFilter: hs,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: me.workingColorSpace
            }));
            const ot = g.state.transmissionRenderTarget[W.id],
                mt = W.viewport || M;
            ot.setSize(mt.z, mt.w);
            const bt = v.getRenderTarget();
            v.setRenderTarget(ot),
            v.getClearColor(k),
            $ = v.getClearAlpha(),
            $ < 1 && v.setClearColor(16777215, .5),
            v.clear(),
            Kt && xt.render(X);
            const gt = v.toneMapping;
            v.toneMapping = Xs;
            const Et = W.viewport;
            if (W.viewport !== void 0 && (W.viewport = void 0), g.setupLightsView(W), J === !0 && Ot.setGlobalState(v.clippingPlanes, W), Oe(w, X, W), kt.updateMultisampleRenderTarget(ot), kt.updateRenderTargetMipmap(ot), Bt.has("WEBGL_multisampled_render_to_texture") === !1) {
                let Ft = !1;
                for (let Vt = 0, fe = U.length; Vt < fe; Vt++) {
                    const Ee = U[Vt],
                        pe = Ee.object,
                        je = Ee.geometry,
                        ce = Ee.material,
                        Rt = Ee.group;
                    if (ce.side === wi && pe.layers.test(W.layers)) {
                        const cn = ce.side;
                        ce.side = kn,
                        ce.needsUpdate = !0,
                        ie(pe, X, W, je, ce, Rt),
                        ce.side = cn,
                        ce.needsUpdate = !0,
                        Ft = !0
                    }
                }
                Ft === !0 && (kt.updateMultisampleRenderTarget(ot), kt.updateRenderTargetMipmap(ot))
            }
            v.setRenderTarget(bt),
            v.setClearColor(k, $),
            Et !== void 0 && (W.viewport = Et),
            v.toneMapping = gt
        }
        function Oe(w, U, X) {
            const W = U.isScene === !0 ? U.overrideMaterial : null;
            for (let z = 0, ot = w.length; z < ot; z++) {
                const mt = w[z],
                    bt = mt.object,
                    gt = mt.geometry,
                    Et = W === null ? mt.material : W,
                    Ft = mt.group;
                bt.layers.test(X.layers) && ie(bt, U, X, gt, Et, Ft)
            }
        }
        function ie(w, U, X, W, z, ot) {
            w.onBeforeRender(v, U, X, W, z, ot),
            w.modelViewMatrix.multiplyMatrices(X.matrixWorldInverse, w.matrixWorld),
            w.normalMatrix.getNormalMatrix(w.modelViewMatrix),
            z.transparent === !0 && z.side === wi && z.forceSinglePass === !1 ? (z.side = kn, z.needsUpdate = !0, v.renderBufferDirect(X, U, W, z, w, ot), z.side = _s, z.needsUpdate = !0, v.renderBufferDirect(X, U, W, z, w, ot), z.side = wi) : v.renderBufferDirect(X, U, W, z, w, ot),
            w.onAfterRender(v, U, X, W, z, ot)
        }
        function Ae(w, U, X) {
            U.isScene !== !0 && (U = Nt);
            const W = Lt.get(w),
                z = g.state.lights,
                ot = g.state.shadowsArray,
                mt = z.state.version,
                bt = Q.getParameters(w, z.state, ot, U, X),
                gt = Q.getProgramCacheKey(bt);
            let Et = W.programs;
            W.environment = w.isMeshStandardMaterial ? U.environment : null,
            W.fog = U.fog,
            W.envMap = (w.isMeshStandardMaterial ? b : L).get(w.envMap || W.environment),
            W.envMapRotation = W.environment !== null && w.envMap === null ? U.environmentRotation : w.envMapRotation,
            Et === void 0 && (w.addEventListener("dispose", Tt), Et = new Map, W.programs = Et);
            let Ft = Et.get(gt);
            if (Ft !== void 0) {
                if (W.currentProgram === Ft && W.lightsStateVersion === mt)
                    return De(w, bt), Ft
            } else
                bt.uniforms = Q.getUniforms(w),
                w.onBeforeCompile(bt, v),
                Ft = Q.acquireProgram(bt, gt),
                Et.set(gt, Ft),
                W.uniforms = bt.uniforms;
            const Vt = W.uniforms;
            return (!w.isShaderMaterial && !w.isRawShaderMaterial || w.clipping === !0) && (Vt.clippingPlanes = Ot.uniform), De(w, bt), W.needsLights = Yn(w), W.lightsStateVersion = mt, W.needsLights && (Vt.ambientLightColor.value = z.state.ambient, Vt.lightProbe.value = z.state.probe, Vt.directionalLights.value = z.state.directional, Vt.directionalLightShadows.value = z.state.directionalShadow, Vt.spotLights.value = z.state.spot, Vt.spotLightShadows.value = z.state.spotShadow, Vt.rectAreaLights.value = z.state.rectArea, Vt.ltc_1.value = z.state.rectAreaLTC1, Vt.ltc_2.value = z.state.rectAreaLTC2, Vt.pointLights.value = z.state.point, Vt.pointLightShadows.value = z.state.pointShadow, Vt.hemisphereLights.value = z.state.hemi, Vt.directionalShadowMap.value = z.state.directionalShadowMap, Vt.directionalShadowMatrix.value = z.state.directionalShadowMatrix, Vt.spotShadowMap.value = z.state.spotShadowMap, Vt.spotLightMatrix.value = z.state.spotLightMatrix, Vt.spotLightMap.value = z.state.spotLightMap, Vt.pointShadowMap.value = z.state.pointShadowMap, Vt.pointShadowMatrix.value = z.state.pointShadowMatrix), W.currentProgram = Ft, W.uniformsList = null, Ft
        }
        function Ke(w) {
            if (w.uniformsList === null) {
                const U = w.currentProgram.getUniforms();
                w.uniformsList = Zl.seqWithValue(U.seq, w.uniforms)
            }
            return w.uniformsList
        }
        function De(w, U) {
            const X = Lt.get(w);
            X.outputColorSpace = U.outputColorSpace,
            X.batching = U.batching,
            X.batchingColor = U.batchingColor,
            X.instancing = U.instancing,
            X.instancingColor = U.instancingColor,
            X.instancingMorph = U.instancingMorph,
            X.skinning = U.skinning,
            X.morphTargets = U.morphTargets,
            X.morphNormals = U.morphNormals,
            X.morphColors = U.morphColors,
            X.morphTargetsCount = U.morphTargetsCount,
            X.numClippingPlanes = U.numClippingPlanes,
            X.numIntersection = U.numClipIntersection,
            X.vertexAlphas = U.vertexAlphas,
            X.vertexTangents = U.vertexTangents,
            X.toneMapping = U.toneMapping
        }
        function Ce(w, U, X, W, z) {
            U.isScene !== !0 && (U = Nt),
            kt.resetTextureUnits();
            const ot = U.fog,
                mt = W.isMeshStandardMaterial ? U.environment : null,
                bt = T === null ? v.outputColorSpace : T.isXRRenderTarget === !0 ? T.texture.colorSpace : dn,
                gt = (W.isMeshStandardMaterial ? b : L).get(W.envMap || mt),
                Et = W.vertexColors === !0 && !!X.attributes.color && X.attributes.color.itemSize === 4,
                Ft = !!X.attributes.tangent && (!!W.normalMap || W.anisotropy > 0),
                Vt = !!X.morphAttributes.position,
                fe = !!X.morphAttributes.normal,
                Ee = !!X.morphAttributes.color;
            let pe = Xs;
            W.toneMapped && (T === null || T.isXRRenderTarget === !0) && (pe = v.toneMapping);
            const je = X.morphAttributes.position || X.morphAttributes.normal || X.morphAttributes.color,
                ce = je !== void 0 ? je.length : 0,
                Rt = Lt.get(W),
                cn = g.state.lights;
            if (J === !0 && (it === !0 || w !== E)) {
                const ai = w === E && W.id === R;
                Ot.setState(W, w, ai)
            }
            let ge = !1;
            W.version === Rt.__version ? (Rt.needsLights && Rt.lightsStateVersion !== cn.state.version || Rt.outputColorSpace !== bt || z.isBatchedMesh && Rt.batching === !1 || !z.isBatchedMesh && Rt.batching === !0 || z.isBatchedMesh && Rt.batchingColor === !0 && z.colorTexture === null || z.isBatchedMesh && Rt.batchingColor === !1 && z.colorTexture !== null || z.isInstancedMesh && Rt.instancing === !1 || !z.isInstancedMesh && Rt.instancing === !0 || z.isSkinnedMesh && Rt.skinning === !1 || !z.isSkinnedMesh && Rt.skinning === !0 || z.isInstancedMesh && Rt.instancingColor === !0 && z.instanceColor === null || z.isInstancedMesh && Rt.instancingColor === !1 && z.instanceColor !== null || z.isInstancedMesh && Rt.instancingMorph === !0 && z.morphTexture === null || z.isInstancedMesh && Rt.instancingMorph === !1 && z.morphTexture !== null || Rt.envMap !== gt || W.fog === !0 && Rt.fog !== ot || Rt.numClippingPlanes !== void 0 && (Rt.numClippingPlanes !== Ot.numPlanes || Rt.numIntersection !== Ot.numIntersection) || Rt.vertexAlphas !== Et || Rt.vertexTangents !== Ft || Rt.morphTargets !== Vt || Rt.morphNormals !== fe || Rt.morphColors !== Ee || Rt.toneMapping !== pe || Rt.morphTargetsCount !== ce) && (ge = !0) : (ge = !0, Rt.__version = W.version);
            let xi = Rt.currentProgram;
            ge === !0 && (xi = Ae(W, U, z));
            let Dr = !1,
                $n = !1,
                Bc = !1;
            const Xe = xi.getUniforms(),
                Ss = Rt.uniforms;
            if (yt.useProgram(xi.program) && (Dr = !0, $n = !0, Bc = !0), W.id !== R && (R = W.id, $n = !0), Dr || E !== w) {
                Xe.setValue(N, "projectionMatrix", w.projectionMatrix),
                Xe.setValue(N, "viewMatrix", w.matrixWorldInverse);
                const ai = Xe.map.cameraPosition;
                ai !== void 0 && ai.setValue(N, ut.setFromMatrixPosition(w.matrixWorld)),
                jt.logarithmicDepthBuffer && Xe.setValue(N, "logDepthBufFC", 2 / (Math.log(w.far + 1) / Math.LN2)),
                (W.isMeshPhongMaterial || W.isMeshToonMaterial || W.isMeshLambertMaterial || W.isMeshBasicMaterial || W.isMeshStandardMaterial || W.isShaderMaterial) && Xe.setValue(N, "isOrthographic", w.isOrthographicCamera === !0),
                E !== w && (E = w, $n = !0, Bc = !0)
            }
            if (z.isSkinnedMesh) {
                Xe.setOptional(N, z, "bindMatrix"),
                Xe.setOptional(N, z, "bindMatrixInverse");
                const ai = z.skeleton;
                ai && (ai.boneTexture === null && ai.computeBoneTexture(), Xe.setValue(N, "boneTexture", ai.boneTexture, kt))
            }
            z.isBatchedMesh && (Xe.setOptional(N, z, "batchingTexture"), Xe.setValue(N, "batchingTexture", z._matricesTexture, kt), Xe.setOptional(N, z, "batchingIdTexture"), Xe.setValue(N, "batchingIdTexture", z._indirectTexture, kt), Xe.setOptional(N, z, "batchingColorTexture"), z._colorsTexture !== null && Xe.setValue(N, "batchingColorTexture", z._colorsTexture, kt));
            const kc = X.morphAttributes;
            if ((kc.position !== void 0 || kc.normal !== void 0 || kc.color !== void 0) && It.update(z, X, xi), ($n || Rt.receiveShadow !== z.receiveShadow) && (Rt.receiveShadow = z.receiveShadow, Xe.setValue(N, "receiveShadow", z.receiveShadow)), W.isMeshGouraudMaterial && W.envMap !== null && (Ss.envMap.value = gt, Ss.flipEnvMap.value = gt.isCubeTexture && gt.isRenderTargetTexture === !1 ? -1 : 1), W.isMeshStandardMaterial && W.envMap === null && U.environment !== null && (Ss.envMapIntensity.value = U.environmentIntensity), $n && (Xe.setValue(N, "toneMappingExposure", v.toneMappingExposure), Rt.needsLights && ve(Ss, Bc), ot && W.fog === !0 && At.refreshFogUniforms(Ss, ot), At.refreshMaterialUniforms(Ss, W, H, G, g.state.transmissionRenderTarget[w.id]), Zl.upload(N, Ke(Rt), Ss, kt)), W.isShaderMaterial && W.uniformsNeedUpdate === !0 && (Zl.upload(N, Ke(Rt), Ss, kt), W.uniformsNeedUpdate = !1), W.isSpriteMaterial && Xe.setValue(N, "center", z.center), Xe.setValue(N, "modelViewMatrix", z.modelViewMatrix), Xe.setValue(N, "normalMatrix", z.normalMatrix), Xe.setValue(N, "modelMatrix", z.matrixWorld), W.isShaderMaterial || W.isRawShaderMaterial) {
                const ai = W.uniformsGroups;
                for (let Hc = 0, z0 = ai.length; Hc < z0; Hc++) {
                    const yf = ai[Hc];
                    de.update(yf, xi),
                    de.bind(yf, xi)
                }
            }
            return xi
        }
        function ve(w, U) {
            w.ambientLightColor.needsUpdate = U,
            w.lightProbe.needsUpdate = U,
            w.directionalLights.needsUpdate = U,
            w.directionalLightShadows.needsUpdate = U,
            w.pointLights.needsUpdate = U,
            w.pointLightShadows.needsUpdate = U,
            w.spotLights.needsUpdate = U,
            w.spotLightShadows.needsUpdate = U,
            w.rectAreaLights.needsUpdate = U,
            w.hemisphereLights.needsUpdate = U
        }
        function Yn(w) {
            return w.isMeshLambertMaterial || w.isMeshToonMaterial || w.isMeshPhongMaterial || w.isMeshStandardMaterial || w.isShadowMaterial || w.isShaderMaterial && w.lights === !0
        }
        this.getActiveCubeFace = function() {
            return C
        },
        this.getActiveMipmapLevel = function() {
            return A
        },
        this.getRenderTarget = function() {
            return T
        },
        this.setRenderTargetTextures = function(w, U, X) {
            Lt.get(w.texture).__webglTexture = U,
            Lt.get(w.depthTexture).__webglTexture = X;
            const W = Lt.get(w);
            W.__hasExternalTextures = !0,
            W.__autoAllocateDepthBuffer = X === void 0,
            W.__autoAllocateDepthBuffer || Bt.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), W.__useRenderToTexture = !1)
        },
        this.setRenderTargetFramebuffer = function(w, U) {
            const X = Lt.get(w);
            X.__webglFramebuffer = U,
            X.__useDefaultFramebuffer = U === void 0
        },
        this.setRenderTarget = function(w, U=0, X=0) {
            T = w,
            C = U,
            A = X;
            let W = !0,
                z = null,
                ot = !1,
                mt = !1;
            if (w) {
                const gt = Lt.get(w);
                gt.__useDefaultFramebuffer !== void 0 ? (yt.bindFramebuffer(N.FRAMEBUFFER, null), W = !1) : gt.__webglFramebuffer === void 0 ? kt.setupRenderTarget(w) : gt.__hasExternalTextures && kt.rebindTextures(w, Lt.get(w.texture).__webglTexture, Lt.get(w.depthTexture).__webglTexture);
                const Et = w.texture;
                (Et.isData3DTexture || Et.isDataArrayTexture || Et.isCompressedArrayTexture) && (mt = !0);
                const Ft = Lt.get(w).__webglFramebuffer;
                w.isWebGLCubeRenderTarget ? (Array.isArray(Ft[U]) ? z = Ft[U][X] : z = Ft[U], ot = !0) : w.samples > 0 && kt.useMultisampledRTT(w) === !1 ? z = Lt.get(w).__webglMultisampledFramebuffer : Array.isArray(Ft) ? z = Ft[X] : z = Ft,
                M.copy(w.viewport),
                D.copy(w.scissor),
                I = w.scissorTest
            } else
                M.copy(P).multiplyScalar(H).floor(),
                D.copy(ct).multiplyScalar(H).floor(),
                I = Ut;
            if (yt.bindFramebuffer(N.FRAMEBUFFER, z) && W && yt.drawBuffers(w, z), yt.viewport(M), yt.scissor(D), yt.setScissorTest(I), ot) {
                const gt = Lt.get(w.texture);
                N.framebufferTexture2D(N.FRAMEBUFFER, N.COLOR_ATTACHMENT0, N.TEXTURE_CUBE_MAP_POSITIVE_X + U, gt.__webglTexture, X)
            } else if (mt) {
                const gt = Lt.get(w.texture),
                    Et = U || 0;
                N.framebufferTextureLayer(N.FRAMEBUFFER, N.COLOR_ATTACHMENT0, gt.__webglTexture, X || 0, Et)
            }
            R = -1
        },
        this.readRenderTargetPixels = function(w, U, X, W, z, ot, mt) {
            if (!(w && w.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let bt = Lt.get(w).__webglFramebuffer;
            if (w.isWebGLCubeRenderTarget && mt !== void 0 && (bt = bt[mt]), bt) {
                yt.bindFramebuffer(N.FRAMEBUFFER, bt);
                try {
                    const gt = w.texture,
                        Et = gt.format,
                        Ft = gt.type;
                    if (!jt.textureFormatReadable(Et)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!jt.textureTypeReadable(Ft)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    U >= 0 && U <= w.width - W && X >= 0 && X <= w.height - z && N.readPixels(U, X, W, z, Wt.convert(Et), Wt.convert(Ft), ot)
                } finally {
                    const gt = T !== null ? Lt.get(T).__webglFramebuffer : null;
                    yt.bindFramebuffer(N.FRAMEBUFFER, gt)
                }
            }
        },
        this.readRenderTargetPixelsAsync = async function(w, U, X, W, z, ot, mt) {
            if (!(w && w.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let bt = Lt.get(w).__webglFramebuffer;
            if (w.isWebGLCubeRenderTarget && mt !== void 0 && (bt = bt[mt]), bt) {
                yt.bindFramebuffer(N.FRAMEBUFFER, bt);
                try {
                    const gt = w.texture,
                        Et = gt.format,
                        Ft = gt.type;
                    if (!jt.textureFormatReadable(Et))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!jt.textureTypeReadable(Ft))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    if (U >= 0 && U <= w.width - W && X >= 0 && X <= w.height - z) {
                        const Vt = N.createBuffer();
                        N.bindBuffer(N.PIXEL_PACK_BUFFER, Vt),
                        N.bufferData(N.PIXEL_PACK_BUFFER, ot.byteLength, N.STREAM_READ),
                        N.readPixels(U, X, W, z, Wt.convert(Et), Wt.convert(Ft), 0),
                        N.flush();
                        const fe = N.fenceSync(N.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        await nv(N, fe, 4);
                        try {
                            N.bindBuffer(N.PIXEL_PACK_BUFFER, Vt),
                            N.getBufferSubData(N.PIXEL_PACK_BUFFER, 0, ot)
                        } finally {
                            N.deleteBuffer(Vt),
                            N.deleteSync(fe)
                        }
                        return ot
                    }
                } finally {
                    const gt = T !== null ? Lt.get(T).__webglFramebuffer : null;
                    yt.bindFramebuffer(N.FRAMEBUFFER, gt)
                }
            }
        },
        this.copyFramebufferToTexture = function(w, U=null, X=0) {
            w.isTexture !== !0 && (po("WebGLRenderer: copyFramebufferToTexture function signature has changed."), U = arguments[0] || null, w = arguments[1]);
            const W = Math.pow(2, -X),
                z = Math.floor(w.image.width * W),
                ot = Math.floor(w.image.height * W),
                mt = U !== null ? U.x : 0,
                bt = U !== null ? U.y : 0;
            kt.setTexture2D(w, 0),
            N.copyTexSubImage2D(N.TEXTURE_2D, X, 0, 0, mt, bt, z, ot),
            yt.unbindTexture()
        },
        this.copyTextureToTexture = function(w, U, X=null, W=null, z=0) {
            w.isTexture !== !0 && (po("WebGLRenderer: copyTextureToTexture function signature has changed."), W = arguments[0] || null, w = arguments[1], U = arguments[2], z = arguments[3] || 0, X = null);
            let ot,
                mt,
                bt,
                gt,
                Et,
                Ft;
            X !== null ? (ot = X.max.x - X.min.x, mt = X.max.y - X.min.y, bt = X.min.x, gt = X.min.y) : (ot = w.image.width, mt = w.image.height, bt = 0, gt = 0),
            W !== null ? (Et = W.x, Ft = W.y) : (Et = 0, Ft = 0);
            const Vt = Wt.convert(U.format),
                fe = Wt.convert(U.type);
            kt.setTexture2D(U, 0),
            N.pixelStorei(N.UNPACK_FLIP_Y_WEBGL, U.flipY),
            N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, U.premultiplyAlpha),
            N.pixelStorei(N.UNPACK_ALIGNMENT, U.unpackAlignment);
            const Ee = N.getParameter(N.UNPACK_ROW_LENGTH),
                pe = N.getParameter(N.UNPACK_IMAGE_HEIGHT),
                je = N.getParameter(N.UNPACK_SKIP_PIXELS),
                ce = N.getParameter(N.UNPACK_SKIP_ROWS),
                Rt = N.getParameter(N.UNPACK_SKIP_IMAGES),
                cn = w.isCompressedTexture ? w.mipmaps[z] : w.image;
            N.pixelStorei(N.UNPACK_ROW_LENGTH, cn.width),
            N.pixelStorei(N.UNPACK_IMAGE_HEIGHT, cn.height),
            N.pixelStorei(N.UNPACK_SKIP_PIXELS, bt),
            N.pixelStorei(N.UNPACK_SKIP_ROWS, gt),
            w.isDataTexture ? N.texSubImage2D(N.TEXTURE_2D, z, Et, Ft, ot, mt, Vt, fe, cn.data) : w.isCompressedTexture ? N.compressedTexSubImage2D(N.TEXTURE_2D, z, Et, Ft, cn.width, cn.height, Vt, cn.data) : N.texSubImage2D(N.TEXTURE_2D, z, Et, Ft, ot, mt, Vt, fe, cn),
            N.pixelStorei(N.UNPACK_ROW_LENGTH, Ee),
            N.pixelStorei(N.UNPACK_IMAGE_HEIGHT, pe),
            N.pixelStorei(N.UNPACK_SKIP_PIXELS, je),
            N.pixelStorei(N.UNPACK_SKIP_ROWS, ce),
            N.pixelStorei(N.UNPACK_SKIP_IMAGES, Rt),
            z === 0 && U.generateMipmaps && N.generateMipmap(N.TEXTURE_2D),
            yt.unbindTexture()
        },
        this.copyTextureToTexture3D = function(w, U, X=null, W=null, z=0) {
            w.isTexture !== !0 && (po("WebGLRenderer: copyTextureToTexture3D function signature has changed."), X = arguments[0] || null, W = arguments[1] || null, w = arguments[2], U = arguments[3], z = arguments[4] || 0);
            let ot,
                mt,
                bt,
                gt,
                Et,
                Ft,
                Vt,
                fe,
                Ee;
            const pe = w.isCompressedTexture ? w.mipmaps[z] : w.image;
            X !== null ? (ot = X.max.x - X.min.x, mt = X.max.y - X.min.y, bt = X.max.z - X.min.z, gt = X.min.x, Et = X.min.y, Ft = X.min.z) : (ot = pe.width, mt = pe.height, bt = pe.depth, gt = 0, Et = 0, Ft = 0),
            W !== null ? (Vt = W.x, fe = W.y, Ee = W.z) : (Vt = 0, fe = 0, Ee = 0);
            const je = Wt.convert(U.format),
                ce = Wt.convert(U.type);
            let Rt;
            if (U.isData3DTexture)
                kt.setTexture3D(U, 0),
                Rt = N.TEXTURE_3D;
            else if (U.isDataArrayTexture || U.isCompressedArrayTexture)
                kt.setTexture2DArray(U, 0),
                Rt = N.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            N.pixelStorei(N.UNPACK_FLIP_Y_WEBGL, U.flipY),
            N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, U.premultiplyAlpha),
            N.pixelStorei(N.UNPACK_ALIGNMENT, U.unpackAlignment);
            const cn = N.getParameter(N.UNPACK_ROW_LENGTH),
                ge = N.getParameter(N.UNPACK_IMAGE_HEIGHT),
                xi = N.getParameter(N.UNPACK_SKIP_PIXELS),
                Dr = N.getParameter(N.UNPACK_SKIP_ROWS),
                $n = N.getParameter(N.UNPACK_SKIP_IMAGES);
            N.pixelStorei(N.UNPACK_ROW_LENGTH, pe.width),
            N.pixelStorei(N.UNPACK_IMAGE_HEIGHT, pe.height),
            N.pixelStorei(N.UNPACK_SKIP_PIXELS, gt),
            N.pixelStorei(N.UNPACK_SKIP_ROWS, Et),
            N.pixelStorei(N.UNPACK_SKIP_IMAGES, Ft),
            w.isDataTexture || w.isData3DTexture ? N.texSubImage3D(Rt, z, Vt, fe, Ee, ot, mt, bt, je, ce, pe.data) : U.isCompressedArrayTexture ? N.compressedTexSubImage3D(Rt, z, Vt, fe, Ee, ot, mt, bt, je, pe.data) : N.texSubImage3D(Rt, z, Vt, fe, Ee, ot, mt, bt, je, ce, pe),
            N.pixelStorei(N.UNPACK_ROW_LENGTH, cn),
            N.pixelStorei(N.UNPACK_IMAGE_HEIGHT, ge),
            N.pixelStorei(N.UNPACK_SKIP_PIXELS, xi),
            N.pixelStorei(N.UNPACK_SKIP_ROWS, Dr),
            N.pixelStorei(N.UNPACK_SKIP_IMAGES, $n),
            z === 0 && U.generateMipmaps && N.generateMipmap(Rt),
            yt.unbindTexture()
        },
        this.initRenderTarget = function(w) {
            Lt.get(w).__webglFramebuffer === void 0 && kt.setupRenderTarget(w)
        },
        this.initTexture = function(w) {
            w.isCubeTexture ? kt.setTextureCube(w, 0) : w.isData3DTexture ? kt.setTexture3D(w, 0) : w.isDataArrayTexture || w.isCompressedArrayTexture ? kt.setTexture2DArray(w, 0) : kt.setTexture2D(w, 0),
            yt.unbindTexture()
        },
        this.resetState = function() {
            C = 0,
            A = 0,
            T = null,
            yt.reset(),
            Yt.reset()
        },
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    get coordinateSystem()
    {
        return us
    }
    get outputColorSpace()
    {
        return this._outputColorSpace
    }
    set outputColorSpace(t)
    {
        this._outputColorSpace = t;
        const e = this.getContext();
        e.drawingBufferColorSpace = t === Md ? "display-p3" : "srgb",
        e.unpackColorSpace = me.workingColorSpace === Pc ? "display-p3" : "srgb"
    }
}
class Ag extends He {
    constructor()
    {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Xi,
        this.environmentIntensity = 1,
        this.environmentRotation = new Xi,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(t, e)
    {
        return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
    }
    toJSON(t)
    {
        const e = super.toJSON(t);
        return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e
    }
}
class hE {
    constructor(t, e)
    {
        this.isInterleavedBuffer = !0,
        this.array = t,
        this.stride = e,
        this.count = t !== void 0 ? t.length / e : 0,
        this.usage = Eu,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.version = 0,
        this.uuid = Ri()
    }
    onUploadCallback() {}
    set needsUpdate(t)
    {
        t === !0 && this.version++
    }
    get updateRange()
    {
        return po("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
    }
    setUsage(t)
    {
        return this.usage = t, this
    }
    addUpdateRange(t, e)
    {
        this.updateRanges.push({
            start: t,
            count: e
        })
    }
    clearUpdateRanges()
    {
        this.updateRanges.length = 0
    }
    copy(t)
    {
        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
    }
    copyAt(t, e, n)
    {
        t *= this.stride,
        n *= e.stride;
        for (let i = 0, s = this.stride; i < s; i++)
            this.array[t + i] = e.array[n + i];
        return this
    }
    set(t, e=0)
    {
        return this.array.set(t, e), this
    }
    clone(t)
    {
        t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ri()),
        t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
            n = new this.constructor(e, this.stride);
        return n.setUsage(this.usage), n
    }
    onUpload(t)
    {
        return this.onUploadCallback = t, this
    }
    toJSON(t)
    {
        return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ri()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const En = new O;
class bd {
    constructor(t, e, n, i=!1)
    {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = t,
        this.itemSize = e,
        this.offset = n,
        this.normalized = i
    }
    get count()
    {
        return this.data.count
    }
    get array()
    {
        return this.data.array
    }
    set needsUpdate(t)
    {
        this.data.needsUpdate = t
    }
    applyMatrix4(t)
    {
        for (let e = 0, n = this.data.count; e < n; e++)
            En.fromBufferAttribute(this, e),
            En.applyMatrix4(t),
            this.setXYZ(e, En.x, En.y, En.z);
        return this
    }
    applyNormalMatrix(t)
    {
        for (let e = 0, n = this.count; e < n; e++)
            En.fromBufferAttribute(this, e),
            En.applyNormalMatrix(t),
            this.setXYZ(e, En.x, En.y, En.z);
        return this
    }
    transformDirection(t)
    {
        for (let e = 0, n = this.count; e < n; e++)
            En.fromBufferAttribute(this, e),
            En.transformDirection(t),
            this.setXYZ(e, En.x, En.y, En.z);
        return this
    }
    getComponent(t, e)
    {
        let n = this.array[t * this.data.stride + this.offset + e];
        return this.normalized && (n = Ai(n, this.array)), n
    }
    setComponent(t, e, n)
    {
        return this.normalized && (n = ye(n, this.array)), this.data.array[t * this.data.stride + this.offset + e] = n, this
    }
    setX(t, e)
    {
        return this.normalized && (e = ye(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
    }
    setY(t, e)
    {
        return this.normalized && (e = ye(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
    }
    setZ(t, e)
    {
        return this.normalized && (e = ye(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
    }
    setW(t, e)
    {
        return this.normalized && (e = ye(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
    }
    getX(t)
    {
        let e = this.data.array[t * this.data.stride + this.offset];
        return this.normalized && (e = Ai(e, this.array)), e
    }
    getY(t)
    {
        let e = this.data.array[t * this.data.stride + this.offset + 1];
        return this.normalized && (e = Ai(e, this.array)), e
    }
    getZ(t)
    {
        let e = this.data.array[t * this.data.stride + this.offset + 2];
        return this.normalized && (e = Ai(e, this.array)), e
    }
    getW(t)
    {
        let e = this.data.array[t * this.data.stride + this.offset + 3];
        return this.normalized && (e = Ai(e, this.array)), e
    }
    setXY(t, e, n)
    {
        return t = t * this.data.stride + this.offset, this.normalized && (e = ye(e, this.array), n = ye(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
    }
    setXYZ(t, e, n, i)
    {
        return t = t * this.data.stride + this.offset, this.normalized && (e = ye(e, this.array), n = ye(n, this.array), i = ye(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
    }
    setXYZW(t, e, n, i, s)
    {
        return t = t * this.data.stride + this.offset, this.normalized && (e = ye(e, this.array), n = ye(n, this.array), i = ye(i, this.array), s = ye(s, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = s, this
    }
    clone(t)
    {
        if (t === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const e = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    e.push(this.data.array[i + s])
            }
            return new zn(new this.array.constructor(e), this.itemSize, this.normalized)
        } else
            return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new bd(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(t)
    {
        if (t === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const e = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    e.push(this.data.array[i + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: e,
                normalized: this.normalized
            }
        } else
            return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
const Mp = new O,
    Sp = new Pe,
    Tp = new Pe,
    uE = new O,
    Ep = new le,
    Ml = new O,
    ph = new $i,
    bp = new le,
    mh = new Ya;
class dE extends Un {
    constructor(t, e)
    {
        super(t, e),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = bf,
        this.bindMatrix = new le,
        this.bindMatrixInverse = new le,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox()
    {
        const t = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Ms),
        this.boundingBox.makeEmpty();
        const e = t.getAttribute("position");
        for (let n = 0; n < e.count; n++)
            this.getVertexPosition(n, Ml),
            this.boundingBox.expandByPoint(Ml)
    }
    computeBoundingSphere()
    {
        const t = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new $i),
        this.boundingSphere.makeEmpty();
        const e = t.getAttribute("position");
        for (let n = 0; n < e.count; n++)
            this.getVertexPosition(n, Ml),
            this.boundingSphere.expandByPoint(Ml)
    }
    copy(t, e)
    {
        return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this
    }
    raycast(t, e)
    {
        const n = this.material,
            i = this.matrixWorld;
        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), ph.copy(this.boundingSphere), ph.applyMatrix4(i), t.ray.intersectsSphere(ph) !== !1 && (bp.copy(i).invert(), mh.copy(t.ray).applyMatrix4(bp), !(this.boundingBox !== null && mh.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(t, e, mh)))
    }
    getVertexPosition(t, e)
    {
        return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
    }
    bind(t, e)
    {
        this.skeleton = t,
        e === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld),
        this.bindMatrix.copy(e),
        this.bindMatrixInverse.copy(e).invert()
    }
    pose()
    {
        this.skeleton.pose()
    }
    normalizeSkinWeights()
    {
        const t = new Pe,
            e = this.geometry.attributes.skinWeight;
        for (let n = 0, i = e.count; n < i; n++) {
            t.fromBufferAttribute(e, n);
            const s = 1 / t.manhattanLength();
            s !== 1 / 0 ? t.multiplyScalar(s) : t.set(1, 0, 0, 0),
            e.setXYZW(n, t.x, t.y, t.z, t.w)
        }
    }
    updateMatrixWorld(t)
    {
        super.updateMatrixWorld(t),
        this.bindMode === bf ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === wx ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(t, e)
    {
        const n = this.skeleton,
            i = this.geometry;
        Sp.fromBufferAttribute(i.attributes.skinIndex, t),
        Tp.fromBufferAttribute(i.attributes.skinWeight, t),
        Mp.copy(e).applyMatrix4(this.bindMatrix),
        e.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = Tp.getComponent(s);
            if (o !== 0) {
                const a = Sp.getComponent(s);
                Ep.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                e.addScaledVector(uE.copy(Mp).applyMatrix4(Ep), o)
            }
        }
        return e.applyMatrix4(this.bindMatrixInverse)
    }
}
class Cg extends He {
    constructor()
    {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Rg extends an {
    constructor(t=null, e=1, n=1, i, s, o, a, l, c=Fn, h=Fn, u, d)
    {
        super(null, o, a, l, c, h, i, s, u, d),
        this.isDataTexture = !0,
        this.image = {
            data: t,
            width: e,
            height: n
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const wp = new le,
    fE = new le;
class wd {
    constructor(t=[], e=[])
    {
        this.uuid = Ri(),
        this.bones = t.slice(0),
        this.boneInverses = e,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init()
    {
        const t = this.bones,
            e = this.boneInverses;
        if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0)
            this.calculateInverses();
        else if (t.length !== e.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let n = 0, i = this.bones.length; n < i; n++)
                this.boneInverses.push(new le)
        }
    }
    calculateInverses()
    {
        this.boneInverses.length = 0;
        for (let t = 0, e = this.bones.length; t < e; t++) {
            const n = new le;
            this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(),
            this.boneInverses.push(n)
        }
    }
    pose()
    {
        for (let t = 0, e = this.bones.length; t < e; t++) {
            const n = this.bones[t];
            n && n.matrixWorld.copy(this.boneInverses[t]).invert()
        }
        for (let t = 0, e = this.bones.length; t < e; t++) {
            const n = this.bones[t];
            n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale))
        }
    }
    update()
    {
        const t = this.bones,
            e = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
        for (let s = 0, o = t.length; s < o; s++) {
            const a = t[s] ? t[s].matrixWorld : fE;
            wp.multiplyMatrices(a, e[s]),
            wp.toArray(n, s * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone()
    {
        return new wd(this.bones, this.boneInverses)
    }
    computeBoneTexture()
    {
        let t = Math.sqrt(this.bones.length * 4);
        t = Math.ceil(t / 4) * 4,
        t = Math.max(t, 4);
        const e = new Float32Array(t * t * 4);
        e.set(this.boneMatrices);
        const n = new Rg(e, t, t, fi, Ci);
        return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this
    }
    getBoneByName(t)
    {
        for (let e = 0, n = this.bones.length; e < n; e++) {
            const i = this.bones[e];
            if (i.name === t)
                return i
        }
    }
    dispose()
    {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
    }
    fromJSON(t, e)
    {
        this.uuid = t.uuid;
        for (let n = 0, i = t.bones.length; n < i; n++) {
            const s = t.bones[n];
            let o = e[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new Cg),
            this.bones.push(o),
            this.boneInverses.push(new le().fromArray(t.boneInverses[n]))
        }
        return this.init(), this
    }
    toJSON()
    {
        const t = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        t.uuid = this.uuid;
        const e = this.bones,
            n = this.boneInverses;
        for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i];
            t.bones.push(o.uuid);
            const a = n[i];
            t.boneInverses.push(a.toArray())
        }
        return t
    }
}
class Au extends zn {
    constructor(t, e, n, i=1)
    {
        super(t, e, n),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = i
    }
    copy(t)
    {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
    }
    toJSON()
    {
        const t = super.toJSON();
        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
    }
}
const Jr = new le,
    Ap = new le,
    Sl = [],
    Cp = new Ms,
    pE = new le,
    jo = new Un,
    Zo = new $i;
class mE extends Un {
    constructor(t, e, n)
    {
        super(t, e),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new Au(new Float32Array(n * 16), 16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = n,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let i = 0; i < n; i++)
            this.setMatrixAt(i, pE)
    }
    computeBoundingBox()
    {
        const t = this.geometry,
            e = this.count;
        this.boundingBox === null && (this.boundingBox = new Ms),
        t.boundingBox === null && t.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let n = 0; n < e; n++)
            this.getMatrixAt(n, Jr),
            Cp.copy(t.boundingBox).applyMatrix4(Jr),
            this.boundingBox.union(Cp)
    }
    computeBoundingSphere()
    {
        const t = this.geometry,
            e = this.count;
        this.boundingSphere === null && (this.boundingSphere = new $i),
        t.boundingSphere === null && t.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let n = 0; n < e; n++)
            this.getMatrixAt(n, Jr),
            Zo.copy(t.boundingSphere).applyMatrix4(Jr),
            this.boundingSphere.union(Zo)
    }
    copy(t, e)
    {
        return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this
    }
    getColorAt(t, e)
    {
        e.fromArray(this.instanceColor.array, t * 3)
    }
    getMatrixAt(t, e)
    {
        e.fromArray(this.instanceMatrix.array, t * 16)
    }
    getMorphAt(t, e)
    {
        const n = e.morphTargetInfluences,
            i = this.morphTexture.source.data.data,
            s = n.length + 1,
            o = t * s + 1;
        for (let a = 0; a < n.length; a++)
            n[a] = i[o + a]
    }
    raycast(t, e)
    {
        const n = this.matrixWorld,
            i = this.count;
        if (jo.geometry = this.geometry, jo.material = this.material, jo.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Zo.copy(this.boundingSphere), Zo.applyMatrix4(n), t.ray.intersectsSphere(Zo) !== !1))
            for (let s = 0; s < i; s++) {
                this.getMatrixAt(s, Jr),
                Ap.multiplyMatrices(n, Jr),
                jo.matrixWorld = Ap,
                jo.raycast(t, Sl);
                for (let o = 0, a = Sl.length; o < a; o++) {
                    const l = Sl[o];
                    l.instanceId = s,
                    l.object = this,
                    e.push(l)
                }
                Sl.length = 0
            }
    }
    setColorAt(t, e)
    {
        this.instanceColor === null && (this.instanceColor = new Au(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)),
        e.toArray(this.instanceColor.array, t * 3)
    }
    setMatrixAt(t, e)
    {
        e.toArray(this.instanceMatrix.array, t * 16)
    }
    setMorphAt(t, e)
    {
        const n = e.morphTargetInfluences,
            i = n.length + 1;
        this.morphTexture === null && (this.morphTexture = new Rg(new Float32Array(i * this.count), i, this.count, gd, Ci));
        const s = this.morphTexture.source.data.data;
        let o = 0;
        for (let c = 0; c < n.length; c++)
            o += n[c];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
            l = i * t;
        s[l] = a,
        s.set(n, l + 1)
    }
    updateMorphTargets() {}
    dispose()
    {
        return this.dispatchEvent({
            type: "dispose"
        }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this
    }
}
class Pg extends Li {
    constructor(t)
    {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Gt(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(t)
    }
    copy(t)
    {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
    }
}
const mc = new O,
    gc = new O,
    Rp = new le,
    Jo = new Ya,
    Tl = new $i,
    gh = new O,
    Pp = new O;
class Ad extends He {
    constructor(t=new Ni, e=new Pg)
    {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = t,
        this.material = e,
        this.updateMorphTargets()
    }
    copy(t, e)
    {
        return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
    }
    computeLineDistances()
    {
        const t = this.geometry;
        if (t.index === null) {
            const e = t.attributes.position,
                n = [0];
            for (let i = 1, s = e.count; i < s; i++)
                mc.fromBufferAttribute(e, i - 1),
                gc.fromBufferAttribute(e, i),
                n[i] = n[i - 1],
                n[i] += mc.distanceTo(gc);
            t.setAttribute("lineDistance", new Di(n, 1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(t, e)
    {
        const n = this.geometry,
            i = this.matrixWorld,
            s = t.params.Line.threshold,
            o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(), Tl.copy(n.boundingSphere), Tl.applyMatrix4(i), Tl.radius += s, t.ray.intersectsSphere(Tl) === !1)
            return;
        Rp.copy(i).invert(),
        Jo.copy(t.ray).applyMatrix4(Rp);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = this.isLineSegments ? 2 : 1,
            h = n.index,
            d = n.attributes.position;
        if (h !== null) {
            const f = Math.max(0, o.start),
                m = Math.min(h.count, o.start + o.count);
            for (let _ = f, g = m - 1; _ < g; _ += c) {
                const p = h.getX(_),
                    x = h.getX(_ + 1),
                    v = El(this, t, Jo, l, p, x);
                v && e.push(v)
            }
            if (this.isLineLoop) {
                const _ = h.getX(m - 1),
                    g = h.getX(f),
                    p = El(this, t, Jo, l, _, g);
                p && e.push(p)
            }
        } else {
            const f = Math.max(0, o.start),
                m = Math.min(d.count, o.start + o.count);
            for (let _ = f, g = m - 1; _ < g; _ += c) {
                const p = El(this, t, Jo, l, _, _ + 1);
                p && e.push(p)
            }
            if (this.isLineLoop) {
                const _ = El(this, t, Jo, l, m - 1, f);
                _ && e.push(_)
            }
        }
    }
    updateMorphTargets()
    {
        const e = this.geometry.morphAttributes,
            n = Object.keys(e);
        if (n.length > 0) {
            const i = e[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function El(r, t, e, n, i, s) {
    const o = r.geometry.attributes.position;
    if (mc.fromBufferAttribute(o, i), gc.fromBufferAttribute(o, s), e.distanceSqToSegment(mc, gc, gh, Pp) > n)
        return;
    gh.applyMatrix4(r.matrixWorld);
    const l = t.ray.origin.distanceTo(gh);
    if (!(l < t.near || l > t.far))
        return {
            distance: l,
            point: Pp.clone().applyMatrix4(r.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: r
        }
}
const Lp = new O,
    Dp = new O;
class gE extends Ad {
    constructor(t, e)
    {
        super(t, e),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances()
    {
        const t = this.geometry;
        if (t.index === null) {
            const e = t.attributes.position,
                n = [];
            for (let i = 0, s = e.count; i < s; i += 2)
                Lp.fromBufferAttribute(e, i),
                Dp.fromBufferAttribute(e, i + 1),
                n[i] = i === 0 ? 0 : n[i - 1],
                n[i + 1] = n[i] + Lp.distanceTo(Dp);
            t.setAttribute("lineDistance", new Di(n, 1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class _E extends Ad {
    constructor(t, e)
    {
        super(t, e),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class Lg extends Li {
    constructor(t)
    {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Gt(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(t)
    }
    copy(t)
    {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
    }
}
const Np = new le,
    Cu = new Ya,
    bl = new $i,
    wl = new O;
class xE extends He {
    constructor(t=new Ni, e=new Lg)
    {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = t,
        this.material = e,
        this.updateMorphTargets()
    }
    copy(t, e)
    {
        return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
    }
    raycast(t, e)
    {
        const n = this.geometry,
            i = this.matrixWorld,
            s = t.params.Points.threshold,
            o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(), bl.copy(n.boundingSphere), bl.applyMatrix4(i), bl.radius += s, t.ray.intersectsSphere(bl) === !1)
            return;
        Np.copy(i).invert(),
        Cu.copy(t.ray).applyMatrix4(Np);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = n.index,
            u = n.attributes.position;
        if (c !== null) {
            const d = Math.max(0, o.start),
                f = Math.min(c.count, o.start + o.count);
            for (let m = d, _ = f; m < _; m++) {
                const g = c.getX(m);
                wl.fromBufferAttribute(u, g),
                Ip(wl, g, l, i, t, e, this)
            }
        } else {
            const d = Math.max(0, o.start),
                f = Math.min(u.count, o.start + o.count);
            for (let m = d, _ = f; m < _; m++)
                wl.fromBufferAttribute(u, m),
                Ip(wl, m, l, i, t, e, this)
        }
    }
    updateMorphTargets()
    {
        const e = this.geometry.morphAttributes,
            n = Object.keys(e);
        if (n.length > 0) {
            const i = e[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function Ip(r, t, e, n, i, s, o) {
    const a = Cu.distanceSqToPoint(r);
    if (a < e) {
        const l = new O;
        Cu.closestPointToPoint(r, l),
        l.applyMatrix4(n);
        const c = i.ray.origin.distanceTo(l);
        if (c < i.near || c > i.far)
            return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: t,
            face: null,
            object: o
        })
    }
}
class Cd extends Li {
    constructor(t)
    {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Gt(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Gt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = yd,
        this.normalScale = new St(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Xi,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(t)
    }
    copy(t)
    {
        return super.copy(t), this.defines = {
            STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}
class qi extends Cd {
    constructor(t)
    {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new St(1, 1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return hn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(e) {
                this.ior = (1 + .4 * e) / (1 - .4 * e)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Gt(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Gt(1, 1, 1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Gt(1, 1, 1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._dispersion = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(t)
    }
    get anisotropy()
    {
        return this._anisotropy
    }
    set anisotropy(t)
    {
        this._anisotropy > 0 != t > 0 && this.version++,
        this._anisotropy = t
    }
    get clearcoat()
    {
        return this._clearcoat
    }
    set clearcoat(t)
    {
        this._clearcoat > 0 != t > 0 && this.version++,
        this._clearcoat = t
    }
    get iridescence()
    {
        return this._iridescence
    }
    set iridescence(t)
    {
        this._iridescence > 0 != t > 0 && this.version++,
        this._iridescence = t
    }
    get dispersion()
    {
        return this._dispersion
    }
    set dispersion(t)
    {
        this._dispersion > 0 != t > 0 && this.version++,
        this._dispersion = t
    }
    get sheen()
    {
        return this._sheen
    }
    set sheen(t)
    {
        this._sheen > 0 != t > 0 && this.version++,
        this._sheen = t
    }
    get transmission()
    {
        return this._transmission
    }
    set transmission(t)
    {
        this._transmission > 0 != t > 0 && this.version++,
        this._transmission = t
    }
    copy(t)
    {
        return super.copy(t), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.dispersion = t.dispersion, this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
    }
}
class vE extends Li {
    constructor(t)
    {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Gt(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = yd,
        this.normalScale = new St(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(t)
    }
    copy(t)
    {
        return super.copy(t), this.defines = {
            MATCAP: ""
        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}
function Al(r, t, e) {
    return !r || !e && r.constructor === t ? r : typeof t.BYTES_PER_ELEMENT == "number" ? new t(r) : Array.prototype.slice.call(r)
}
function yE(r) {
    return ArrayBuffer.isView(r) && !(r instanceof DataView)
}
function ME(r) {
    function t(i, s) {
        return r[i] - r[s]
    }
    const e = r.length,
        n = new Array(e);
    for (let i = 0; i !== e; ++i)
        n[i] = i;
    return n.sort(t), n
}
function Fp(r, t, e) {
    const n = r.length,
        i = new r.constructor(n);
    for (let s = 0, o = 0; o !== n; ++s) {
        const a = e[s] * t;
        for (let l = 0; l !== t; ++l)
            i[o++] = r[a + l]
    }
    return i
}
function Dg(r, t, e, n) {
    let i = 1,
        s = r[0];
    for (; s !== void 0 && s[n] === void 0;)
        s = r[i++];
    if (s === void 0)
        return;
    let o = s[n];
    if (o !== void 0)
        if (Array.isArray(o))
            do o = s[n],
            o !== void 0 && (t.push(s.time), e.push.apply(e, o)),
            s = r[i++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do o = s[n],
            o !== void 0 && (t.push(s.time), o.toArray(e, e.length)),
            s = r[i++];
            while (s !== void 0);
        else
            do o = s[n],
            o !== void 0 && (t.push(s.time), e.push(o)),
            s = r[i++];
            while (s !== void 0)
}
class Ka {
    constructor(t, e, n, i)
    {
        this.parameterPositions = t,
        this._cachedIndex = 0,
        this.resultBuffer = i !== void 0 ? i : new e.constructor(n),
        this.sampleValues = e,
        this.valueSize = n,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(t)
    {
        const e = this.parameterPositions;
        let n = this._cachedIndex,
            i = e[n],
            s = e[n - 1];
        n:
        {
            t:
            {
                let o;
                e:
                {
                    i:
                    if (!(t < i)) {
                        for (let a = n + 2; ;) {
                            if (i === void 0) {
                                if (t < s)
                                    break i;
                                return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                            }
                            if (n === a)
                                break;
                            if (s = i, i = e[++n], t < i)
                                break t
                        }
                        o = e.length;
                        break e
                    }
                    if (!(t >= s)) {
                        const a = e[1];
                        t < a && (n = 2, s = a);
                        for (let l = n - 2; ;) {
                            if (s === void 0)
                                return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (n === l)
                                break;
                            if (i = s, s = e[--n - 1], t >= s)
                                break t
                        }
                        o = n,
                        n = 0;
                        break e
                    }
                    break n
                }for (; n < o;) {
                    const a = n + o >>> 1;
                    t < e[a] ? o = a : n = a + 1
                }
                if (i = e[n], s = e[n - 1], s === void 0)
                    return this._cachedIndex = 0, this.copySampleValue_(0);
                if (i === void 0)
                    return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
            }this._cachedIndex = n,
            this.intervalChanged_(n, s, i)
        }return this.interpolate_(n, s, t, i)
    }
    getSettings_()
    {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(t)
    {
        const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            s = t * i;
        for (let o = 0; o !== i; ++o)
            e[o] = n[s + o];
        return e
    }
    interpolate_()
    {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class SE extends Ka {
    constructor(t, e, n, i)
    {
        super(t, e, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: wf,
            endingEnd: wf
        }
    }
    intervalChanged_(t, e, n)
    {
        const i = this.parameterPositions;
        let s = t - 2,
            o = t + 1,
            a = i[s],
            l = i[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case Af:
                s = t,
                a = 2 * e - n;
                break;
            case Cf:
                s = i.length - 2,
                a = e + i[s] - i[s + 1];
                break;
            default:
                s = t,
                a = n
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case Af:
                o = t,
                l = 2 * n - e;
                break;
            case Cf:
                o = 1,
                l = n + i[1] - i[0];
                break;
            default:
                o = t - 1,
                l = e
            }
        const c = (n - e) * .5,
            h = this.valueSize;
        this._weightPrev = c / (e - a),
        this._weightNext = c / (l - n),
        this._offsetPrev = s * h,
        this._offsetNext = o * h
    }
    interpolate_(t, e, n, i)
    {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = t * a,
            c = l - a,
            h = this._offsetPrev,
            u = this._offsetNext,
            d = this._weightPrev,
            f = this._weightNext,
            m = (n - e) / (i - e),
            _ = m * m,
            g = _ * m,
            p = -d * g + 2 * d * _ - d * m,
            x = (1 + d) * g + (-1.5 - 2 * d) * _ + (-.5 + d) * m + 1,
            v = (-1 - f) * g + (1.5 + f) * _ + .5 * m,
            y = f * g - f * _;
        for (let C = 0; C !== a; ++C)
            s[C] = p * o[h + C] + x * o[c + C] + v * o[l + C] + y * o[u + C];
        return s
    }
}
class TE extends Ka {
    constructor(t, e, n, i)
    {
        super(t, e, n, i)
    }
    interpolate_(t, e, n, i)
    {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = t * a,
            c = l - a,
            h = (n - e) / (i - e),
            u = 1 - h;
        for (let d = 0; d !== a; ++d)
            s[d] = o[c + d] * u + o[l + d] * h;
        return s
    }
}
class EE extends Ka {
    constructor(t, e, n, i)
    {
        super(t, e, n, i)
    }
    interpolate_(t)
    {
        return this.copySampleValue_(t - 1)
    }
}
class Ki {
    constructor(t, e, n, i)
    {
        if (t === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (e === void 0 || e.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t,
        this.times = Al(e, this.TimeBufferType),
        this.values = Al(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(t)
    {
        const e = t.constructor;
        let n;
        if (e.toJSON !== this.toJSON)
            n = e.toJSON(t);
        else {
            n = {
                name: t.name,
                times: Al(t.times, Array),
                values: Al(t.values, Array)
            };
            const i = t.getInterpolation();
            i !== t.DefaultInterpolation && (n.interpolation = i)
        }
        return n.type = t.ValueTypeName, n
    }
    InterpolantFactoryMethodDiscrete(t)
    {
        return new EE(this.times, this.values, this.getValueSize(), t)
    }
    InterpolantFactoryMethodLinear(t)
    {
        return new TE(this.times, this.values, this.getValueSize(), t)
    }
    InterpolantFactoryMethodSmooth(t)
    {
        return new SE(this.times, this.values, this.getValueSize(), t)
    }
    setInterpolation(t)
    {
        let e;
        switch (t) {
        case Da:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
        case Na:
            e = this.InterpolantFactoryMethodLinear;
            break;
        case Vc:
            e = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (e === void 0) {
            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (t !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n), this
        }
        return this.createInterpolant = e, this
    }
    getInterpolation()
    {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return Da;
        case this.InterpolantFactoryMethodLinear:
            return Na;
        case this.InterpolantFactoryMethodSmooth:
            return Vc
        }
    }
    getValueSize()
    {
        return this.values.length / this.times.length
    }
    shift(t)
    {
        if (t !== 0) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n)
                e[n] += t
        }
        return this
    }
    scale(t)
    {
        if (t !== 1) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n)
                e[n] *= t
        }
        return this
    }
    trim(t, e)
    {
        const n = this.times,
            i = n.length;
        let s = 0,
            o = i - 1;
        for (; s !== i && n[s] < t;)
            ++s;
        for (; o !== -1 && n[o] > e;)
            --o;
        if (++o, s !== 0 || o !== i) {
            s >= o && (o = Math.max(o, 1), s = o - 1);
            const a = this.getValueSize();
            this.times = n.slice(s, o),
            this.values = this.values.slice(s * a, o * a)
        }
        return this
    }
    validate()
    {
        let t = !0;
        const e = this.getValueSize();
        e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
        const n = this.times,
            i = this.values,
            s = n.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                t = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                t = !1;
                break
            }
            o = l
        }
        if (i !== void 0 && yE(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
                const c = i[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c),
                    t = !1;
                    break
                }
            }
        return t
    }
    optimize()
    {
        const t = this.times.slice(),
            e = this.values.slice(),
            n = this.getValueSize(),
            i = this.getInterpolation() === Vc,
            s = t.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = t[a],
                h = t[a + 1];
            if (c !== h && (a !== 1 || c !== t[0]))
                if (i)
                    l = !0;
                else {
                    const u = a * n,
                        d = u - n,
                        f = u + n;
                    for (let m = 0; m !== n; ++m) {
                        const _ = e[u + m];
                        if (_ !== e[d + m] || _ !== e[f + m]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    t[o] = t[a];
                    const u = a * n,
                        d = o * n;
                    for (let f = 0; f !== n; ++f)
                        e[d + f] = e[u + f]
                }
                ++o
            }
        }
        if (s > 0) {
            t[o] = t[s];
            for (let a = s * n, l = o * n, c = 0; c !== n; ++c)
                e[l + c] = e[a + c];
            ++o
        }
        return o !== t.length ? (this.times = t.slice(0, o), this.values = e.slice(0, o * n)) : (this.times = t, this.values = e), this
    }
    clone()
    {
        const t = this.times.slice(),
            e = this.values.slice(),
            n = this.constructor,
            i = new n(this.name, t, e);
        return i.createInterpolant = this.createInterpolant, i
    }
}
Ki.prototype.TimeBufferType = Float32Array;
Ki.prototype.ValueBufferType = Float32Array;
Ki.prototype.DefaultInterpolation = Na;
class Ho extends Ki {
    constructor(t, e, n)
    {
        super(t, e, n)
    }
}
Ho.prototype.ValueTypeName = "bool";
Ho.prototype.ValueBufferType = Array;
Ho.prototype.DefaultInterpolation = Da;
Ho.prototype.InterpolantFactoryMethodLinear = void 0;
Ho.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ng extends Ki {}
Ng.prototype.ValueTypeName = "color";
class Po extends Ki {}
Po.prototype.ValueTypeName = "number";
class bE extends Ka {
    constructor(t, e, n, i)
    {
        super(t, e, n, i)
    }
    interpolate_(t, e, n, i)
    {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (n - e) / (i - e);
        let c = t * a;
        for (let h = c + a; c !== h; c += 4)
            Wi.slerpFlat(s, 0, o, c - a, o, c, l);
        return s
    }
}
class Lo extends Ki {
    InterpolantFactoryMethodLinear(t)
    {
        return new bE(this.times, this.values, this.getValueSize(), t)
    }
}
Lo.prototype.ValueTypeName = "quaternion";
Lo.prototype.InterpolantFactoryMethodSmooth = void 0;
class Vo extends Ki {
    constructor(t, e, n)
    {
        super(t, e, n)
    }
}
Vo.prototype.ValueTypeName = "string";
Vo.prototype.ValueBufferType = Array;
Vo.prototype.DefaultInterpolation = Da;
Vo.prototype.InterpolantFactoryMethodLinear = void 0;
Vo.prototype.InterpolantFactoryMethodSmooth = void 0;
class Do extends Ki {}
Do.prototype.ValueTypeName = "vector";
class wE {
    constructor(t="", e=-1, n=[], i=Ax)
    {
        this.name = t,
        this.tracks = n,
        this.duration = e,
        this.blendMode = i,
        this.uuid = Ri(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(t)
    {
        const e = [],
            n = t.tracks,
            i = 1 / (t.fps || 1);
        for (let o = 0, a = n.length; o !== a; ++o)
            e.push(CE(n[o]).scale(i));
        const s = new this(t.name, t.duration, e, t.blendMode);
        return s.uuid = t.uuid, s
    }
    static toJSON(t)
    {
        const e = [],
            n = t.tracks,
            i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode
            };
        for (let s = 0, o = n.length; s !== o; ++s)
            e.push(Ki.toJSON(n[s]));
        return i
    }
    static CreateFromMorphTargetSequence(t, e, n, i)
    {
        const s = e.length,
            o = [];
        for (let a = 0; a < s; a++) {
            let l = [],
                c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s),
            c.push(0, 1, 0);
            const h = ME(l);
            l = Fp(l, 1, h),
            c = Fp(c, 1, h),
            !i && l[0] === 0 && (l.push(s), c.push(c[0])),
            o.push(new Po(".morphTargetInfluences[" + e[a].name + "]", l, c).scale(1 / n))
        }
        return new this(t, -1, o)
    }
    static findByName(t, e)
    {
        let n = t;
        if (!Array.isArray(t)) {
            const i = t;
            n = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < n.length; i++)
            if (n[i].name === e)
                return n[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(t, e, n)
    {
        const i = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = t.length; a < l; a++) {
            const c = t[a],
                h = c.name.match(s);
            if (h && h.length > 1) {
                const u = h[1];
                let d = i[u];
                d || (i[u] = d = []),
                d.push(c)
            }
        }
        const o = [];
        for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], e, n));
        return o
    }
    static parseAnimation(t, e)
    {
        if (!t)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const n = function(u, d, f, m, _) {
                if (f.length !== 0) {
                    const g = [],
                        p = [];
                    Dg(f, g, p, m),
                    g.length !== 0 && _.push(new u(d, g, p))
                }
            },
            i = [],
            s = t.name || "default",
            o = t.fps || 30,
            a = t.blendMode;
        let l = t.length || -1;
        const c = t.hierarchy || [];
        for (let u = 0; u < c.length; u++) {
            const d = c[u].keys;
            if (!(!d || d.length === 0))
                if (d[0].morphTargets) {
                    const f = {};
                    let m;
                    for (m = 0; m < d.length; m++)
                        if (d[m].morphTargets)
                            for (let _ = 0; _ < d[m].morphTargets.length; _++)
                                f[d[m].morphTargets[_]] = -1;
                    for (const _ in f) {
                        const g = [],
                            p = [];
                        for (let x = 0; x !== d[m].morphTargets.length; ++x) {
                            const v = d[m];
                            g.push(v.time),
                            p.push(v.morphTarget === _ ? 1 : 0)
                        }
                        i.push(new Po(".morphTargetInfluence[" + _ + "]", g, p))
                    }
                    l = f.length * o
                } else {
                    const f = ".bones[" + e[u].name + "]";
                    n(Do, f + ".position", d, "pos", i),
                    n(Lo, f + ".quaternion", d, "rot", i),
                    n(Do, f + ".scale", d, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(s, l, i, a)
    }
    resetDuration()
    {
        const t = this.tracks;
        let e = 0;
        for (let n = 0, i = t.length; n !== i; ++n) {
            const s = this.tracks[n];
            e = Math.max(e, s.times[s.times.length - 1])
        }
        return this.duration = e, this
    }
    trim()
    {
        for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration);
        return this
    }
    validate()
    {
        let t = !0;
        for (let e = 0; e < this.tracks.length; e++)
            t = t && this.tracks[e].validate();
        return t
    }
    optimize()
    {
        for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].optimize();
        return this
    }
    clone()
    {
        const t = [];
        for (let e = 0; e < this.tracks.length; e++)
            t.push(this.tracks[e].clone());
        return new this.constructor(this.name, this.duration, t, this.blendMode)
    }
    toJSON()
    {
        return this.constructor.toJSON(this)
    }
}
function AE(r) {
    switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return Po;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return Do;
    case "color":
        return Ng;
    case "quaternion":
        return Lo;
    case "bool":
    case "boolean":
        return Ho;
    case "string":
        return Vo
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
}
function CE(r) {
    if (r.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const t = AE(r.type);
    if (r.times === void 0) {
        const e = [],
            n = [];
        Dg(r.keys, e, n, "value"),
        r.times = e,
        r.values = n
    }
    return t.parse !== void 0 ? t.parse(r) : new t(r.name, r.times, r.values, r.interpolation)
}
const Bs = {
    enabled: !1,
    files: {},
    add: function(r, t) {
        this.enabled !== !1 && (this.files[r] = t)
    },
    get: function(r) {
        if (this.enabled !== !1)
            return this.files[r]
    },
    remove: function(r) {
        delete this.files[r]
    },
    clear: function() {
        this.files = {}
    }
};
class RE {
    constructor(t, e, n)
    {
        const i = this;
        let s = !1,
            o = 0,
            a = 0,
            l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = t,
        this.onProgress = e,
        this.onError = n,
        this.itemStart = function(h) {
            a++,
            s === !1 && i.onStart !== void 0 && i.onStart(h, o, a),
            s = !0
        },
        this.itemEnd = function(h) {
            o++,
            i.onProgress !== void 0 && i.onProgress(h, o, a),
            o === a && (s = !1, i.onLoad !== void 0 && i.onLoad())
        },
        this.itemError = function(h) {
            i.onError !== void 0 && i.onError(h)
        },
        this.resolveURL = function(h) {
            return l ? l(h) : h
        },
        this.setURLModifier = function(h) {
            return l = h, this
        },
        this.addHandler = function(h, u) {
            return c.push(h, u), this
        },
        this.removeHandler = function(h) {
            const u = c.indexOf(h);
            return u !== -1 && c.splice(u, 2), this
        },
        this.getHandler = function(h) {
            for (let u = 0, d = c.length; u < d; u += 2) {
                const f = c[u],
                    m = c[u + 1];
                if (f.global && (f.lastIndex = 0), f.test(h))
                    return m
            }
            return null
        }
    }
}
const PE = new RE;
class Go {
    constructor(t)
    {
        this.manager = t !== void 0 ? t : PE,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(t, e)
    {
        const n = this;
        return new Promise(function(i, s) {
            n.load(t, i, e, s)
        })
    }
    parse() {}
    setCrossOrigin(t)
    {
        return this.crossOrigin = t, this
    }
    setWithCredentials(t)
    {
        return this.withCredentials = t, this
    }
    setPath(t)
    {
        return this.path = t, this
    }
    setResourcePath(t)
    {
        return this.resourcePath = t, this
    }
    setRequestHeader(t)
    {
        return this.requestHeader = t, this
    }
}
Go.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const is = {};
class LE extends Error {
    constructor(t, e)
    {
        super(t),
        this.response = e
    }
}
class Ig extends Go {
    constructor(t)
    {
        super(t)
    }
    load(t, e, n, i)
    {
        t === void 0 && (t = ""),
        this.path !== void 0 && (t = this.path + t),
        t = this.manager.resolveURL(t);
        const s = Bs.get(t);
        if (s !== void 0)
            return this.manager.itemStart(t), setTimeout(() => {
                e && e(s),
                this.manager.itemEnd(t)
            }, 0), s;
        if (is[t] !== void 0) {
            is[t].push({
                onLoad: e,
                onProgress: n,
                onError: i
            });
            return
        }
        is[t] = [],
        is[t].push({
            onLoad: e,
            onProgress: n,
            onError: i
        });
        const o = new Request(t, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }),
            a = this.mimeType,
            l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                    return c;
                const h = is[t],
                    u = c.body.getReader(),
                    d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
                    f = d ? parseInt(d) : 0,
                    m = f !== 0;
                let _ = 0;
                const g = new ReadableStream({
                    start(p) {
                        x();
                        function x() {
                            u.read().then(({done: v, value: y}) => {
                                if (v)
                                    p.close();
                                else {
                                    _ += y.byteLength;
                                    const C = new ProgressEvent("progress", {
                                        lengthComputable: m,
                                        loaded: _,
                                        total: f
                                    });
                                    for (let A = 0, T = h.length; A < T; A++) {
                                        const R = h[A];
                                        R.onProgress && R.onProgress(C)
                                    }
                                    p.enqueue(y),
                                    x()
                                }
                            }, v => {
                                p.error(v)
                            })
                        }
                    }
                });
                return new Response(g)
            } else
                throw new LE(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c)
        }).then(c => {
            switch (l) {
            case "arraybuffer":
                return c.arrayBuffer();
            case "blob":
                return c.blob();
            case "document":
                return c.text().then(h => new DOMParser().parseFromString(h, a));
            case "json":
                return c.json();
            default:
                if (a === void 0)
                    return c.text();
                {
                    const u = /charset="?([^;"\s]*)"?/i.exec(a),
                        d = u && u[1] ? u[1].toLowerCase() : void 0,
                        f = new TextDecoder(d);
                    return c.arrayBuffer().then(m => f.decode(m))
                }
            }
        }).then(c => {
            Bs.add(t, c);
            const h = is[t];
            delete is[t];
            for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onLoad && f.onLoad(c)
            }
        }).catch(c => {
            const h = is[t];
            if (h === void 0)
                throw this.manager.itemError(t), c;
            delete is[t];
            for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onError && f.onError(c)
            }
            this.manager.itemError(t)
        }).finally(() => {
            this.manager.itemEnd(t)
        }),
        this.manager.itemStart(t)
    }
    setResponseType(t)
    {
        return this.responseType = t, this
    }
    setMimeType(t)
    {
        return this.mimeType = t, this
    }
}
class DE extends Go {
    constructor(t)
    {
        super(t)
    }
    load(t, e, n, i)
    {
        this.path !== void 0 && (t = this.path + t),
        t = this.manager.resolveURL(t);
        const s = this,
            o = Bs.get(t);
        if (o !== void 0)
            return s.manager.itemStart(t), setTimeout(function() {
                e && e(o),
                s.manager.itemEnd(t)
            }, 0), o;
        const a = Ia("img");
        function l() {
            h(),
            Bs.add(t, this),
            e && e(this),
            s.manager.itemEnd(t)
        }
        function c(u) {
            h(),
            i && i(u),
            s.manager.itemError(t),
            s.manager.itemEnd(t)
        }
        function h() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(t), a.src = t, a
    }
}
class Fg extends Go {
    constructor(t)
    {
        super(t)
    }
    load(t, e, n, i)
    {
        const s = new an,
            o = new DE(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            e !== void 0 && e(s)
        }, n, i), s
    }
}
class Rd extends He {
    constructor(t, e=1)
    {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Gt(t),
        this.intensity = e
    }
    dispose() {}
    copy(t, e)
    {
        return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
    }
    toJSON(t)
    {
        const e = super.toJSON(t);
        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e
    }
}
const _h = new le,
    Up = new O,
    Op = new O;
class Pd {
    constructor(t)
    {
        this.camera = t,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new St(512, 512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new le,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Td,
        this._frameExtents = new St(1, 1),
        this._viewportCount = 1,
        this._viewports = [new Pe(0, 0, 1, 1)]
    }
    getViewportCount()
    {
        return this._viewportCount
    }
    getFrustum()
    {
        return this._frustum
    }
    updateMatrices(t)
    {
        const e = this.camera,
            n = this.matrix;
        Up.setFromMatrixPosition(t.matrixWorld),
        e.position.copy(Up),
        Op.setFromMatrixPosition(t.target.matrixWorld),
        e.lookAt(Op),
        e.updateMatrixWorld(),
        _h.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(_h),
        n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        n.multiply(_h)
    }
    getViewport(t)
    {
        return this._viewports[t]
    }
    getFrameExtents()
    {
        return this._frameExtents
    }
    dispose()
    {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(t)
    {
        return this.camera = t.camera.clone(), this.intensity = t.intensity, this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
    toJSON()
    {
        const t = {};
        return this.intensity !== 1 && (t.intensity = this.intensity), this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
    }
}
class NE extends Pd {
    constructor()
    {
        super(new yn(50, 1, .5, 500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(t)
    {
        const e = this.camera,
            n = Co * 2 * t.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            s = t.distance || e.far;
        (n !== e.fov || i !== e.aspect || s !== e.far) && (e.fov = n, e.aspect = i, e.far = s, e.updateProjectionMatrix()),
        super.updateMatrices(t)
    }
    copy(t)
    {
        return super.copy(t), this.focus = t.focus, this
    }
}
class IE extends Rd {
    constructor(t, e, n=0, i=Math.PI / 3, s=0, o=2)
    {
        super(t, e),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(He.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new He,
        this.distance = n,
        this.angle = i,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new NE
    }
    get power()
    {
        return this.intensity * Math.PI
    }
    set power(t)
    {
        this.intensity = t / Math.PI
    }
    dispose()
    {
        this.shadow.dispose()
    }
    copy(t, e)
    {
        return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}
const zp = new le,
    Qo = new O,
    xh = new O;
class FE extends Pd {
    constructor()
    {
        super(new yn(90, 1, .5, 500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new St(4, 2),
        this._viewportCount = 6,
        this._viewports = [new Pe(2, 1, 1, 1), new Pe(0, 1, 1, 1), new Pe(3, 1, 1, 1), new Pe(1, 1, 1, 1), new Pe(3, 0, 1, 1), new Pe(1, 0, 1, 1)],
        this._cubeDirections = [new O(1, 0, 0), new O(-1, 0, 0), new O(0, 0, 1), new O(0, 0, -1), new O(0, 1, 0), new O(0, -1, 0)],
        this._cubeUps = [new O(0, 1, 0), new O(0, 1, 0), new O(0, 1, 0), new O(0, 1, 0), new O(0, 0, 1), new O(0, 0, -1)]
    }
    updateMatrices(t, e=0)
    {
        const n = this.camera,
            i = this.matrix,
            s = t.distance || n.far;
        s !== n.far && (n.far = s, n.updateProjectionMatrix()),
        Qo.setFromMatrixPosition(t.matrixWorld),
        n.position.copy(Qo),
        xh.copy(n.position),
        xh.add(this._cubeDirections[e]),
        n.up.copy(this._cubeUps[e]),
        n.lookAt(xh),
        n.updateMatrixWorld(),
        i.makeTranslation(-Qo.x, -Qo.y, -Qo.z),
        zp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(zp)
    }
}
class UE extends Rd {
    constructor(t, e, n=0, i=2)
    {
        super(t, e),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = n,
        this.decay = i,
        this.shadow = new FE
    }
    get power()
    {
        return this.intensity * 4 * Math.PI
    }
    set power(t)
    {
        this.intensity = t / (4 * Math.PI)
    }
    dispose()
    {
        this.shadow.dispose()
    }
    copy(t, e)
    {
        return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
    }
}
class OE extends Pd {
    constructor()
    {
        super(new Lc(-5, 5, 5, -5, .5, 500)),
        this.isDirectionalLightShadow = !0
    }
}
class zE extends Rd {
    constructor(t, e)
    {
        super(t, e),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(He.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new He,
        this.shadow = new OE
    }
    dispose()
    {
        this.shadow.dispose()
    }
    copy(t)
    {
        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}
class ga {
    static decodeText(t)
    {
        if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u")
            return new TextDecoder().decode(t);
        let e = "";
        for (let n = 0, i = t.length; n < i; n++)
            e += String.fromCharCode(t[n]);
        try {
            return decodeURIComponent(escape(e))
        } catch {
            return e
        }
    }
    static extractUrlBase(t)
    {
        const e = t.lastIndexOf("/");
        return e === -1 ? "./" : t.slice(0, e + 1)
    }
    static resolveURL(t, e)
    {
        return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
    }
}
class BE extends Go {
    constructor(t)
    {
        super(t),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(t)
    {
        return this.options = t, this
    }
    load(t, e, n, i)
    {
        t === void 0 && (t = ""),
        this.path !== void 0 && (t = this.path + t),
        t = this.manager.resolveURL(t);
        const s = this,
            o = Bs.get(t);
        if (o !== void 0) {
            if (s.manager.itemStart(t), o.then) {
                o.then(c => {
                    e && e(c),
                    s.manager.itemEnd(t)
                }).catch(c => {
                    i && i(c)
                });
                return
            }
            return setTimeout(function() {
                e && e(o),
                s.manager.itemEnd(t)
            }, 0), o
        }
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader;
        const l = fetch(t, a).then(function(c) {
            return c.blob()
        }).then(function(c) {
            return createImageBitmap(c, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(c) {
            return Bs.add(t, c), e && e(c), s.manager.itemEnd(t), c
        }).catch(function(c) {
            i && i(c),
            Bs.remove(t),
            s.manager.itemError(t),
            s.manager.itemEnd(t)
        });
        Bs.add(t, l),
        s.manager.itemStart(t)
    }
}
class kE {
    constructor(t=!0)
    {
        this.autoStart = t,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start()
    {
        this.startTime = Bp(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop()
    {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime()
    {
        return this.getDelta(), this.elapsedTime
    }
    getDelta()
    {
        let t = 0;
        if (this.autoStart && !this.running)
            return this.start(), 0;
        if (this.running) {
            const e = Bp();
            t = (e - this.oldTime) / 1e3,
            this.oldTime = e,
            this.elapsedTime += t
        }
        return t
    }
}
function Bp() {
    return (typeof performance > "u" ? Date : performance).now()
}
const Ld = "\\[\\]\\.:\\/",
    HE = new RegExp("[" + Ld + "]", "g"),
    Dd = "[^" + Ld + "]",
    VE = "[^" + Ld.replace("\\.", "") + "]",
    GE = /((?:WC+[\/:])*)/.source.replace("WC", Dd),
    WE = /(WCOD+)?/.source.replace("WCOD", VE),
    XE = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Dd),
    YE = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Dd),
    $E = new RegExp("^" + GE + WE + XE + YE + "$"),
    qE = ["material", "materials", "bones", "map"];
class KE {
    constructor(t, e, n)
    {
        const i = n || Me.parseTrackName(e);
        this._targetGroup = t,
        this._bindings = t.subscribe_(e, i)
    }
    getValue(t, e)
    {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
        i !== void 0 && i.getValue(t, e)
    }
    setValue(t, e)
    {
        const n = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
            n[i].setValue(t, e)
    }
    bind()
    {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
            t[e].bind()
    }
    unbind()
    {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
            t[e].unbind()
    }
}
class Me {
    constructor(t, e, n)
    {
        this.path = e,
        this.parsedPath = n || Me.parseTrackName(e),
        this.node = Me.findNode(t, this.parsedPath.nodeName),
        this.rootNode = t,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(t, e, n)
    {
        return t && t.isAnimationObjectGroup ? new Me.Composite(t, e, n) : new Me(t, e, n)
    }
    static sanitizeNodeName(t)
    {
        return t.replace(/\s/g, "_").replace(HE, "")
    }
    static parseTrackName(t)
    {
        const e = $E.exec(t);
        if (e === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const s = n.nodeName.substring(i + 1);
            qE.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = s)
        }
        if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
        return n
    }
    static findNode(t, e)
    {
        if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid)
            return t;
        if (t.skeleton) {
            const n = t.skeleton.getBoneByName(e);
            if (n !== void 0)
                return n
        }
        if (t.children) {
            const n = function(s) {
                    for (let o = 0; o < s.length; o++) {
                        const a = s[o];
                        if (a.name === e || a.uuid === e)
                            return a;
                        const l = n(a.children);
                        if (l)
                            return l
                    }
                    return null
                },
                i = n(t.children);
            if (i)
                return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(t, e)
    {
        t[e] = this.targetObject[this.propertyName]
    }
    _getValue_array(t, e)
    {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            t[e++] = n[i]
    }
    _getValue_arrayElement(t, e)
    {
        t[e] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(t, e)
    {
        this.resolvedProperty.toArray(t, e)
    }
    _setValue_direct(t, e)
    {
        this.targetObject[this.propertyName] = t[e]
    }
    _setValue_direct_setNeedsUpdate(t, e)
    {
        this.targetObject[this.propertyName] = t[e],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e)
    {
        this.targetObject[this.propertyName] = t[e],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(t, e)
    {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            n[i] = t[e++]
    }
    _setValue_array_setNeedsUpdate(t, e)
    {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            n[i] = t[e++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e)
    {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i)
            n[i] = t[e++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(t, e)
    {
        this.resolvedProperty[this.propertyIndex] = t[e]
    }
    _setValue_arrayElement_setNeedsUpdate(t, e)
    {
        this.resolvedProperty[this.propertyIndex] = t[e],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e)
    {
        this.resolvedProperty[this.propertyIndex] = t[e],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(t, e)
    {
        this.resolvedProperty.fromArray(t, e)
    }
    _setValue_fromArray_setNeedsUpdate(t, e)
    {
        this.resolvedProperty.fromArray(t, e),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e)
    {
        this.resolvedProperty.fromArray(t, e),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(t, e)
    {
        this.bind(),
        this.getValue(t, e)
    }
    _setValue_unbound(t, e)
    {
        this.bind(),
        this.setValue(t, e)
    }
    bind()
    {
        let t = this.node;
        const e = this.parsedPath,
            n = e.objectName,
            i = e.propertyName;
        let s = e.propertyIndex;
        if (t || (t = Me.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (n) {
            let c = e.objectIndex;
            switch (n) {
            case "materials":
                if (!t.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!t.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                t = t.material.materials;
                break;
            case "bones":
                if (!t.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                t = t.skeleton.bones;
                for (let h = 0; h < t.length; h++)
                    if (t[h].name === c) {
                        c = h;
                        break
                    }
                break;
            case "map":
                if ("map" in t) {
                    t = t.map;
                    break
                }
                if (!t.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!t.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                t = t.material.map;
                break;
            default:
                if (t[n] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                t = t[n]
            }
            if (c !== void 0) {
                if (t[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                    return
                }
                t = t[c]
            }
        }
        const o = t[i];
        if (o === void 0) {
            const c = e.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", t);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = t,
        t.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!t.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!t.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                t.morphTargetDictionary[s] !== void 0 && (s = t.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind()
    {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
Me.Composite = KE;
Me.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
Me.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
Me.prototype.GetterByBindingType = [Me.prototype._getValue_direct, Me.prototype._getValue_array, Me.prototype._getValue_arrayElement, Me.prototype._getValue_toArray];
Me.prototype.SetterByBindingTypeAndVersioning = [[Me.prototype._setValue_direct, Me.prototype._setValue_direct_setNeedsUpdate, Me.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Me.prototype._setValue_array, Me.prototype._setValue_array_setNeedsUpdate, Me.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Me.prototype._setValue_arrayElement, Me.prototype._setValue_arrayElement_setNeedsUpdate, Me.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Me.prototype._setValue_fromArray, Me.prototype._setValue_fromArray_setNeedsUpdate, Me.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class kp {
    constructor(t=1, e=0, n=0)
    {
        return this.radius = t, this.phi = e, this.theta = n, this
    }
    set(t, e, n)
    {
        return this.radius = t, this.phi = e, this.theta = n, this
    }
    copy(t)
    {
        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
    }
    makeSafe()
    {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
    }
    setFromVector3(t)
    {
        return this.setFromCartesianCoords(t.x, t.y, t.z)
    }
    setFromCartesianCoords(t, e, n)
    {
        return this.radius = Math.sqrt(t * t + e * e + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(hn(e / this.radius, -1, 1))), this
    }
    clone()
    {
        return new this.constructor().copy(this)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: dd
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = dd);
const Hp = {
        type: "change"
    },
    vh = {
        type: "start"
    },
    Vp = {
        type: "end"
    },
    Cl = new Ya,
    Gp = new Fs,
    jE = Math.cos(70 * fc.DEG2RAD);
class ZE extends Rr {
    constructor(t, e)
    {
        super(),
        this.object = t,
        this.domElement = e,
        this.domElement.style.touchAction = "none",
        this.enabled = !0,
        this.target = new O,
        this.cursor = new O,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minTargetRadius = 0,
        this.maxTargetRadius = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.zoomToCursor = !1,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: Nr.ROTATE,
            MIDDLE: Nr.DOLLY,
            RIGHT: Nr.PAN
        },
        this.touches = {
            ONE: Ir.ROTATE,
            TWO: Ir.DOLLY_PAN
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this.getPolarAngle = function() {
            return a.phi
        },
        this.getAzimuthalAngle = function() {
            return a.theta
        },
        this.getDistance = function() {
            return this.object.position.distanceTo(this.target)
        },
        this.listenToKeyEvents = function(S) {
            S.addEventListener("keydown", dt),
            this._domElementKeyEvents = S
        },
        this.stopListenToKeyEvents = function() {
            this._domElementKeyEvents.removeEventListener("keydown", dt),
            this._domElementKeyEvents = null
        },
        this.saveState = function() {
            n.target0.copy(n.target),
            n.position0.copy(n.object.position),
            n.zoom0 = n.object.zoom
        },
        this.reset = function() {
            n.target.copy(n.target0),
            n.object.position.copy(n.position0),
            n.object.zoom = n.zoom0,
            n.object.updateProjectionMatrix(),
            n.dispatchEvent(Hp),
            n.update(),
            s = i.NONE
        },
        this.update = function() {
            const S = new O,
                F = new Wi().setFromUnitVectors(t.up, new O(0, 1, 0)),
                Y = F.clone().invert(),
                Z = new O,
                et = new Wi,
                Tt = new O,
                Ht = 2 * Math.PI;
            return function(xe=null) {
                const ne = n.object.position;
                S.copy(ne).sub(n.target),
                S.applyQuaternion(F),
                a.setFromVector3(S),
                n.autoRotate && s === i.NONE && I(M(xe)),
                n.enableDamping ? (a.theta += l.theta * n.dampingFactor, a.phi += l.phi * n.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
                let Ct = n.minAzimuthAngle,
                    Mt = n.maxAzimuthAngle;
                isFinite(Ct) && isFinite(Mt) && (Ct < -Math.PI ? Ct += Ht : Ct > Math.PI && (Ct -= Ht), Mt < -Math.PI ? Mt += Ht : Mt > Math.PI && (Mt -= Ht), Ct <= Mt ? a.theta = Math.max(Ct, Math.min(Mt, a.theta)) : a.theta = a.theta > (Ct + Mt) / 2 ? Math.max(Ct, a.theta) : Math.min(Mt, a.theta)),
                a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)),
                a.makeSafe(),
                n.enableDamping === !0 ? n.target.addScaledVector(h, n.dampingFactor) : n.target.add(h),
                n.target.sub(n.cursor),
                n.target.clampLength(n.minTargetRadius, n.maxTargetRadius),
                n.target.add(n.cursor);
                let Qt = !1;
                if (n.zoomToCursor && A || n.object.isOrthographicCamera)
                    a.radius = P(a.radius);
                else {
                    const ht = a.radius;
                    a.radius = P(a.radius * c),
                    Qt = ht != a.radius
                }
                if (S.setFromSpherical(a), S.applyQuaternion(Y), ne.copy(n.target).add(S), n.object.lookAt(n.target), n.enableDamping === !0 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, h.multiplyScalar(1 - n.dampingFactor)) : (l.set(0, 0, 0), h.set(0, 0, 0)), n.zoomToCursor && A) {
                    let ht = null;
                    if (n.object.isPerspectiveCamera) {
                        const $t = S.length();
                        ht = P($t * c);
                        const Dt = $t - ht;
                        n.object.position.addScaledVector(y, Dt),
                        n.object.updateMatrixWorld(),
                        Qt = !!Dt
                    } else if (n.object.isOrthographicCamera) {
                        const $t = new O(C.x, C.y, 0);
                        $t.unproject(n.object);
                        const Dt = n.object.zoom;
                        n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)),
                        n.object.updateProjectionMatrix(),
                        Qt = Dt !== n.object.zoom;
                        const qt = new O(C.x, C.y, 0);
                        qt.unproject(n.object),
                        n.object.position.sub(qt).add($t),
                        n.object.updateMatrixWorld(),
                        ht = S.length()
                    } else
                        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                        n.zoomToCursor = !1;
                    ht !== null && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(ht).add(n.object.position) : (Cl.origin.copy(n.object.position), Cl.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(Cl.direction)) < jE ? t.lookAt(n.target) : (Gp.setFromNormalAndCoplanarPoint(n.object.up, n.target), Cl.intersectPlane(Gp, n.target))))
                } else if (n.object.isOrthographicCamera) {
                    const ht = n.object.zoom;
                    n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)),
                    ht !== n.object.zoom && (n.object.updateProjectionMatrix(), Qt = !0)
                }
                return c = 1, A = !1, Qt || Z.distanceToSquared(n.object.position) > o || 8 * (1 - et.dot(n.object.quaternion)) > o || Tt.distanceToSquared(n.target) > o ? (n.dispatchEvent(Hp), Z.copy(n.object.position), et.copy(n.object.quaternion), Tt.copy(n.target), !0) : !1
            }
        }(),
        this.dispose = function() {
            n.domElement.removeEventListener("contextmenu", xt),
            n.domElement.removeEventListener("pointerdown", kt),
            n.domElement.removeEventListener("pointercancel", b),
            n.domElement.removeEventListener("wheel", rt),
            n.domElement.removeEventListener("pointermove", L),
            n.domElement.removeEventListener("pointerup", b),
            n.domElement.getRootNode().removeEventListener("keydown", At, {
                capture: !0
            }),
            n._domElementKeyEvents !== null && (n._domElementKeyEvents.removeEventListener("keydown", dt), n._domElementKeyEvents = null)
        };
        const n = this,
            i = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            };
        let s = i.NONE;
        const o = 1e-6,
            a = new kp,
            l = new kp;
        let c = 1;
        const h = new O,
            u = new St,
            d = new St,
            f = new St,
            m = new St,
            _ = new St,
            g = new St,
            p = new St,
            x = new St,
            v = new St,
            y = new O,
            C = new St;
        let A = !1;
        const T = [],
            R = {};
        let E = !1;
        function M(S) {
            return S !== null ? 2 * Math.PI / 60 * n.autoRotateSpeed * S : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
        }
        function D(S) {
            const F = Math.abs(S * .01);
            return Math.pow(.95, n.zoomSpeed * F)
        }
        function I(S) {
            l.theta -= S
        }
        function k(S) {
            l.phi -= S
        }
        const $ = function() {
                const S = new O;
                return function(Y, Z) {
                    S.setFromMatrixColumn(Z, 0),
                    S.multiplyScalar(-Y),
                    h.add(S)
                }
            }(),
            j = function() {
                const S = new O;
                return function(Y, Z) {
                    n.screenSpacePanning === !0 ? S.setFromMatrixColumn(Z, 1) : (S.setFromMatrixColumn(Z, 0), S.crossVectors(n.object.up, S)),
                    S.multiplyScalar(Y),
                    h.add(S)
                }
            }(),
            G = function() {
                const S = new O;
                return function(Y, Z) {
                    const et = n.domElement;
                    if (n.object.isPerspectiveCamera) {
                        const Tt = n.object.position;
                        S.copy(Tt).sub(n.target);
                        let Ht = S.length();
                        Ht *= Math.tan(n.object.fov / 2 * Math.PI / 180),
                        $(2 * Y * Ht / et.clientHeight, n.object.matrix),
                        j(2 * Z * Ht / et.clientHeight, n.object.matrix)
                    } else
                        n.object.isOrthographicCamera ? ($(Y * (n.object.right - n.object.left) / n.object.zoom / et.clientWidth, n.object.matrix), j(Z * (n.object.top - n.object.bottom) / n.object.zoom / et.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                }
            }();
        function H(S) {
            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c /= S : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
        }
        function V(S) {
            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c *= S : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
        }
        function nt(S, F) {
            if (!n.zoomToCursor)
                return;
            A = !0;
            const Y = n.domElement.getBoundingClientRect(),
                Z = S - Y.left,
                et = F - Y.top,
                Tt = Y.width,
                Ht = Y.height;
            C.x = Z / Tt * 2 - 1,
            C.y = -(et / Ht) * 2 + 1,
            y.set(C.x, C.y, 1).unproject(n.object).sub(n.object.position).normalize()
        }
        function P(S) {
            return Math.max(n.minDistance, Math.min(n.maxDistance, S))
        }
        function ct(S) {
            u.set(S.clientX, S.clientY)
        }
        function Ut(S) {
            nt(S.clientX, S.clientX),
            p.set(S.clientX, S.clientY)
        }
        function Zt(S) {
            m.set(S.clientX, S.clientY)
        }
        function J(S) {
            d.set(S.clientX, S.clientY),
            f.subVectors(d, u).multiplyScalar(n.rotateSpeed);
            const F = n.domElement;
            I(2 * Math.PI * f.x / F.clientHeight),
            k(2 * Math.PI * f.y / F.clientHeight),
            u.copy(d),
            n.update()
        }
        function it(S) {
            x.set(S.clientX, S.clientY),
            v.subVectors(x, p),
            v.y > 0 ? H(D(v.y)) : v.y < 0 && V(D(v.y)),
            p.copy(x),
            n.update()
        }
        function ft(S) {
            _.set(S.clientX, S.clientY),
            g.subVectors(_, m).multiplyScalar(n.panSpeed),
            G(g.x, g.y),
            m.copy(_),
            n.update()
        }
        function ut(S) {
            nt(S.clientX, S.clientY),
            S.deltaY < 0 ? V(D(S.deltaY)) : S.deltaY > 0 && H(D(S.deltaY)),
            n.update()
        }
        function Pt(S) {
            let F = !1;
            switch (S.code) {
            case n.keys.UP:
                S.ctrlKey || S.metaKey || S.shiftKey ? k(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : G(0, n.keyPanSpeed),
                F = !0;
                break;
            case n.keys.BOTTOM:
                S.ctrlKey || S.metaKey || S.shiftKey ? k(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : G(0, -n.keyPanSpeed),
                F = !0;
                break;
            case n.keys.LEFT:
                S.ctrlKey || S.metaKey || S.shiftKey ? I(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : G(n.keyPanSpeed, 0),
                F = !0;
                break;
            case n.keys.RIGHT:
                S.ctrlKey || S.metaKey || S.shiftKey ? I(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : G(-n.keyPanSpeed, 0),
                F = !0;
                break
            }
            F && (S.preventDefault(), n.update())
        }
        function Nt(S) {
            if (T.length === 1)
                u.set(S.pageX, S.pageY);
            else {
                const F = Yt(S),
                    Y = .5 * (S.pageX + F.x),
                    Z = .5 * (S.pageY + F.y);
                u.set(Y, Z)
            }
        }
        function Kt(S) {
            if (T.length === 1)
                m.set(S.pageX, S.pageY);
            else {
                const F = Yt(S),
                    Y = .5 * (S.pageX + F.x),
                    Z = .5 * (S.pageY + F.y);
                m.set(Y, Z)
            }
        }
        function Jt(S) {
            const F = Yt(S),
                Y = S.pageX - F.x,
                Z = S.pageY - F.y,
                et = Math.sqrt(Y * Y + Z * Z);
            p.set(0, et)
        }
        function N(S) {
            n.enableZoom && Jt(S),
            n.enablePan && Kt(S)
        }
        function zt(S) {
            n.enableZoom && Jt(S),
            n.enableRotate && Nt(S)
        }
        function Bt(S) {
            if (T.length == 1)
                d.set(S.pageX, S.pageY);
            else {
                const Y = Yt(S),
                    Z = .5 * (S.pageX + Y.x),
                    et = .5 * (S.pageY + Y.y);
                d.set(Z, et)
            }
            f.subVectors(d, u).multiplyScalar(n.rotateSpeed);
            const F = n.domElement;
            I(2 * Math.PI * f.x / F.clientHeight),
            k(2 * Math.PI * f.y / F.clientHeight),
            u.copy(d)
        }
        function jt(S) {
            if (T.length === 1)
                _.set(S.pageX, S.pageY);
            else {
                const F = Yt(S),
                    Y = .5 * (S.pageX + F.x),
                    Z = .5 * (S.pageY + F.y);
                _.set(Y, Z)
            }
            g.subVectors(_, m).multiplyScalar(n.panSpeed),
            G(g.x, g.y),
            m.copy(_)
        }
        function yt(S) {
            const F = Yt(S),
                Y = S.pageX - F.x,
                Z = S.pageY - F.y,
                et = Math.sqrt(Y * Y + Z * Z);
            x.set(0, et),
            v.set(0, Math.pow(x.y / p.y, n.zoomSpeed)),
            H(v.y),
            p.copy(x);
            const Tt = (S.pageX + F.x) * .5,
                Ht = (S.pageY + F.y) * .5;
            nt(Tt, Ht)
        }
        function q(S) {
            n.enableZoom && yt(S),
            n.enablePan && jt(S)
        }
        function Lt(S) {
            n.enableZoom && yt(S),
            n.enableRotate && Bt(S)
        }
        function kt(S) {
            n.enabled !== !1 && (T.length === 0 && (n.domElement.setPointerCapture(S.pointerId), n.domElement.addEventListener("pointermove", L), n.domElement.addEventListener("pointerup", b)), !vt(S) && (It(S), S.pointerType === "touch" ? Ot(S) : K(S)))
        }
        function L(S) {
            n.enabled !== !1 && (S.pointerType === "touch" ? lt(S) : st(S))
        }
        function b(S) {
            switch (Xt(S), T.length) {
            case 0:
                n.domElement.releasePointerCapture(S.pointerId),
                n.domElement.removeEventListener("pointermove", L),
                n.domElement.removeEventListener("pointerup", b),
                n.dispatchEvent(Vp),
                s = i.NONE;
                break;
            case 1:
                const F = T[0],
                    Y = R[F];
                Ot({
                    pointerId: F,
                    pageX: Y.x,
                    pageY: Y.y
                });
                break
            }
        }
        function K(S) {
            let F;
            switch (S.button) {
            case 0:
                F = n.mouseButtons.LEFT;
                break;
            case 1:
                F = n.mouseButtons.MIDDLE;
                break;
            case 2:
                F = n.mouseButtons.RIGHT;
                break;
            default:
                F = -1
            }
            switch (F) {
            case Nr.DOLLY:
                if (n.enableZoom === !1)
                    return;
                Ut(S),
                s = i.DOLLY;
                break;
            case Nr.ROTATE:
                if (S.ctrlKey || S.metaKey || S.shiftKey) {
                    if (n.enablePan === !1)
                        return;
                    Zt(S),
                    s = i.PAN
                } else {
                    if (n.enableRotate === !1)
                        return;
                    ct(S),
                    s = i.ROTATE
                }
                break;
            case Nr.PAN:
                if (S.ctrlKey || S.metaKey || S.shiftKey) {
                    if (n.enableRotate === !1)
                        return;
                    ct(S),
                    s = i.ROTATE
                } else {
                    if (n.enablePan === !1)
                        return;
                    Zt(S),
                    s = i.PAN
                }
                break;
            default:
                s = i.NONE
            }
            s !== i.NONE && n.dispatchEvent(vh)
        }
        function st(S) {
            switch (s) {
            case i.ROTATE:
                if (n.enableRotate === !1)
                    return;
                J(S);
                break;
            case i.DOLLY:
                if (n.enableZoom === !1)
                    return;
                it(S);
                break;
            case i.PAN:
                if (n.enablePan === !1)
                    return;
                ft(S);
                break
            }
        }
        function rt(S) {
            n.enabled === !1 || n.enableZoom === !1 || s !== i.NONE || (S.preventDefault(), n.dispatchEvent(vh), ut(Q(S)), n.dispatchEvent(Vp))
        }
        function Q(S) {
            const F = S.deltaMode,
                Y = {
                    clientX: S.clientX,
                    clientY: S.clientY,
                    deltaY: S.deltaY
                };
            switch (F) {
            case 1:
                Y.deltaY *= 16;
                break;
            case 2:
                Y.deltaY *= 100;
                break
            }
            return S.ctrlKey && !E && (Y.deltaY *= 10), Y
        }
        function At(S) {
            S.key === "Control" && (E = !0, n.domElement.getRootNode().addEventListener("keyup", at, {
                passive: !0,
                capture: !0
            }))
        }
        function at(S) {
            S.key === "Control" && (E = !1, n.domElement.getRootNode().removeEventListener("keyup", at, {
                passive: !0,
                capture: !0
            }))
        }
        function dt(S) {
            n.enabled === !1 || n.enablePan === !1 || Pt(S)
        }
        function Ot(S) {
            switch (Wt(S), T.length) {
            case 1:
                switch (n.touches.ONE) {
                case Ir.ROTATE:
                    if (n.enableRotate === !1)
                        return;
                    Nt(S),
                    s = i.TOUCH_ROTATE;
                    break;
                case Ir.PAN:
                    if (n.enablePan === !1)
                        return;
                    Kt(S),
                    s = i.TOUCH_PAN;
                    break;
                default:
                    s = i.NONE
                }
                break;
            case 2:
                switch (n.touches.TWO) {
                case Ir.DOLLY_PAN:
                    if (n.enableZoom === !1 && n.enablePan === !1)
                        return;
                    N(S),
                    s = i.TOUCH_DOLLY_PAN;
                    break;
                case Ir.DOLLY_ROTATE:
                    if (n.enableZoom === !1 && n.enableRotate === !1)
                        return;
                    zt(S),
                    s = i.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    s = i.NONE
                }
                break;
            default:
                s = i.NONE
            }
            s !== i.NONE && n.dispatchEvent(vh)
        }
        function lt(S) {
            switch (Wt(S), s) {
            case i.TOUCH_ROTATE:
                if (n.enableRotate === !1)
                    return;
                Bt(S),
                n.update();
                break;
            case i.TOUCH_PAN:
                if (n.enablePan === !1)
                    return;
                jt(S),
                n.update();
                break;
            case i.TOUCH_DOLLY_PAN:
                if (n.enableZoom === !1 && n.enablePan === !1)
                    return;
                q(S),
                n.update();
                break;
            case i.TOUCH_DOLLY_ROTATE:
                if (n.enableZoom === !1 && n.enableRotate === !1)
                    return;
                Lt(S),
                n.update();
                break;
            default:
                s = i.NONE
            }
        }
        function xt(S) {
            n.enabled !== !1 && S.preventDefault()
        }
        function It(S) {
            T.push(S.pointerId)
        }
        function Xt(S) {
            delete R[S.pointerId];
            for (let F = 0; F < T.length; F++)
                if (T[F] == S.pointerId) {
                    T.splice(F, 1);
                    return
                }
        }
        function vt(S) {
            for (let F = 0; F < T.length; F++)
                if (T[F] == S.pointerId)
                    return !0;
            return !1
        }
        function Wt(S) {
            let F = R[S.pointerId];
            F === void 0 && (F = new St, R[S.pointerId] = F),
            F.set(S.pageX, S.pageY)
        }
        function Yt(S) {
            const F = S.pointerId === T[0] ? T[1] : T[0];
            return R[F]
        }
        n.domElement.addEventListener("contextmenu", xt),
        n.domElement.addEventListener("pointerdown", kt),
        n.domElement.addEventListener("pointercancel", b),
        n.domElement.addEventListener("wheel", rt, {
            passive: !1
        }),
        n.domElement.getRootNode().addEventListener("keydown", At, {
            passive: !0,
            capture: !0
        }),
        this.update()
    }
}
var JE = `varying vec2 vUv;

void main() {\r
    vUv = uv;

    vec3 newPos = position;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\r
}`







    ,
    QE = `varying vec2 vUv;

uniform float uTime;\r
uniform vec2 uMouse;\r
uniform vec2 uResolution;

uniform vec2 uMix1;\r
uniform vec2 uMix2;\r
uniform vec2 uMix3;

uniform vec3 uColor1;\r
uniform vec3 uColor2;\r
uniform vec3 uColor3;\r
uniform vec3 uColor4;

vec4 permute(vec4 x) {\r
    return mod(((x * 34.0) + 1.0) * x, 289.0);\r
}\r
vec4 taylorInvSqrt(vec4 r) {\r
    return 1.79284291400159 - 0.85373472095314 * r;\r
}\r
vec3 fade(vec3 t) {\r
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\r
}

float cnoise(vec3 P) {\r
    vec3 Pi0 = floor(P); 
    vec3 Pi1 = Pi0 + vec3(1.0); 
    Pi0 = mod(Pi0, 289.0);\r
    Pi1 = mod(Pi1, 289.0);\r
    vec3 Pf0 = fract(P); 
    vec3 Pf1 = Pf0 - vec3(1.0); 
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r
    vec4 iy = vec4(Pi0.yy, Pi1.yy);\r
    vec4 iz0 = Pi0.zzzz;\r
    vec4 iz1 = Pi1.zzzz;

    vec4 ixy = permute(permute(ix) + iy);\r
    vec4 ixy0 = permute(ixy + iz0);\r
    vec4 ixy1 = permute(ixy + iz1);

    vec4 gx0 = ixy0 / 7.0;\r
    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\r
    gx0 = fract(gx0);\r
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r
    vec4 sz0 = step(gz0, vec4(0.0));\r
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);

    vec4 gx1 = ixy1 / 7.0;\r
    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\r
    gx1 = fract(gx1);\r
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r
    vec4 sz1 = step(gz1, vec4(0.0));\r
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);

    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\r
    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\r
    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\r
    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\r
    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\r
    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\r
    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\r
    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);

    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r
    g000 *= norm0.x;\r
    g010 *= norm0.y;\r
    g100 *= norm0.z;\r
    g110 *= norm0.w;\r
    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r
    g001 *= norm1.x;\r
    g011 *= norm1.y;\r
    g101 *= norm1.z;\r
    g111 *= norm1.w;

    float n000 = dot(g000, Pf0);\r
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r
    float n111 = dot(g111, Pf1);

    vec3 fade_xyz = fade(Pf0);\r
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r
    return 2.2 * n_xyz;\r
}

void main() {

    vec2 centeredUv = vUv * 2.0 - 1.;

    float dist = distance(centeredUv, uMouse);

    vec2 scale = vec2(0.5, 0.1);

    if(uResolution.x < uResolution.y) {\r
        scale.x = 0.1;\r
        scale.y = 0.3;\r
    }

    float noiseHeight = cnoise(vec3(vec2(centeredUv.x * scale.x, centeredUv.y * scale.y) - uTime * 0.0001 - 0.5, 234.34));

    float height = noiseHeight * pow((1. - dist * 0.5), 40.0);\r
    height = noiseHeight;\r
    height *= 1. - pow(vUv.x, .5);\r
    height *= 1. - pow(vUv.y, 0.5);\r
    float mixer1 = smoothstep(uMix1.x, uMix1.y, height);\r
    float mixer2 = smoothstep(uMix2.x, uMix2.y, height);\r
    float mixer3 = smoothstep(uMix3.x, uMix3.y, height);\r
    vec3 mixedColor1 = mix(uColor1, uColor2, mixer1);\r
    vec3 mixedColor2 = mix(mixedColor1, uColor3, mixer2);\r
    vec3 mixedColor3 = mix(mixedColor2, uColor4, mixer3);

    float alpha = mix(0.0, 1.0, mixer1);

    gl_FragColor = vec4(mixedColor3, alpha);

}`


























































































































    ; /**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.19.2
 * @author George Michael Brower
 * @license MIT
 */





class Hi {
    constructor(t, e, n, i, s="div")
    {
        this.parent = t,
        this.object = e,
        this.property = n,
        this._disabled = !1,
        this._hidden = !1,
        this.initialValue = this.getValue(),
        this.domElement = document.createElement(s),
        this.domElement.classList.add("controller"),
        this.domElement.classList.add(i),
        this.$name = document.createElement("div"),
        this.$name.classList.add("name"),
        Hi.nextNameID = Hi.nextNameID || 0,
        this.$name.id = `lil-gui-name-${++Hi.nextNameID}`,
        this.$widget = document.createElement("div"),
        this.$widget.classList.add("widget"),
        this.$disable = this.$widget,
        this.domElement.appendChild(this.$name),
        this.domElement.appendChild(this.$widget),
        this.domElement.addEventListener("keydown", o => o.stopPropagation()),
        this.domElement.addEventListener("keyup", o => o.stopPropagation()),
        this.parent.children.push(this),
        this.parent.controllers.push(this),
        this.parent.$children.appendChild(this.domElement),
        this._listenCallback = this._listenCallback.bind(this),
        this.name(n)
    }
    name(t)
    {
        return this._name = t, this.$name.textContent = t, this
    }
    onChange(t)
    {
        return this._onChange = t, this
    }
    _callOnChange()
    {
        this.parent._callOnChange(this),
        this._onChange !== void 0 && this._onChange.call(this, this.getValue()),
        this._changed = !0
    }
    onFinishChange(t)
    {
        return this._onFinishChange = t, this
    }
    _callOnFinishChange()
    {
        this._changed && (this.parent._callOnFinishChange(this), this._onFinishChange !== void 0 && this._onFinishChange.call(this, this.getValue())),
        this._changed = !1
    }
    reset()
    {
        return this.setValue(this.initialValue), this._callOnFinishChange(), this
    }
    enable(t=!0)
    {
        return this.disable(!t)
    }
    disable(t=!0)
    {
        return t === this._disabled ? this : (this._disabled = t, this.domElement.classList.toggle("disabled", t), this.$disable.toggleAttribute("disabled", t), this)
    }
    show(t=!0)
    {
        return this._hidden = !t, this.domElement.style.display = this._hidden ? "none" : "", this
    }
    hide()
    {
        return this.show(!1)
    }
    options(t)
    {
        const e = this.parent.add(this.object, this.property, t);
        return e.name(this._name), this.destroy(), e
    }
    min(t)
    {
        return this
    }
    max(t)
    {
        return this
    }
    step(t)
    {
        return this
    }
    decimals(t)
    {
        return this
    }
    listen(t=!0)
    {
        return this._listening = t, this._listenCallbackID !== void 0 && (cancelAnimationFrame(this._listenCallbackID), this._listenCallbackID = void 0), this._listening && this._listenCallback(), this
    }
    _listenCallback()
    {
        this._listenCallbackID = requestAnimationFrame(this._listenCallback);
        const t = this.save();
        t !== this._listenPrevValue && this.updateDisplay(),
        this._listenPrevValue = t
    }
    getValue()
    {
        return this.object[this.property]
    }
    setValue(t)
    {
        return this.getValue() !== t && (this.object[this.property] = t, this._callOnChange(), this.updateDisplay()), this
    }
    updateDisplay()
    {
        return this
    }
    load(t)
    {
        return this.setValue(t), this._callOnFinishChange(), this
    }
    save()
    {
        return this.getValue()
    }
    destroy()
    {
        this.listen(!1),
        this.parent.children.splice(this.parent.children.indexOf(this), 1),
        this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1),
        this.parent.$children.removeChild(this.domElement)
    }
}
class tb extends Hi {
    constructor(t, e, n)
    {
        super(t, e, n, "boolean", "label"),
        this.$input = document.createElement("input"),
        this.$input.setAttribute("type", "checkbox"),
        this.$input.setAttribute("aria-labelledby", this.$name.id),
        this.$widget.appendChild(this.$input),
        this.$input.addEventListener("change", () => {
            this.setValue(this.$input.checked),
            this._callOnFinishChange()
        }),
        this.$disable = this.$input,
        this.updateDisplay()
    }
    updateDisplay()
    {
        return this.$input.checked = this.getValue(), this
    }
}
function Ru(r) {
    let t,
        e;
    return (t = r.match(/(#|0x)?([a-f0-9]{6})/i)) ? e = t[2] : (t = r.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) ? e = parseInt(t[1]).toString(16).padStart(2, 0) + parseInt(t[2]).toString(16).padStart(2, 0) + parseInt(t[3]).toString(16).padStart(2, 0) : (t = r.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) && (e = t[1] + t[1] + t[2] + t[2] + t[3] + t[3]), e ? "#" + e : !1
}
const eb = {
        isPrimitive: !0,
        match: r => typeof r == "string",
        fromHexString: Ru,
        toHexString: Ru
    },
    Fa = {
        isPrimitive: !0,
        match: r => typeof r == "number",
        fromHexString: r => parseInt(r.substring(1), 16),
        toHexString: r => "#" + r.toString(16).padStart(6, 0)
    },
    nb = {
        isPrimitive: !1,
        match: r => Array.isArray(r),
        fromHexString(r, t, e=1) {
            const n = Fa.fromHexString(r);
            t[0] = (n >> 16 & 255) / 255 * e,
            t[1] = (n >> 8 & 255) / 255 * e,
            t[2] = (n & 255) / 255 * e
        },
        toHexString([r, t, e], n=1) {
            n = 255 / n;
            const i = r * n << 16 ^ t * n << 8 ^ e * n << 0;
            return Fa.toHexString(i)
        }
    },
    ib = {
        isPrimitive: !1,
        match: r => Object(r) === r,
        fromHexString(r, t, e=1) {
            const n = Fa.fromHexString(r);
            t.r = (n >> 16 & 255) / 255 * e,
            t.g = (n >> 8 & 255) / 255 * e,
            t.b = (n & 255) / 255 * e
        },
        toHexString({r, g: t, b: e}, n=1) {
            n = 255 / n;
            const i = r * n << 16 ^ t * n << 8 ^ e * n << 0;
            return Fa.toHexString(i)
        }
    },
    sb = [eb, Fa, nb, ib];
function rb(r) {
    return sb.find(t => t.match(r))
}
class ob extends Hi {
    constructor(t, e, n, i)
    {
        super(t, e, n, "color"),
        this.$input = document.createElement("input"),
        this.$input.setAttribute("type", "color"),
        this.$input.setAttribute("tabindex", -1),
        this.$input.setAttribute("aria-labelledby", this.$name.id),
        this.$text = document.createElement("input"),
        this.$text.setAttribute("type", "text"),
        this.$text.setAttribute("spellcheck", "false"),
        this.$text.setAttribute("aria-labelledby", this.$name.id),
        this.$display = document.createElement("div"),
        this.$display.classList.add("display"),
        this.$display.appendChild(this.$input),
        this.$widget.appendChild(this.$display),
        this.$widget.appendChild(this.$text),
        this._format = rb(this.initialValue),
        this._rgbScale = i,
        this._initialValueHexString = this.save(),
        this._textFocused = !1,
        this.$input.addEventListener("input", () => {
            this._setValueFromHexString(this.$input.value)
        }),
        this.$input.addEventListener("blur", () => {
            this._callOnFinishChange()
        }),
        this.$text.addEventListener("input", () => {
            const s = Ru(this.$text.value);
            s && this._setValueFromHexString(s)
        }),
        this.$text.addEventListener("focus", () => {
            this._textFocused = !0,
            this.$text.select()
        }),
        this.$text.addEventListener("blur", () => {
            this._textFocused = !1,
            this.updateDisplay(),
            this._callOnFinishChange()
        }),
        this.$disable = this.$text,
        this.updateDisplay()
    }
    reset()
    {
        return this._setValueFromHexString(this._initialValueHexString), this
    }
    _setValueFromHexString(t)
    {
        if (this._format.isPrimitive) {
            const e = this._format.fromHexString(t);
            this.setValue(e)
        } else
            this._format.fromHexString(t, this.getValue(), this._rgbScale),
            this._callOnChange(),
            this.updateDisplay()
    }
    save()
    {
        return this._format.toHexString(this.getValue(), this._rgbScale)
    }
    load(t)
    {
        return this._setValueFromHexString(t), this._callOnFinishChange(), this
    }
    updateDisplay()
    {
        return this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale), this._textFocused || (this.$text.value = this.$input.value.substring(1)), this.$display.style.backgroundColor = this.$input.value, this
    }
}
class yh extends Hi {
    constructor(t, e, n)
    {
        super(t, e, n, "function"),
        this.$button = document.createElement("button"),
        this.$button.appendChild(this.$name),
        this.$widget.appendChild(this.$button),
        this.$button.addEventListener("click", i => {
            i.preventDefault(),
            this.getValue().call(this.object),
            this._callOnChange()
        }),
        this.$button.addEventListener("touchstart", () => {}, {
            passive: !0
        }),
        this.$disable = this.$button
    }
}
class ab extends Hi {
    constructor(t, e, n, i, s, o)
    {
        super(t, e, n, "number"),
        this._initInput(),
        this.min(i),
        this.max(s);
        const a = o !== void 0;
        this.step(a ? o : this._getImplicitStep(), a),
        this.updateDisplay()
    }
    decimals(t)
    {
        return this._decimals = t, this.updateDisplay(), this
    }
    min(t)
    {
        return this._min = t, this._onUpdateMinMax(), this
    }
    max(t)
    {
        return this._max = t, this._onUpdateMinMax(), this
    }
    step(t, e=!0)
    {
        return this._step = t, this._stepExplicit = e, this
    }
    updateDisplay()
    {
        const t = this.getValue();
        if (this._hasSlider) {
            let e = (t - this._min) / (this._max - this._min);
            e = Math.max(0, Math.min(e, 1)),
            this.$fill.style.width = e * 100 + "%"
        }
        return this._inputFocused || (this.$input.value = this._decimals === void 0 ? t : t.toFixed(this._decimals)), this
    }
    _initInput()
    {
        this.$input = document.createElement("input"),
        this.$input.setAttribute("type", "text"),
        this.$input.setAttribute("aria-labelledby", this.$name.id),
        window.matchMedia("(pointer: coarse)").matches && (this.$input.setAttribute("type", "number"), this.$input.setAttribute("step", "any")),
        this.$widget.appendChild(this.$input),
        this.$disable = this.$input;
        const e = () => {
                let x = parseFloat(this.$input.value);
                isNaN(x) || (this._stepExplicit && (x = this._snap(x)), this.setValue(this._clamp(x)))
            },
            n = x => {
                const v = parseFloat(this.$input.value);
                isNaN(v) || (this._snapClampSetValue(v + x), this.$input.value = this.getValue())
            },
            i = x => {
                x.key === "Enter" && this.$input.blur(),
                x.code === "ArrowUp" && (x.preventDefault(), n(this._step * this._arrowKeyMultiplier(x))),
                x.code === "ArrowDown" && (x.preventDefault(), n(this._step * this._arrowKeyMultiplier(x) * -1))
            },
            s = x => {
                this._inputFocused && (x.preventDefault(), n(this._step * this._normalizeMouseWheel(x)))
            };
        let o = !1,
            a,
            l,
            c,
            h,
            u;
        const d = 5,
            f = x => {
                a = x.clientX,
                l = c = x.clientY,
                o = !0,
                h = this.getValue(),
                u = 0,
                window.addEventListener("mousemove", m),
                window.addEventListener("mouseup", _)
            },
            m = x => {
                if (o) {
                    const v = x.clientX - a,
                        y = x.clientY - l;
                    Math.abs(y) > d ? (x.preventDefault(), this.$input.blur(), o = !1, this._setDraggingStyle(!0, "vertical")) : Math.abs(v) > d && _()
                }
                if (!o) {
                    const v = x.clientY - c;
                    u -= v * this._step * this._arrowKeyMultiplier(x),
                    h + u > this._max ? u = this._max - h : h + u < this._min && (u = this._min - h),
                    this._snapClampSetValue(h + u)
                }
                c = x.clientY
            },
            _ = () => {
                this._setDraggingStyle(!1, "vertical"),
                this._callOnFinishChange(),
                window.removeEventListener("mousemove", m),
                window.removeEventListener("mouseup", _)
            },
            g = () => {
                this._inputFocused = !0
            },
            p = () => {
                this._inputFocused = !1,
                this.updateDisplay(),
                this._callOnFinishChange()
            };
        this.$input.addEventListener("input", e),
        this.$input.addEventListener("keydown", i),
        this.$input.addEventListener("wheel", s, {
            passive: !1
        }),
        this.$input.addEventListener("mousedown", f),
        this.$input.addEventListener("focus", g),
        this.$input.addEventListener("blur", p)
    }
    _initSlider()
    {
        this._hasSlider = !0,
        this.$slider = document.createElement("div"),
        this.$slider.classList.add("slider"),
        this.$fill = document.createElement("div"),
        this.$fill.classList.add("fill"),
        this.$slider.appendChild(this.$fill),
        this.$widget.insertBefore(this.$slider, this.$input),
        this.domElement.classList.add("hasSlider");
        const t = (p, x, v, y, C) => (p - x) / (v - x) * (C - y) + y,
            e = p => {
                const x = this.$slider.getBoundingClientRect();
                let v = t(p, x.left, x.right, this._min, this._max);
                this._snapClampSetValue(v)
            },
            n = p => {
                this._setDraggingStyle(!0),
                e(p.clientX),
                window.addEventListener("mousemove", i),
                window.addEventListener("mouseup", s)
            },
            i = p => {
                e(p.clientX)
            },
            s = () => {
                this._callOnFinishChange(),
                this._setDraggingStyle(!1),
                window.removeEventListener("mousemove", i),
                window.removeEventListener("mouseup", s)
            };
        let o = !1,
            a,
            l;
        const c = p => {
                p.preventDefault(),
                this._setDraggingStyle(!0),
                e(p.touches[0].clientX),
                o = !1
            },
            h = p => {
                p.touches.length > 1 || (this._hasScrollBar ? (a = p.touches[0].clientX, l = p.touches[0].clientY, o = !0) : c(p), window.addEventListener("touchmove", u, {
                    passive: !1
                }), window.addEventListener("touchend", d))
            },
            u = p => {
                if (o) {
                    const x = p.touches[0].clientX - a,
                        v = p.touches[0].clientY - l;
                    Math.abs(x) > Math.abs(v) ? c(p) : (window.removeEventListener("touchmove", u), window.removeEventListener("touchend", d))
                } else
                    p.preventDefault(),
                    e(p.touches[0].clientX)
            },
            d = () => {
                this._callOnFinishChange(),
                this._setDraggingStyle(!1),
                window.removeEventListener("touchmove", u),
                window.removeEventListener("touchend", d)
            },
            f = this._callOnFinishChange.bind(this),
            m = 400;
        let _;
        const g = p => {
            if (Math.abs(p.deltaX) < Math.abs(p.deltaY) && this._hasScrollBar)
                return;
            p.preventDefault();
            const v = this._normalizeMouseWheel(p) * this._step;
            this._snapClampSetValue(this.getValue() + v),
            this.$input.value = this.getValue(),
            clearTimeout(_),
            _ = setTimeout(f, m)
        };
        this.$slider.addEventListener("mousedown", n),
        this.$slider.addEventListener("touchstart", h, {
            passive: !1
        }),
        this.$slider.addEventListener("wheel", g, {
            passive: !1
        })
    }
    _setDraggingStyle(t, e="horizontal")
    {
        this.$slider && this.$slider.classList.toggle("active", t),
        document.body.classList.toggle("lil-gui-dragging", t),
        document.body.classList.toggle(`lil-gui-${e}`, t)
    }
    _getImplicitStep()
    {
        return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : .1
    }
    _onUpdateMinMax()
    {
        !this._hasSlider && this._hasMin && this._hasMax && (this._stepExplicit || this.step(this._getImplicitStep(), !1), this._initSlider(), this.updateDisplay())
    }
    _normalizeMouseWheel(t)
    {
        let {deltaX: e, deltaY: n} = t;
        return Math.floor(t.deltaY) !== t.deltaY && t.wheelDelta && (e = 0, n = -t.wheelDelta / 120, n *= this._stepExplicit ? 1 : 10), e + -n
    }
    _arrowKeyMultiplier(t)
    {
        let e = this._stepExplicit ? 1 : 10;
        return t.shiftKey ? e *= 10 : t.altKey && (e /= 10), e
    }
    _snap(t)
    {
        const e = Math.round(t / this._step) * this._step;
        return parseFloat(e.toPrecision(15))
    }
    _clamp(t)
    {
        return t < this._min && (t = this._min), t > this._max && (t = this._max), t
    }
    _snapClampSetValue(t)
    {
        this.setValue(this._clamp(this._snap(t)))
    }
    get _hasScrollBar()
    {
        const t = this.parent.root.$children;
        return t.scrollHeight > t.clientHeight
    }
    get _hasMin()
    {
        return this._min !== void 0
    }
    get _hasMax()
    {
        return this._max !== void 0
    }
}
class lb extends Hi {
    constructor(t, e, n, i)
    {
        super(t, e, n, "option"),
        this.$select = document.createElement("select"),
        this.$select.setAttribute("aria-labelledby", this.$name.id),
        this.$display = document.createElement("div"),
        this.$display.classList.add("display"),
        this.$select.addEventListener("change", () => {
            this.setValue(this._values[this.$select.selectedIndex]),
            this._callOnFinishChange()
        }),
        this.$select.addEventListener("focus", () => {
            this.$display.classList.add("focus")
        }),
        this.$select.addEventListener("blur", () => {
            this.$display.classList.remove("focus")
        }),
        this.$widget.appendChild(this.$select),
        this.$widget.appendChild(this.$display),
        this.$disable = this.$select,
        this.options(i)
    }
    options(t)
    {
        return this._values = Array.isArray(t) ? t : Object.values(t), this._names = Array.isArray(t) ? t : Object.keys(t), this.$select.replaceChildren(), this._names.forEach(e => {
            const n = document.createElement("option");
            n.textContent = e,
            this.$select.appendChild(n)
        }), this.updateDisplay(), this
    }
    updateDisplay()
    {
        const t = this.getValue(),
            e = this._values.indexOf(t);
        return this.$select.selectedIndex = e, this.$display.textContent = e === -1 ? t : this._names[e], this
    }
}
class cb extends Hi {
    constructor(t, e, n)
    {
        super(t, e, n, "string"),
        this.$input = document.createElement("input"),
        this.$input.setAttribute("type", "text"),
        this.$input.setAttribute("spellcheck", "false"),
        this.$input.setAttribute("aria-labelledby", this.$name.id),
        this.$input.addEventListener("input", () => {
            this.setValue(this.$input.value)
        }),
        this.$input.addEventListener("keydown", i => {
            i.code === "Enter" && this.$input.blur()
        }),
        this.$input.addEventListener("blur", () => {
            this._callOnFinishChange()
        }),
        this.$widget.appendChild(this.$input),
        this.$disable = this.$input,
        this.updateDisplay()
    }
    updateDisplay()
    {
        return this.$input.value = this.getValue(), this
    }
}
const hb = `.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
  background: var(--background-color);
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "↕";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  line-height: calc(var(--title-height) - 4px);
  font-weight: 600;
  padding: 0 var(--padding);
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
  outline: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "▾";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "▸";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui label, .lil-gui input, .lil-gui button {
  -webkit-tap-highlight-color: transparent;
}
.lil-gui input {
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
  -moz-appearance: textfield;
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input[type=checkbox] {
  appearance: none;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "✓";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  border: none;
}
@media (hover: hover) {
  .lil-gui button:hover {
    background: var(--hover-color);
  }
  .lil-gui button:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`




































































































































































































































































































































































































































;
function ub(r) {
    const t = document.createElement("style");
    t.innerHTML = r;
    const e = document.querySelector("head link[rel=stylesheet], head style");
    e ? document.head.insertBefore(t, e) : document.head.appendChild(t)
}
let Wp = !1;
class Nd {
    constructor({parent: t, autoPlace: e=t === void 0, container: n, width: i, title: s="Controls", closeFolders: o=!1, injectStyles: a=!0, touchStyles: l=!0}={})
    {
        if (this.parent = t, this.root = t ? t.root : this, this.children = [], this.controllers = [], this.folders = [], this._closed = !1, this._hidden = !1, this.domElement = document.createElement("div"), this.domElement.classList.add("lil-gui"), this.$title = document.createElement("div"), this.$title.classList.add("title"), this.$title.setAttribute("role", "button"), this.$title.setAttribute("aria-expanded", !0), this.$title.setAttribute("tabindex", 0), this.$title.addEventListener("click", () => this.openAnimated(this._closed)), this.$title.addEventListener("keydown", c => {
            (c.code === "Enter" || c.code === "Space") && (c.preventDefault(), this.$title.click())
        }), this.$title.addEventListener("touchstart", () => {}, {
            passive: !0
        }), this.$children = document.createElement("div"), this.$children.classList.add("children"), this.domElement.appendChild(this.$title), this.domElement.appendChild(this.$children), this.title(s), this.parent) {
            this.parent.children.push(this),
            this.parent.folders.push(this),
            this.parent.$children.appendChild(this.domElement);
            return
        }
        this.domElement.classList.add("root"),
        l && this.domElement.classList.add("allow-touch-styles"),
        !Wp && a && (ub(hb), Wp = !0),
        n ? n.appendChild(this.domElement) : e && (this.domElement.classList.add("autoPlace"), document.body.appendChild(this.domElement)),
        i && this.domElement.style.setProperty("--width", i + "px"),
        this._closeFolders = o
    }
    add(t, e, n, i, s)
    {
        if (Object(n) === n)
            return new lb(this, t, e, n);
        const o = t[e];
        switch (typeof o) {
        case "number":
            return new ab(this, t, e, n, i, s);
        case "boolean":
            return new tb(this, t, e);
        case "string":
            return new cb(this, t, e);
        case "function":
            return new yh(this, t, e)
        }
        console.error(`gui.add failed
	property:`
        , e, `
	object:`
        , t, `
	value:`
        , o)
    }
    addColor(t, e, n=1)
    {
        return new ob(this, t, e, n)
    }
    addFolder(t)
    {
        const e = new Nd({
            parent: this,
            title: t
        });
        return this.root._closeFolders && e.close(), e
    }
    load(t, e=!0)
    {
        return t.controllers && this.controllers.forEach(n => {
            n instanceof yh || n._name in t.controllers && n.load(t.controllers[n._name])
        }), e && t.folders && this.folders.forEach(n => {
            n._title in t.folders && n.load(t.folders[n._title])
        }), this
    }
    save(t=!0)
    {
        const e = {
            controllers: {},
            folders: {}
        };
        return this.controllers.forEach(n => {
            if (!(n instanceof yh)) {
                if (n._name in e.controllers)
                    throw new Error(`Cannot save GUI with duplicate property "${n._name}"`);
                e.controllers[n._name] = n.save()
            }
        }), t && this.folders.forEach(n => {
            if (n._title in e.folders)
                throw new Error(`Cannot save GUI with duplicate folder "${n._title}"`);
            e.folders[n._title] = n.save()
        }), e
    }
    open(t=!0)
    {
        return this._setClosed(!t), this.$title.setAttribute("aria-expanded", !this._closed), this.domElement.classList.toggle("closed", this._closed), this
    }
    close()
    {
        return this.open(!1)
    }
    _setClosed(t)
    {
        this._closed !== t && (this._closed = t, this._callOnOpenClose(this))
    }
    show(t=!0)
    {
        return this._hidden = !t, this.domElement.style.display = this._hidden ? "none" : "", this
    }
    hide()
    {
        return this.show(!1)
    }
    openAnimated(t=!0)
    {
        return this._setClosed(!t), this.$title.setAttribute("aria-expanded", !this._closed), requestAnimationFrame(() => {
            const e = this.$children.clientHeight;
            this.$children.style.height = e + "px",
            this.domElement.classList.add("transition");
            const n = s => {
                s.target === this.$children && (this.$children.style.height = "", this.domElement.classList.remove("transition"), this.$children.removeEventListener("transitionend", n))
            };
            this.$children.addEventListener("transitionend", n);
            const i = t ? this.$children.scrollHeight : 0;
            this.domElement.classList.toggle("closed", !t),
            requestAnimationFrame(() => {
                this.$children.style.height = i + "px"
            })
        }), this
    }
    title(t)
    {
        return this._title = t, this.$title.textContent = t, this
    }
    reset(t=!0)
    {
        return (t ? this.controllersRecursive() : this.controllers).forEach(n => n.reset()), this
    }
    onChange(t)
    {
        return this._onChange = t, this
    }
    _callOnChange(t)
    {
        this.parent && this.parent._callOnChange(t),
        this._onChange !== void 0 && this._onChange.call(this, {
            object: t.object,
            property: t.property,
            value: t.getValue(),
            controller: t
        })
    }
    onFinishChange(t)
    {
        return this._onFinishChange = t, this
    }
    _callOnFinishChange(t)
    {
        this.parent && this.parent._callOnFinishChange(t),
        this._onFinishChange !== void 0 && this._onFinishChange.call(this, {
            object: t.object,
            property: t.property,
            value: t.getValue(),
            controller: t
        })
    }
    onOpenClose(t)
    {
        return this._onOpenClose = t, this
    }
    _callOnOpenClose(t)
    {
        this.parent && this.parent._callOnOpenClose(t),
        this._onOpenClose !== void 0 && this._onOpenClose.call(this, t)
    }
    destroy()
    {
        this.parent && (this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.folders.splice(this.parent.folders.indexOf(this), 1)),
        this.domElement.parentElement && this.domElement.parentElement.removeChild(this.domElement),
        Array.from(this.children).forEach(t => t.destroy())
    }
    controllersRecursive()
    {
        let t = Array.from(this.controllers);
        return this.folders.forEach(e => {
            t = t.concat(e.controllersRecursive())
        }), t
    }
    foldersRecursive()
    {
        let t = Array.from(this.folders);
        return this.folders.forEach(e => {
            t = t.concat(e.foldersRecursive())
        }), t
    }
}
function Xp(r, t) {
    if (t === Cx)
        return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), r;
    if (t === Tu || t === sg) {
        let e = r.getIndex();
        if (e === null) {
            const o = [],
                a = r.getAttribute("position");
            if (a !== void 0) {
                for (let l = 0; l < a.count; l++)
                    o.push(l);
                r.setIndex(o),
                e = r.getIndex()
            } else
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), r
        }
        const n = e.count - 2,
            i = [];
        if (t === Tu)
            for (let o = 1; o <= n; o++)
                i.push(e.getX(0)),
                i.push(e.getX(o)),
                i.push(e.getX(o + 1));
        else
            for (let o = 0; o < n; o++)
                o % 2 === 0 ? (i.push(e.getX(o)), i.push(e.getX(o + 1)), i.push(e.getX(o + 2))) : (i.push(e.getX(o + 2)), i.push(e.getX(o + 1)), i.push(e.getX(o)));
        i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = r.clone();
        return s.setIndex(i), s.clearGroups(), s
    } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), r
}
class db extends Go {
    constructor(t)
    {
        super(t),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(e) {
            return new _b(e)
        }),
        this.register(function(e) {
            return new xb(e)
        }),
        this.register(function(e) {
            return new Ab(e)
        }),
        this.register(function(e) {
            return new Cb(e)
        }),
        this.register(function(e) {
            return new Rb(e)
        }),
        this.register(function(e) {
            return new yb(e)
        }),
        this.register(function(e) {
            return new Mb(e)
        }),
        this.register(function(e) {
            return new Sb(e)
        }),
        this.register(function(e) {
            return new Tb(e)
        }),
        this.register(function(e) {
            return new gb(e)
        }),
        this.register(function(e) {
            return new Eb(e)
        }),
        this.register(function(e) {
            return new vb(e)
        }),
        this.register(function(e) {
            return new wb(e)
        }),
        this.register(function(e) {
            return new bb(e)
        }),
        this.register(function(e) {
            return new pb(e)
        }),
        this.register(function(e) {
            return new Pb(e)
        }),
        this.register(function(e) {
            return new Lb(e)
        })
    }
    load(t, e, n, i)
    {
        const s = this;
        let o;
        if (this.resourcePath !== "")
            o = this.resourcePath;
        else if (this.path !== "") {
            const c = ga.extractUrlBase(t);
            o = ga.resolveURL(c, this.path)
        } else
            o = ga.extractUrlBase(t);
        this.manager.itemStart(t);
        const a = function(c) {
                i ? i(c) : console.error(c),
                s.manager.itemError(t),
                s.manager.itemEnd(t)
            },
            l = new Ig(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(t, function(c) {
            try {
                s.parse(c, o, function(h) {
                    e(h),
                    s.manager.itemEnd(t)
                }, a)
            } catch (h) {
                a(h)
            }
        }, n, a)
    }
    setDRACOLoader(t)
    {
        return this.dracoLoader = t, this
    }
    setDDSLoader()
    {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(t)
    {
        return this.ktx2Loader = t, this
    }
    setMeshoptDecoder(t)
    {
        return this.meshoptDecoder = t, this
    }
    register(t)
    {
        return this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t), this
    }
    unregister(t)
    {
        return this.pluginCallbacks.indexOf(t) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
    }
    parse(t, e, n, i)
    {
        let s;
        const o = {},
            a = {},
            l = new TextDecoder;
        if (typeof t == "string")
            s = JSON.parse(t);
        else if (t instanceof ArrayBuffer)
            if (l.decode(new Uint8Array(t, 0, 4)) === Ug) {
                try {
                    o[ae.KHR_BINARY_GLTF] = new Db(t)
                } catch (u) {
                    i && i(u);
                    return
                }
                s = JSON.parse(o[ae.KHR_BINARY_GLTF].content)
            } else
                s = JSON.parse(l.decode(t));
        else
            s = t;
        if (s.asset === void 0 || s.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const c = new Xb(s, {
            path: e || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const u = this.pluginCallbacks[h](c);
            u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
            a[u.name] = u,
            o[u.name] = !0
        }
        if (s.extensionsUsed)
            for (let h = 0; h < s.extensionsUsed.length; ++h) {
                const u = s.extensionsUsed[h],
                    d = s.extensionsRequired || [];
                switch (u) {
                case ae.KHR_MATERIALS_UNLIT:
                    o[u] = new mb;
                    break;
                case ae.KHR_DRACO_MESH_COMPRESSION:
                    o[u] = new Nb(s, this.dracoLoader);
                    break;
                case ae.KHR_TEXTURE_TRANSFORM:
                    o[u] = new Ib;
                    break;
                case ae.KHR_MESH_QUANTIZATION:
                    o[u] = new Fb;
                    break;
                default:
                    d.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".')
                }
            }
        c.setExtensions(o),
        c.setPlugins(a),
        c.parse(n, i)
    }
    parseAsync(t, e)
    {
        const n = this;
        return new Promise(function(i, s) {
            n.parse(t, e, i, s)
        })
    }
}
function fb() {
    let r = {};
    return {
        get: function(t) {
            return r[t]
        },
        add: function(t, e) {
            r[t] = e
        },
        remove: function(t) {
            delete r[t]
        },
        removeAll: function() {
            r = {}
        }
    }
}
const ae = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class pb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs()
    {
        const t = this.parser,
            e = this.parser.json.nodes || [];
        for (let n = 0, i = e.length; n < i; n++) {
            const s = e[n];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && t._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(t)
    {
        const e = this.parser,
            n = "light:" + t;
        let i = e.cache.get(n);
        if (i)
            return i;
        const s = e.json,
            l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[t];
        let c;
        const h = new Gt(16777215);
        l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], dn);
        const u = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
        case "directional":
            c = new zE(h),
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        case "point":
            c = new UE(h),
            c.distance = u;
            break;
        case "spot":
            c = new IE(h),
            c.distance = u,
            l.spot = l.spot || {},
            l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0,
            l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4,
            c.angle = l.spot.outerConeAngle,
            c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0), c.decay = 2, rs(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = e.createUniqueName(l.name || "light_" + t), i = Promise.resolve(c), e.cache.add(n, i), i
    }
    getDependency(t, e)
    {
        if (t === "light")
            return this._loadLight(e)
    }
    createNodeAttachment(t)
    {
        const e = this,
            n = this.parser,
            s = n.json.nodes[t],
            a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return n._getNodeRef(e.cache, a, l)
        })
    }
}
class mb {
    constructor()
    {
        this.name = ae.KHR_MATERIALS_UNLIT
    }
    getMaterialType()
    {
        return zs
    }
    extendParams(t, e, n)
    {
        const i = [];
        t.color = new Gt(1, 1, 1),
        t.opacity = 1;
        const s = e.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                t.color.setRGB(o[0], o[1], o[2], dn),
                t.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && i.push(n.assignTexture(t, "map", s.baseColorTexture, Ln))
        }
        return Promise.all(i)
    }
}
class gb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(t, e)
    {
        const i = this.parser.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name].emissiveStrength;
        return s !== void 0 && (e.emissiveIntensity = s), Promise.resolve()
    }
}
class _b {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (e.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(n.assignTexture(e, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(e, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(e, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            e.clearcoatNormalScale = new St(a, a)
        }
        return Promise.all(s)
    }
}
class xb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_DISPERSION
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const i = this.parser.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name];
        return e.dispersion = s.dispersion !== void 0 ? s.dispersion : 0, Promise.resolve()
    }
}
class vb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (e.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(n.assignTexture(e, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (e.iridescenceIOR = o.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(e, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s)
    }
}
class yb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_SHEEN
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [];
        e.sheenColor = new Gt(0, 0, 0),
        e.sheenRoughness = 0,
        e.sheen = 1;
        const o = i.extensions[this.name];
        if (o.sheenColorFactor !== void 0) {
            const a = o.sheenColorFactor;
            e.sheenColor.setRGB(a[0], a[1], a[2], dn)
        }
        return o.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(n.assignTexture(e, "sheenColorMap", o.sheenColorTexture, Ln)), o.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(e, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s)
    }
}
class Mb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return o.transmissionFactor !== void 0 && (e.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(n.assignTexture(e, "transmissionMap", o.transmissionTexture)), Promise.all(s)
    }
}
class Sb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_VOLUME
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        e.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && s.push(n.assignTexture(e, "thicknessMap", o.thicknessTexture)),
        e.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return e.attenuationColor = new Gt().setRGB(a[0], a[1], a[2], dn), Promise.all(s)
    }
}
class Tb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_IOR
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const i = this.parser.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name];
        return e.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve()
    }
}
class Eb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        e.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && s.push(n.assignTexture(e, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return e.specularColor = new Gt().setRGB(a[0], a[1], a[2], dn), o.specularColorTexture !== void 0 && s.push(n.assignTexture(e, "specularColorMap", o.specularColorTexture, Ln)), Promise.all(s)
    }
}
class bb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.EXT_MATERIALS_BUMP
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return e.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && s.push(n.assignTexture(e, "bumpMap", o.bumpTexture)), Promise.all(s)
    }
}
class wb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(t)
    {
        const n = this.parser.json.materials[t];
        return !n.extensions || !n.extensions[this.name] ? null : qi
    }
    extendMaterialParams(t, e)
    {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return o.anisotropyStrength !== void 0 && (e.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (e.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(n.assignTexture(e, "anisotropyMap", o.anisotropyTexture)), Promise.all(s)
    }
}
class Ab {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.KHR_TEXTURE_BASISU
    }
    loadTexture(t)
    {
        const e = this.parser,
            n = e.json,
            i = n.textures[t];
        if (!i.extensions || !i.extensions[this.name])
            return null;
        const s = i.extensions[this.name],
            o = e.options.ktx2Loader;
        if (!o) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return e.loadTextureImage(t, s.source, o)
    }
}
class Cb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(t)
    {
        const e = this.name,
            n = this.parser,
            i = n.json,
            s = i.textures[t];
        if (!s.extensions || !s.extensions[e])
            return null;
        const o = s.extensions[e],
            a = i.images[o.source];
        let l = n.textureLoader;
        if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return n.loadTextureImage(t, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return n.loadTexture(t)
        })
    }
    detectSupport()
    {
        return this.isSupported || (this.isSupported = new Promise(function(t) {
            const e = new Image;
            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            e.onload = e.onerror = function() {
                t(e.height === 1)
            }
        })), this.isSupported
    }
}
class Rb {
    constructor(t)
    {
        this.parser = t,
        this.name = ae.EXT_TEXTURE_AVIF,
        this.isSupported = null
    }
    loadTexture(t)
    {
        const e = this.name,
            n = this.parser,
            i = n.json,
            s = i.textures[t];
        if (!s.extensions || !s.extensions[e])
            return null;
        const o = s.extensions[e],
            a = i.images[o.source];
        let l = n.textureLoader;
        if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return n.loadTextureImage(t, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return n.loadTexture(t)
        })
    }
    detectSupport()
    {
        return this.isSupported || (this.isSupported = new Promise(function(t) {
            const e = new Image;
            e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
            e.onload = e.onerror = function() {
                t(e.height === 1)
            }
        })), this.isSupported
    }
}
class Pb {
    constructor(t)
    {
        this.name = ae.EXT_MESHOPT_COMPRESSION,
        this.parser = t
    }
    loadBufferView(t)
    {
        const e = this.parser.json,
            n = e.bufferViews[t];
        if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name],
                s = this.parser.getDependency("buffer", i.buffer),
                o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const l = i.byteOffset || 0,
                    c = i.byteLength || 0,
                    h = i.count,
                    u = i.byteStride,
                    d = new Uint8Array(a, l, c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(h, u, d, i.mode, i.filter).then(function(f) {
                    return f.buffer
                }) : o.ready.then(function() {
                    const f = new ArrayBuffer(h * u);
                    return o.decodeGltfBuffer(new Uint8Array(f), h, u, d, i.mode, i.filter), f
                })
            })
        } else
            return null
    }
}
class Lb {
    constructor(t)
    {
        this.name = ae.EXT_MESH_GPU_INSTANCING,
        this.parser = t
    }
    createNodeMesh(t)
    {
        const e = this.parser.json,
            n = e.nodes[t];
        if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
            return null;
        const i = e.meshes[n.mesh];
        for (const c of i.primitives)
            if (c.mode !== hi.TRIANGLES && c.mode !== hi.TRIANGLE_STRIP && c.mode !== hi.TRIANGLE_FAN && c.mode !== void 0)
                return null;
        const o = n.extensions[this.name].attributes,
            a = [],
            l = {};
        for (const c in o)
            a.push(this.parser.getDependency("accessor", o[c]).then(h => (l[c] = h, l[c])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(t)), Promise.all(a).then(c => {
            const h = c.pop(),
                u = h.isGroup ? h.children : [h],
                d = c[0].count,
                f = [];
            for (const m of u) {
                const _ = new le,
                    g = new O,
                    p = new Wi,
                    x = new O(1, 1, 1),
                    v = new mE(m.geometry, m.material, d);
                for (let y = 0; y < d; y++)
                    l.TRANSLATION && g.fromBufferAttribute(l.TRANSLATION, y),
                    l.ROTATION && p.fromBufferAttribute(l.ROTATION, y),
                    l.SCALE && x.fromBufferAttribute(l.SCALE, y),
                    v.setMatrixAt(y, _.compose(g, p, x));
                for (const y in l)
                    if (y === "_COLOR_0") {
                        const C = l[y];
                        v.instanceColor = new Au(C.array, C.itemSize, C.normalized)
                    } else
                        y !== "TRANSLATION" && y !== "ROTATION" && y !== "SCALE" && m.geometry.setAttribute(y, l[y]);
                He.prototype.copy.call(v, m),
                this.parser.assignFinalMaterial(v),
                f.push(v)
            }
            return h.isGroup ? (h.clear(), h.add(...f), h) : f[0]
        }))
    }
}
const Ug = "glTF",
    ta = 12,
    Yp = {
        JSON: 1313821514,
        BIN: 5130562
    };
class Db {
    constructor(t)
    {
        this.name = ae.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const e = new DataView(t, 0, ta),
            n = new TextDecoder;
        if (this.header = {
            magic: n.decode(new Uint8Array(t.slice(0, 4))),
            version: e.getUint32(4, !0),
            length: e.getUint32(8, !0)
        }, this.header.magic !== Ug)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const i = this.header.length - ta,
            s = new DataView(t, ta);
        let o = 0;
        for (; o < i;) {
            const a = s.getUint32(o, !0);
            o += 4;
            const l = s.getUint32(o, !0);
            if (o += 4, l === Yp.JSON) {
                const c = new Uint8Array(t, ta + o, a);
                this.content = n.decode(c)
            } else if (l === Yp.BIN) {
                const c = ta + o;
                this.body = t.slice(c, c + a)
            }
            o += a
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class Nb {
    constructor(t, e)
    {
        if (!e)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = ae.KHR_DRACO_MESH_COMPRESSION,
        this.json = t,
        this.dracoLoader = e,
        this.dracoLoader.preload()
    }
    decodePrimitive(t, e)
    {
        const n = this.json,
            i = this.dracoLoader,
            s = t.extensions[this.name].bufferView,
            o = t.extensions[this.name].attributes,
            a = {},
            l = {},
            c = {};
        for (const h in o) {
            const u = Pu[h] || h.toLowerCase();
            a[u] = o[h]
        }
        for (const h in t.attributes) {
            const u = Pu[h] || h.toLowerCase();
            if (o[h] !== void 0) {
                const d = n.accessors[t.attributes[h]],
                    f = go[d.componentType];
                c[u] = f.name,
                l[u] = d.normalized === !0
            }
        }
        return e.getDependency("bufferView", s).then(function(h) {
            return new Promise(function(u, d) {
                i.decodeDracoFile(h, function(f) {
                    for (const m in f.attributes) {
                        const _ = f.attributes[m],
                            g = l[m];
                        g !== void 0 && (_.normalized = g)
                    }
                    u(f)
                }, a, c, dn, d)
            })
        })
    }
}
class Ib {
    constructor()
    {
        this.name = ae.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(t, e)
    {
        return (e.texCoord === void 0 || e.texCoord === t.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (t = t.clone(), e.texCoord !== void 0 && (t.channel = e.texCoord), e.offset !== void 0 && t.offset.fromArray(e.offset), e.rotation !== void 0 && (t.rotation = e.rotation), e.scale !== void 0 && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t
    }
}
class Fb {
    constructor()
    {
        this.name = ae.KHR_MESH_QUANTIZATION
    }
}
class Og extends Ka {
    constructor(t, e, n, i)
    {
        super(t, e, n, i)
    }
    copySampleValue_(t)
    {
        const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            s = t * i * 3 + i;
        for (let o = 0; o !== i; o++)
            e[o] = n[s + o];
        return e
    }
    interpolate_(t, e, n, i)
    {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = a * 2,
            c = a * 3,
            h = i - e,
            u = (n - e) / h,
            d = u * u,
            f = d * u,
            m = t * c,
            _ = m - c,
            g = -2 * f + 3 * d,
            p = f - d,
            x = 1 - g,
            v = p - d + u;
        for (let y = 0; y !== a; y++) {
            const C = o[_ + y + a],
                A = o[_ + y + l] * h,
                T = o[m + y + a],
                R = o[m + y] * h;
            s[y] = x * C + v * A + g * T + p * R
        }
        return s
    }
}
const Ub = new Wi;
class Ob extends Og {
    interpolate_(t, e, n, i)
    {
        const s = super.interpolate_(t, e, n, i);
        return Ub.fromArray(s).normalize().toArray(s), s
    }
}
const hi = {
        FLOAT: 5126,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    },
    go = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    },
    $p = {
        9728: Fn,
        9729: ti,
        9984: qm,
        9985: Xl,
        9986: ra,
        9987: hs
    },
    qp = {
        33071: Os,
        33648: lc,
        10497: bo
    },
    Mh = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    },
    Pu = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    },
    Ps = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    },
    zb = {
        CUBICSPLINE: void 0,
        LINEAR: Na,
        STEP: Da
    },
    Sh = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };
function Bb(r) {
    return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new Cd({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: _s
    })), r.DefaultMaterial
}
function rr(r, t, e) {
    for (const n in e.extensions)
        r[n] === void 0 && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = e.extensions[n])
}
function rs(r, t) {
    t.extras !== void 0 && (typeof t.extras == "object" ? Object.assign(r.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
}
function kb(r, t, e) {
    let n = !1,
        i = !1,
        s = !1;
    for (let c = 0, h = t.length; c < h; c++) {
        const u = t[c];
        if (u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (i = !0), u.COLOR_0 !== void 0 && (s = !0), n && i && s)
            break
    }
    if (!n && !i && !s)
        return Promise.resolve(r);
    const o = [],
        a = [],
        l = [];
    for (let c = 0, h = t.length; c < h; c++) {
        const u = t[c];
        if (n) {
            const d = u.POSITION !== void 0 ? e.getDependency("accessor", u.POSITION) : r.attributes.position;
            o.push(d)
        }
        if (i) {
            const d = u.NORMAL !== void 0 ? e.getDependency("accessor", u.NORMAL) : r.attributes.normal;
            a.push(d)
        }
        if (s) {
            const d = u.COLOR_0 !== void 0 ? e.getDependency("accessor", u.COLOR_0) : r.attributes.color;
            l.push(d)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
        const h = c[0],
            u = c[1],
            d = c[2];
        return n && (r.morphAttributes.position = h), i && (r.morphAttributes.normal = u), s && (r.morphAttributes.color = d), r.morphTargetsRelative = !0, r
    })
}
function Hb(r, t) {
    if (r.updateMorphTargets(), t.weights !== void 0)
        for (let e = 0, n = t.weights.length; e < n; e++)
            r.morphTargetInfluences[e] = t.weights[e];
    if (t.extras && Array.isArray(t.extras.targetNames)) {
        const e = t.extras.targetNames;
        if (r.morphTargetInfluences.length === e.length) {
            r.morphTargetDictionary = {};
            for (let n = 0, i = e.length; n < i; n++)
                r.morphTargetDictionary[e[n]] = n
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function Vb(r) {
    let t;
    const e = r.extensions && r.extensions[ae.KHR_DRACO_MESH_COMPRESSION];
    if (e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + Th(e.attributes) : t = r.indices + ":" + Th(r.attributes) + ":" + r.mode, r.targets !== void 0)
        for (let n = 0, i = r.targets.length; n < i; n++)
            t += ":" + Th(r.targets[n]);
    return t
}
function Th(r) {
    let t = "";
    const e = Object.keys(r).sort();
    for (let n = 0, i = e.length; n < i; n++)
        t += e[n] + ":" + r[e[n]] + ";";
    return t
}
function Lu(r) {
    switch (r) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function Gb(r) {
    return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const Wb = new le;
class Xb {
    constructor(t={}, e={})
    {
        this.json = t,
        this.extensions = {},
        this.plugins = {},
        this.options = e,
        this.cache = new fb,
        this.associations = new Map,
        this.primitiveCache = {},
        this.nodeCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        let n = !1,
            i = -1,
            s = !1,
            o = -1;
        if (typeof navigator < "u") {
            const a = navigator.userAgent;
            n = /^((?!chrome|android).)*safari/i.test(a) === !0;
            const l = a.match(/Version\/(\d+)/);
            i = n && l ? parseInt(l[1], 10) : -1,
            s = a.indexOf("Firefox") > -1,
            o = s ? a.match(/Firefox\/([0-9]+)\./)[1] : -1
        }
        typeof createImageBitmap > "u" || n && i < 17 || s && o < 98 ? this.textureLoader = new Fg(this.options.manager) : this.textureLoader = new BE(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new Ig(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(t)
    {
        this.extensions = t
    }
    setPlugins(t)
    {
        this.plugins = t
    }
    parse(t, e)
    {
        const n = this,
            i = this.json,
            s = this.extensions;
        this.cache.removeAll(),
        this.nodeCache = {},
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][i.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: i.asset,
                parser: n,
                userData: {}
            };
            return rr(s, a, i), rs(a, i), Promise.all(n._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                for (const l of a.scenes)
                    l.updateMatrixWorld();
                t(a)
            })
        }).catch(e)
    }
    _markDefs()
    {
        const t = this.json.nodes || [],
            e = this.json.skins || [],
            n = this.json.meshes || [];
        for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i].joints;
            for (let a = 0, l = o.length; a < l; a++)
                t[o[a]].isBone = !0
        }
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(t, e)
    {
        e !== void 0 && (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
    }
    _getNodeRef(t, e, n)
    {
        if (t.refs[e] <= 1)
            return n;
        const i = n.clone(),
            s = (o, a) => {
                const l = this.associations.get(o);
                l != null && this.associations.set(a, l);
                for (const [c, h] of o.children.entries())
                    s(h, a.children[c])
            };
        return s(n, i), i.name += "_instance_" + t.uses[e]++, i
    }
    _invokeOne(t)
    {
        const e = Object.values(this.plugins);
        e.push(this);
        for (let n = 0; n < e.length; n++) {
            const i = t(e[n]);
            if (i)
                return i
        }
        return null
    }
    _invokeAll(t)
    {
        const e = Object.values(this.plugins);
        e.unshift(this);
        const n = [];
        for (let i = 0; i < e.length; i++) {
            const s = t(e[i]);
            s && n.push(s)
        }
        return n
    }
    getDependency(t, e)
    {
        const n = t + ":" + e;
        let i = this.cache.get(n);
        if (!i) {
            switch (t) {
            case "scene":
                i = this.loadScene(e);
                break;
            case "node":
                i = this._invokeOne(function(s) {
                    return s.loadNode && s.loadNode(e)
                });
                break;
            case "mesh":
                i = this._invokeOne(function(s) {
                    return s.loadMesh && s.loadMesh(e)
                });
                break;
            case "accessor":
                i = this.loadAccessor(e);
                break;
            case "bufferView":
                i = this._invokeOne(function(s) {
                    return s.loadBufferView && s.loadBufferView(e)
                });
                break;
            case "buffer":
                i = this.loadBuffer(e);
                break;
            case "material":
                i = this._invokeOne(function(s) {
                    return s.loadMaterial && s.loadMaterial(e)
                });
                break;
            case "texture":
                i = this._invokeOne(function(s) {
                    return s.loadTexture && s.loadTexture(e)
                });
                break;
            case "skin":
                i = this.loadSkin(e);
                break;
            case "animation":
                i = this._invokeOne(function(s) {
                    return s.loadAnimation && s.loadAnimation(e)
                });
                break;
            case "camera":
                i = this.loadCamera(e);
                break;
            default:
                if (i = this._invokeOne(function(s) {
                    return s != this && s.getDependency && s.getDependency(t, e)
                }), !i)
                    throw new Error("Unknown type: " + t);
                break
            }
            this.cache.add(n, i)
        }
        return i
    }
    getDependencies(t)
    {
        let e = this.cache.get(t);
        if (!e) {
            const n = this,
                i = this.json[t + (t === "mesh" ? "es" : "s")] || [];
            e = Promise.all(i.map(function(s, o) {
                return n.getDependency(t, o)
            })),
            this.cache.add(t, e)
        }
        return e
    }
    loadBuffer(t)
    {
        const e = this.json.buffers[t],
            n = this.fileLoader;
        if (e.type && e.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
        if (e.uri === void 0 && t === 0)
            return Promise.resolve(this.extensions[ae.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function(s, o) {
            n.load(ga.resolveURL(e.uri, i.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
            })
        })
    }
    loadBufferView(t)
    {
        const e = this.json.bufferViews[t];
        return this.getDependency("buffer", e.buffer).then(function(n) {
            const i = e.byteLength || 0,
                s = e.byteOffset || 0;
            return n.slice(s, s + i)
        })
    }
    loadAccessor(t)
    {
        const e = this,
            n = this.json,
            i = this.json.accessors[t];
        if (i.bufferView === void 0 && i.sparse === void 0) {
            const o = Mh[i.type],
                a = go[i.componentType],
                l = i.normalized === !0,
                c = new a(i.count * o);
            return Promise.resolve(new zn(c, o, l))
        }
        const s = [];
        return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function(o) {
            const a = o[0],
                l = Mh[i.type],
                c = go[i.componentType],
                h = c.BYTES_PER_ELEMENT,
                u = h * l,
                d = i.byteOffset || 0,
                f = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0,
                m = i.normalized === !0;
            let _,
                g;
            if (f && f !== u) {
                const p = Math.floor(d / f),
                    x = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + p + ":" + i.count;
                let v = e.cache.get(x);
                v || (_ = new c(a, p * f, i.count * f / h), v = new hE(_, f / h), e.cache.add(x, v)),
                g = new bd(v, l, d % f / h, m)
            } else
                a === null ? _ = new c(i.count * l) : _ = new c(a, d, i.count * l),
                g = new zn(_, l, m);
            if (i.sparse !== void 0) {
                const p = Mh.SCALAR,
                    x = go[i.sparse.indices.componentType],
                    v = i.sparse.indices.byteOffset || 0,
                    y = i.sparse.values.byteOffset || 0,
                    C = new x(o[1], v, i.sparse.count * p),
                    A = new c(o[2], y, i.sparse.count * l);
                a !== null && (g = new zn(g.array.slice(), g.itemSize, g.normalized));
                for (let T = 0, R = C.length; T < R; T++) {
                    const E = C[T];
                    if (g.setX(E, A[T * l]), l >= 2 && g.setY(E, A[T * l + 1]), l >= 3 && g.setZ(E, A[T * l + 2]), l >= 4 && g.setW(E, A[T * l + 3]), l >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return g
        })
    }
    loadTexture(t)
    {
        const e = this.json,
            n = this.options,
            s = e.textures[t].source,
            o = e.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const l = n.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(t, s, a)
    }
    loadTextureImage(t, e, n)
    {
        const i = this,
            s = this.json,
            o = s.textures[t],
            a = s.images[e],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l])
            return this.textureCache[l];
        const c = this.loadImageSource(e, n).then(function(h) {
            h.flipY = !1,
            h.name = o.name || a.name || "",
            h.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (h.name = a.uri);
            const d = (s.samplers || {})[o.sampler] || {};
            return h.magFilter = $p[d.magFilter] || ti, h.minFilter = $p[d.minFilter] || hs, h.wrapS = qp[d.wrapS] || bo, h.wrapT = qp[d.wrapT] || bo, i.associations.set(h, {
                textures: t
            }), h
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = c, c
    }
    loadImageSource(t, e)
    {
        const n = this,
            i = this.json,
            s = this.options;
        if (this.sourceCache[t] !== void 0)
            return this.sourceCache[t].then(u => u.clone());
        const o = i.images[t],
            a = self.URL || self.webkitURL;
        let l = o.uri || "",
            c = !1;
        if (o.bufferView !== void 0)
            l = n.getDependency("bufferView", o.bufferView).then(function(u) {
                c = !0;
                const d = new Blob([u], {
                    type: o.mimeType
                });
                return l = a.createObjectURL(d), l
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
        const h = Promise.resolve(l).then(function(u) {
            return new Promise(function(d, f) {
                let m = d;
                e.isImageBitmapLoader === !0 && (m = function(_) {
                    const g = new an(_);
                    g.needsUpdate = !0,
                    d(g)
                }),
                e.load(ga.resolveURL(u, s.path), m, void 0, f)
            })
        }).then(function(u) {
            return c === !0 && a.revokeObjectURL(l), rs(u, o), u.userData.mimeType = o.mimeType || Gb(o.uri), u
        }).catch(function(u) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l), u
        });
        return this.sourceCache[t] = h, h
    }
    assignTexture(t, e, n, i)
    {
        const s = this;
        return this.getDependency("texture", n.index).then(function(o) {
            if (!o)
                return null;
            if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(), o.channel = n.texCoord), s.extensions[ae.KHR_TEXTURE_TRANSFORM]) {
                const a = n.extensions !== void 0 ? n.extensions[ae.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = s.associations.get(o);
                    o = s.extensions[ae.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    s.associations.set(o, l)
                }
            }
            return i !== void 0 && (o.colorSpace = i), t[e] = o, o
        })
    }
    assignFinalMaterial(t)
    {
        const e = t.geometry;
        let n = t.material;
        const i = e.attributes.tangent === void 0,
            s = e.attributes.color !== void 0,
            o = e.attributes.normal === void 0;
        if (t.isPoints) {
            const a = "PointsMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new Lg, Li.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)),
            n = l
        } else if (t.isLine) {
            const a = "LineBasicMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new Pg, Li.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)),
            n = l
        }
        if (i || s || o) {
            let a = "ClonedMaterial:" + n.uuid + ":";
            i && (a += "derivative-tangents:"),
            s && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = n.clone(), s && (l.vertexColors = !0), o && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))),
            n = l
        }
        t.material = n
    }
    getMaterialType()
    {
        return Cd
    }
    loadMaterial(t)
    {
        const e = this,
            n = this.json,
            i = this.extensions,
            s = n.materials[t];
        let o;
        const a = {},
            l = s.extensions || {},
            c = [];
        if (l[ae.KHR_MATERIALS_UNLIT]) {
            const u = i[ae.KHR_MATERIALS_UNLIT];
            o = u.getMaterialType(),
            c.push(u.extendParams(a, s, e))
        } else {
            const u = s.pbrMetallicRoughness || {};
            if (a.color = new Gt(1, 1, 1), a.opacity = 1, Array.isArray(u.baseColorFactor)) {
                const d = u.baseColorFactor;
                a.color.setRGB(d[0], d[1], d[2], dn),
                a.opacity = d[3]
            }
            u.baseColorTexture !== void 0 && c.push(e.assignTexture(a, "map", u.baseColorTexture, Ln)),
            a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1,
            a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1,
            u.metallicRoughnessTexture !== void 0 && (c.push(e.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)), c.push(e.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture))),
            o = this._invokeOne(function(d) {
                return d.getMaterialType && d.getMaterialType(t)
            }),
            c.push(Promise.all(this._invokeAll(function(d) {
                return d.extendMaterialParams && d.extendMaterialParams(t, a)
            })))
        }
        s.doubleSided === !0 && (a.side = wi);
        const h = s.alphaMode || Sh.OPAQUE;
        if (h === Sh.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, h === Sh.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== zs && (c.push(e.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new St(1, 1), s.normalTexture.scale !== void 0)) {
            const u = s.normalTexture.scale;
            a.normalScale.set(u, u)
        }
        if (s.occlusionTexture !== void 0 && o !== zs && (c.push(e.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== zs) {
            const u = s.emissiveFactor;
            a.emissive = new Gt().setRGB(u[0], u[1], u[2], dn)
        }
        return s.emissiveTexture !== void 0 && o !== zs && c.push(e.assignTexture(a, "emissiveMap", s.emissiveTexture, Ln)), Promise.all(c).then(function() {
            const u = new o(a);
            return s.name && (u.name = s.name), rs(u, s), e.associations.set(u, {
                materials: t
            }), s.extensions && rr(i, u, s), u
        })
    }
    createUniqueName(t)
    {
        const e = Me.sanitizeNodeName(t || "");
        return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e)
    }
    loadGeometries(t)
    {
        const e = this,
            n = this.extensions,
            i = this.primitiveCache;
        function s(a) {
            return n[ae.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, e).then(function(l) {
                return Kp(l, a, e)
            })
        }
        const o = [];
        for (let a = 0, l = t.length; a < l; a++) {
            const c = t[a],
                h = Vb(c),
                u = i[h];
            if (u)
                o.push(u.promise);
            else {
                let d;
                c.extensions && c.extensions[ae.KHR_DRACO_MESH_COMPRESSION] ? d = s(c) : d = Kp(new Ni, c, e),
                i[h] = {
                    primitive: c,
                    promise: d
                },
                o.push(d)
            }
        }
        return Promise.all(o)
    }
    loadMesh(t)
    {
        const e = this,
            n = this.json,
            i = this.extensions,
            s = n.meshes[t],
            o = s.primitives,
            a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const h = o[l].material === void 0 ? Bb(this.cache) : this.getDependency("material", o[l].material);
            a.push(h)
        }
        return a.push(e.loadGeometries(o)), Promise.all(a).then(function(l) {
            const c = l.slice(0, l.length - 1),
                h = l[l.length - 1],
                u = [];
            for (let f = 0, m = h.length; f < m; f++) {
                const _ = h[f],
                    g = o[f];
                let p;
                const x = c[f];
                if (g.mode === hi.TRIANGLES || g.mode === hi.TRIANGLE_STRIP || g.mode === hi.TRIANGLE_FAN || g.mode === void 0)
                    p = s.isSkinnedMesh === !0 ? new dE(_, x) : new Un(_, x),
                    p.isSkinnedMesh === !0 && p.normalizeSkinWeights(),
                    g.mode === hi.TRIANGLE_STRIP ? p.geometry = Xp(p.geometry, sg) : g.mode === hi.TRIANGLE_FAN && (p.geometry = Xp(p.geometry, Tu));
                else if (g.mode === hi.LINES)
                    p = new gE(_, x);
                else if (g.mode === hi.LINE_STRIP)
                    p = new Ad(_, x);
                else if (g.mode === hi.LINE_LOOP)
                    p = new _E(_, x);
                else if (g.mode === hi.POINTS)
                    p = new xE(_, x);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
                Object.keys(p.geometry.morphAttributes).length > 0 && Hb(p, s),
                p.name = e.createUniqueName(s.name || "mesh_" + t),
                rs(p, s),
                g.extensions && rr(i, p, g),
                e.assignFinalMaterial(p),
                u.push(p)
            }
            for (let f = 0, m = u.length; f < m; f++)
                e.associations.set(u[f], {
                    meshes: t,
                    primitives: f
                });
            if (u.length === 1)
                return s.extensions && rr(i, u[0], s), u[0];
            const d = new ds;
            s.extensions && rr(i, d, s),
            e.associations.set(d, {
                meshes: t
            });
            for (let f = 0, m = u.length; f < m; f++)
                d.add(u[f]);
            return d
        })
    }
    loadCamera(t)
    {
        let e;
        const n = this.json.cameras[t],
            i = n[n.type];
        if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return n.type === "perspective" ? e = new yn(fc.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (e = new Lc(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), rs(e, n), Promise.resolve(e)
    }
    loadSkin(t)
    {
        const e = this.json.skins[t],
            n = [];
        for (let i = 0, s = e.joints.length; i < s; i++)
            n.push(this._loadNodeShallow(e.joints[i]));
        return e.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", e.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
            const s = i.pop(),
                o = i,
                a = [],
                l = [];
            for (let c = 0, h = o.length; c < h; c++) {
                const u = o[c];
                if (u) {
                    a.push(u);
                    const d = new le;
                    s !== null && d.fromArray(s.array, c * 16),
                    l.push(d)
                } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[c])
            }
            return new wd(a, l)
        })
    }
    loadAnimation(t)
    {
        const e = this.json,
            n = this,
            i = e.animations[t],
            s = i.name ? i.name : "animation_" + t,
            o = [],
            a = [],
            l = [],
            c = [],
            h = [];
        for (let u = 0, d = i.channels.length; u < d; u++) {
            const f = i.channels[u],
                m = i.samplers[f.sampler],
                _ = f.target,
                g = _.node,
                p = i.parameters !== void 0 ? i.parameters[m.input] : m.input,
                x = i.parameters !== void 0 ? i.parameters[m.output] : m.output;
            _.node !== void 0 && (o.push(this.getDependency("node", g)), a.push(this.getDependency("accessor", p)), l.push(this.getDependency("accessor", x)), c.push(m), h.push(_))
        }
        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c), Promise.all(h)]).then(function(u) {
            const d = u[0],
                f = u[1],
                m = u[2],
                _ = u[3],
                g = u[4],
                p = [];
            for (let x = 0, v = d.length; x < v; x++) {
                const y = d[x],
                    C = f[x],
                    A = m[x],
                    T = _[x],
                    R = g[x];
                if (y === void 0)
                    continue;
                y.updateMatrix && y.updateMatrix();
                const E = n._createAnimationTracks(y, C, A, T, R);
                if (E)
                    for (let M = 0; M < E.length; M++)
                        p.push(E[M])
            }
            return new wE(s, void 0, p)
        })
    }
    createNodeMesh(t)
    {
        const e = this.json,
            n = this,
            i = e.nodes[t];
        return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(s) {
            const o = n._getNodeRef(n.meshCache, i.mesh, s);
            return i.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, c = i.weights.length; l < c; l++)
                        a.morphTargetInfluences[l] = i.weights[l]
            }), o
        })
    }
    loadNode(t)
    {
        const e = this.json,
            n = this,
            i = e.nodes[t],
            s = n._loadNodeShallow(t),
            o = [],
            a = i.children || [];
        for (let c = 0, h = a.length; c < h; c++)
            o.push(n.getDependency("node", a[c]));
        const l = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
        return Promise.all([s, Promise.all(o), l]).then(function(c) {
            const h = c[0],
                u = c[1],
                d = c[2];
            d !== null && h.traverse(function(f) {
                f.isSkinnedMesh && f.bind(d, Wb)
            });
            for (let f = 0, m = u.length; f < m; f++)
                h.add(u[f]);
            return h
        })
    }
    _loadNodeShallow(t)
    {
        const e = this.json,
            n = this.extensions,
            i = this;
        if (this.nodeCache[t] !== void 0)
            return this.nodeCache[t];
        const s = e.nodes[t],
            o = s.name ? i.createUniqueName(s.name) : "",
            a = [],
            l = i._invokeOne(function(c) {
                return c.createNodeMesh && c.createNodeMesh(t)
            });
        return l && a.push(l), s.camera !== void 0 && a.push(i.getDependency("camera", s.camera).then(function(c) {
            return i._getNodeRef(i.cameraCache, s.camera, c)
        })), i._invokeAll(function(c) {
            return c.createNodeAttachment && c.createNodeAttachment(t)
        }).forEach(function(c) {
            a.push(c)
        }), this.nodeCache[t] = Promise.all(a).then(function(c) {
            let h;
            if (s.isBone === !0 ? h = new Cg : c.length > 1 ? h = new ds : c.length === 1 ? h = c[0] : h = new He, h !== c[0])
                for (let u = 0, d = c.length; u < d; u++)
                    h.add(c[u]);
            if (s.name && (h.userData.name = s.name, h.name = o), rs(h, s), s.extensions && rr(n, h, s), s.matrix !== void 0) {
                const u = new le;
                u.fromArray(s.matrix),
                h.applyMatrix4(u)
            } else
                s.translation !== void 0 && h.position.fromArray(s.translation),
                s.rotation !== void 0 && h.quaternion.fromArray(s.rotation),
                s.scale !== void 0 && h.scale.fromArray(s.scale);
            return i.associations.has(h) || i.associations.set(h, {}), i.associations.get(h).nodes = t, h
        }), this.nodeCache[t]
    }
    loadScene(t)
    {
        const e = this.extensions,
            n = this.json.scenes[t],
            i = this,
            s = new ds;
        n.name && (s.name = i.createUniqueName(n.name)),
        rs(s, n),
        n.extensions && rr(e, s, n);
        const o = n.nodes || [],
            a = [];
        for (let l = 0, c = o.length; l < c; l++)
            a.push(i.getDependency("node", o[l]));
        return Promise.all(a).then(function(l) {
            for (let h = 0, u = l.length; h < u; h++)
                s.add(l[h]);
            const c = h => {
                const u = new Map;
                for (const [d, f] of i.associations)
                    (d instanceof Li || d instanceof an) && u.set(d, f);
                return h.traverse(d => {
                    const f = i.associations.get(d);
                    f != null && u.set(d, f)
                }), u
            };
            return i.associations = c(s), s
        })
    }
    _createAnimationTracks(t, e, n, i, s)
    {
        const o = [],
            a = t.name ? t.name : t.uuid,
            l = [];
        Ps[s.path] === Ps.weights ? t.traverse(function(d) {
            d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid)
        }) : l.push(a);
        let c;
        switch (Ps[s.path]) {
        case Ps.weights:
            c = Po;
            break;
        case Ps.rotation:
            c = Lo;
            break;
        case Ps.position:
        case Ps.scale:
            c = Do;
            break;
        default:
            switch (n.itemSize) {
            case 1:
                c = Po;
                break;
            case 2:
            case 3:
            default:
                c = Do;
                break
            }
            break
        }
        const h = i.interpolation !== void 0 ? zb[i.interpolation] : Na,
            u = this._getArrayFromAccessor(n);
        for (let d = 0, f = l.length; d < f; d++) {
            const m = new c(l[d] + "." + Ps[s.path], e.array, u, h);
            i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m),
            o.push(m)
        }
        return o
    }
    _getArrayFromAccessor(t)
    {
        let e = t.array;
        if (t.normalized) {
            const n = Lu(e.constructor),
                i = new Float32Array(e.length);
            for (let s = 0, o = e.length; s < o; s++)
                i[s] = e[s] * n;
            e = i
        }
        return e
    }
    _createCubicSplineTrackInterpolant(t)
    {
        t.createInterpolant = function(n) {
            const i = this instanceof Lo ? Ob : Og;
            return new i(this.times, this.values, this.getValueSize() / 3, n)
        },
        t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}
function Yb(r, t, e) {
    const n = t.attributes,
        i = new Ms;
    if (n.POSITION !== void 0) {
        const a = e.json.accessors[n.POSITION],
            l = a.min,
            c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (i.set(new O(l[0], l[1], l[2]), new O(c[0], c[1], c[2])), a.normalized) {
                const h = Lu(go[a.componentType]);
                i.min.multiplyScalar(h),
                i.max.multiplyScalar(h)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const s = t.targets;
    if (s !== void 0) {
        const a = new O,
            l = new O;
        for (let c = 0, h = s.length; c < h; c++) {
            const u = s[c];
            if (u.POSITION !== void 0) {
                const d = e.json.accessors[u.POSITION],
                    f = d.min,
                    m = d.max;
                if (f !== void 0 && m !== void 0) {
                    if (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))), d.normalized) {
                        const _ = Lu(go[d.componentType]);
                        l.multiplyScalar(_)
                    }
                    a.max(l)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(a)
    }
    r.boundingBox = i;
    const o = new $i;
    i.getCenter(o.center),
    o.radius = i.min.distanceTo(i.max) / 2,
    r.boundingSphere = o
}
function Kp(r, t, e) {
    const n = t.attributes,
        i = [];
    function s(o, a) {
        return e.getDependency("accessor", o).then(function(l) {
            r.setAttribute(a, l)
        })
    }
    for (const o in n) {
        const a = Pu[o] || o.toLowerCase();
        a in r.attributes || i.push(s(n[o], a))
    }
    if (t.indices !== void 0 && !r.index) {
        const o = e.getDependency("accessor", t.indices).then(function(a) {
            r.setIndex(a)
        });
        i.push(o)
    }
    return me.workingColorSpace !== dn && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${me.workingColorSpace}" not supported.`), rs(r, t), Yb(r, t, e), Promise.all(i).then(function() {
        return t.targets !== void 0 ? kb(r, t.targets, e) : r
    })
}
class ja {
    constructor()
    {
        this.isPass = !0,
        this.enabled = !0,
        this.needsSwap = !0,
        this.clear = !1,
        this.renderToScreen = !1
    }
    setSize() {}
    render()
    {
        console.error("THREE.Pass: .render() must be implemented in derived pass.")
    }
    dispose() {}
}
const $b = new Lc(-1, 1, 1, -1, 0, 1);
class qb extends Ni {
    constructor()
    {
        super(),
        this.setAttribute("position", new Di([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
        this.setAttribute("uv", new Di([0, 2, 0, 0, 2, 0], 2))
    }
}
const Kb = new qb;
class zg {
    constructor(t)
    {
        this._mesh = new Un(Kb, t)
    }
    dispose()
    {
        this._mesh.geometry.dispose()
    }
    render(t)
    {
        t.render(this._mesh, $b)
    }
    get material()
    {
        return this._mesh.material
    }
    set material(t)
    {
        this._mesh.material = t
    }
}
const Bg = {
    name: "CopyShader",
    uniforms: {
        tDiffuse: {
            value: null
        },
        opacity: {
            value: 1
        }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`








    ,
    fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`













};
class Du extends ja {
    constructor(t, e)
    {
        super(),
        this.textureID = e !== void 0 ? e : "tDiffuse",
        t instanceof On ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = pc.clone(t.uniforms), this.material = new On({
            name: t.name !== void 0 ? t.name : "unspecified",
            defines: Object.assign({}, t.defines),
            uniforms: this.uniforms,
            vertexShader: t.vertexShader,
            fragmentShader: t.fragmentShader
        })),
        this.fsQuad = new zg(this.material)
    }
    render(t, e, n)
    {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture),
        this.fsQuad.material = this.material,
        this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
    }
    dispose()
    {
        this.material.dispose(),
        this.fsQuad.dispose()
    }
}
class jp extends ja {
    constructor(t, e)
    {
        super(),
        this.scene = t,
        this.camera = e,
        this.clear = !0,
        this.needsSwap = !1,
        this.inverse = !1
    }
    render(t, e, n)
    {
        const i = t.getContext(),
            s = t.state;
        s.buffers.color.setMask(!1),
        s.buffers.depth.setMask(!1),
        s.buffers.color.setLocked(!0),
        s.buffers.depth.setLocked(!0);
        let o,
            a;
        this.inverse ? (o = 0, a = 1) : (o = 1, a = 0),
        s.buffers.stencil.setTest(!0),
        s.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
        s.buffers.stencil.setFunc(i.ALWAYS, o, 4294967295),
        s.buffers.stencil.setClear(a),
        s.buffers.stencil.setLocked(!0),
        t.setRenderTarget(n),
        this.clear && t.clear(),
        t.render(this.scene, this.camera),
        t.setRenderTarget(e),
        this.clear && t.clear(),
        t.render(this.scene, this.camera),
        s.buffers.color.setLocked(!1),
        s.buffers.depth.setLocked(!1),
        s.buffers.color.setMask(!0),
        s.buffers.depth.setMask(!0),
        s.buffers.stencil.setLocked(!1),
        s.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
        s.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
        s.buffers.stencil.setLocked(!0)
    }
}
class jb extends ja {
    constructor()
    {
        super(),
        this.needsSwap = !1
    }
    render(t)
    {
        t.state.buffers.stencil.setLocked(!1),
        t.state.buffers.stencil.setTest(!1)
    }
}
class Zb {
    constructor(t, e)
    {
        if (this.renderer = t, this._pixelRatio = t.getPixelRatio(), e === void 0) {
            const n = t.getSize(new St);
            this._width = n.width,
            this._height = n.height,
            e = new Pi(this._width * this._pixelRatio, this._height * this._pixelRatio, {
                type: ms
            }),
            e.texture.name = "EffectComposer.rt1"
        } else
            this._width = e.width,
            this._height = e.height;
        this.renderTarget1 = e,
        this.renderTarget2 = e.clone(),
        this.renderTarget2.texture.name = "EffectComposer.rt2",
        this.writeBuffer = this.renderTarget1,
        this.readBuffer = this.renderTarget2,
        this.renderToScreen = !0,
        this.passes = [],
        this.copyPass = new Du(Bg),
        this.copyPass.material.blending = ps,
        this.clock = new kE
    }
    swapBuffers()
    {
        const t = this.readBuffer;
        this.readBuffer = this.writeBuffer,
        this.writeBuffer = t
    }
    addPass(t)
    {
        this.passes.push(t),
        t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }
    insertPass(t, e)
    {
        this.passes.splice(e, 0, t),
        t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }
    removePass(t)
    {
        const e = this.passes.indexOf(t);
        e !== -1 && this.passes.splice(e, 1)
    }
    isLastEnabledPass(t)
    {
        for (let e = t + 1; e < this.passes.length; e++)
            if (this.passes[e].enabled)
                return !1;
        return !0
    }
    render(t)
    {
        t === void 0 && (t = this.clock.getDelta());
        const e = this.renderer.getRenderTarget();
        let n = !1;
        for (let i = 0, s = this.passes.length; i < s; i++) {
            const o = this.passes[i];
            if (o.enabled !== !1) {
                if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i), o.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), o.needsSwap) {
                    if (n) {
                        const a = this.renderer.getContext(),
                            l = this.renderer.state.buffers.stencil;
                        l.setFunc(a.NOTEQUAL, 1, 4294967295),
                        this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t),
                        l.setFunc(a.EQUAL, 1, 4294967295)
                    }
                    this.swapBuffers()
                }
                jp !== void 0 && (o instanceof jp ? n = !0 : o instanceof jb && (n = !1))
            }
        }
        this.renderer.setRenderTarget(e)
    }
    reset(t)
    {
        if (t === void 0) {
            const e = this.renderer.getSize(new St);
            this._pixelRatio = this.renderer.getPixelRatio(),
            this._width = e.width,
            this._height = e.height,
            t = this.renderTarget1.clone(),
            t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }
        this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        this.renderTarget1 = t,
        this.renderTarget2 = t.clone(),
        this.writeBuffer = this.renderTarget1,
        this.readBuffer = this.renderTarget2
    }
    setSize(t, e)
    {
        this._width = t,
        this._height = e;
        const n = this._width * this._pixelRatio,
            i = this._height * this._pixelRatio;
        this.renderTarget1.setSize(n, i),
        this.renderTarget2.setSize(n, i);
        for (let s = 0; s < this.passes.length; s++)
            this.passes[s].setSize(n, i)
    }
    setPixelRatio(t)
    {
        this._pixelRatio = t,
        this.setSize(this._width, this._height)
    }
    dispose()
    {
        this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        this.copyPass.dispose()
    }
}
class Jb extends ja {
    constructor(t, e, n=null, i=null, s=null)
    {
        super(),
        this.scene = t,
        this.camera = e,
        this.overrideMaterial = n,
        this.clearColor = i,
        this.clearAlpha = s,
        this.clear = !0,
        this.clearDepth = !1,
        this.needsSwap = !1,
        this._oldClearColor = new Gt
    }
    render(t, e, n)
    {
        const i = t.autoClear;
        t.autoClear = !1;
        let s,
            o;
        this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial),
        this.clearColor !== null && (t.getClearColor(this._oldClearColor), t.setClearColor(this.clearColor, t.getClearAlpha())),
        this.clearAlpha !== null && (s = t.getClearAlpha(), t.setClearAlpha(this.clearAlpha)),
        this.clearDepth == !0 && t.clearDepth(),
        t.setRenderTarget(this.renderToScreen ? null : n),
        this.clear === !0 && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
        t.render(this.scene, this.camera),
        this.clearColor !== null && t.setClearColor(this._oldClearColor),
        this.clearAlpha !== null && t.setClearAlpha(s),
        this.overrideMaterial !== null && (this.scene.overrideMaterial = o),
        t.autoClear = i
    }
}
const Qb = {
    name: "LuminosityHighPassShader",
    shaderID: "luminosityHighPass",
    uniforms: {
        tDiffuse: {
            value: null
        },
        luminosityThreshold: {
            value: 1
        },
        smoothWidth: {
            value: 1
        },
        defaultColor: {
            value: new Gt(0)
        },
        defaultOpacity: {
            value: 0
        }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`









    ,
    fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`





















};
class No extends ja {
    constructor(t, e, n, i)
    {
        super(),
        this.strength = e !== void 0 ? e : 1,
        this.radius = n,
        this.threshold = i,
        this.resolution = t !== void 0 ? new St(t.x, t.y) : new St(256, 256),
        this.clearColor = new Gt(0, 0, 0),
        this.renderTargetsHorizontal = [],
        this.renderTargetsVertical = [],
        this.nMips = 5;
        let s = Math.round(this.resolution.x / 2),
            o = Math.round(this.resolution.y / 2);
        this.renderTargetBright = new Pi(s, o, {
            type: ms
        }),
        this.renderTargetBright.texture.name = "UnrealBloomPass.bright",
        this.renderTargetBright.texture.generateMipmaps = !1;
        for (let u = 0; u < this.nMips; u++) {
            const d = new Pi(s, o, {
                type: ms
            });
            d.texture.name = "UnrealBloomPass.h" + u,
            d.texture.generateMipmaps = !1,
            this.renderTargetsHorizontal.push(d);
            const f = new Pi(s, o, {
                type: ms
            });
            f.texture.name = "UnrealBloomPass.v" + u,
            f.texture.generateMipmaps = !1,
            this.renderTargetsVertical.push(f),
            s = Math.round(s / 2),
            o = Math.round(o / 2)
        }
        const a = Qb;
        this.highPassUniforms = pc.clone(a.uniforms),
        this.highPassUniforms.luminosityThreshold.value = i,
        this.highPassUniforms.smoothWidth.value = .01,
        this.materialHighPassFilter = new On({
            uniforms: this.highPassUniforms,
            vertexShader: a.vertexShader,
            fragmentShader: a.fragmentShader
        }),
        this.separableBlurMaterials = [];
        const l = [3, 5, 7, 9, 11];
        s = Math.round(this.resolution.x / 2),
        o = Math.round(this.resolution.y / 2);
        for (let u = 0; u < this.nMips; u++)
            this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[u])),
            this.separableBlurMaterials[u].uniforms.invSize.value = new St(1 / s, 1 / o),
            s = Math.round(s / 2),
            o = Math.round(o / 2);
        this.compositeMaterial = this.getCompositeMaterial(this.nMips),
        this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture,
        this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture,
        this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture,
        this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture,
        this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture,
        this.compositeMaterial.uniforms.bloomStrength.value = e,
        this.compositeMaterial.uniforms.bloomRadius.value = .1;
        const c = [1, .8, .6, .4, .2];
        this.compositeMaterial.uniforms.bloomFactors.value = c,
        this.bloomTintColors = [new O(1, 1, 1), new O(1, 1, 1), new O(1, 1, 1), new O(1, 1, 1), new O(1, 1, 1)],
        this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
        const h = Bg;
        this.copyUniforms = pc.clone(h.uniforms),
        this.blendMaterial = new On({
            uniforms: this.copyUniforms,
            vertexShader: h.vertexShader,
            fragmentShader: h.fragmentShader,
            blending: Yh,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }),
        this.enabled = !0,
        this.needsSwap = !1,
        this._oldClearColor = new Gt,
        this.oldClearAlpha = 1,
        this.basic = new zs,
        this.fsQuad = new zg(null)
    }
    dispose()
    {
        for (let t = 0; t < this.renderTargetsHorizontal.length; t++)
            this.renderTargetsHorizontal[t].dispose();
        for (let t = 0; t < this.renderTargetsVertical.length; t++)
            this.renderTargetsVertical[t].dispose();
        this.renderTargetBright.dispose();
        for (let t = 0; t < this.separableBlurMaterials.length; t++)
            this.separableBlurMaterials[t].dispose();
        this.compositeMaterial.dispose(),
        this.blendMaterial.dispose(),
        this.basic.dispose(),
        this.fsQuad.dispose()
    }
    setSize(t, e)
    {
        let n = Math.round(t / 2),
            i = Math.round(e / 2);
        this.renderTargetBright.setSize(n, i);
        for (let s = 0; s < this.nMips; s++)
            this.renderTargetsHorizontal[s].setSize(n, i),
            this.renderTargetsVertical[s].setSize(n, i),
            this.separableBlurMaterials[s].uniforms.invSize.value = new St(1 / n, 1 / i),
            n = Math.round(n / 2),
            i = Math.round(i / 2)
    }
    render(t, e, n, i, s)
    {
        t.getClearColor(this._oldClearColor),
        this.oldClearAlpha = t.getClearAlpha();
        const o = t.autoClear;
        t.autoClear = !1,
        t.setClearColor(this.clearColor, 0),
        s && t.state.buffers.stencil.setTest(!1),
        this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, t.setRenderTarget(null), t.clear(), this.fsQuad.render(t)),
        this.highPassUniforms.tDiffuse.value = n.texture,
        this.highPassUniforms.luminosityThreshold.value = this.threshold,
        this.fsQuad.material = this.materialHighPassFilter,
        t.setRenderTarget(this.renderTargetBright),
        t.clear(),
        this.fsQuad.render(t);
        let a = this.renderTargetBright;
        for (let l = 0; l < this.nMips; l++)
            this.fsQuad.material = this.separableBlurMaterials[l],
            this.separableBlurMaterials[l].uniforms.colorTexture.value = a.texture,
            this.separableBlurMaterials[l].uniforms.direction.value = No.BlurDirectionX,
            t.setRenderTarget(this.renderTargetsHorizontal[l]),
            t.clear(),
            this.fsQuad.render(t),
            this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture,
            this.separableBlurMaterials[l].uniforms.direction.value = No.BlurDirectionY,
            t.setRenderTarget(this.renderTargetsVertical[l]),
            t.clear(),
            this.fsQuad.render(t),
            a = this.renderTargetsVertical[l];
        this.fsQuad.material = this.compositeMaterial,
        this.compositeMaterial.uniforms.bloomStrength.value = this.strength,
        this.compositeMaterial.uniforms.bloomRadius.value = this.radius,
        this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors,
        t.setRenderTarget(this.renderTargetsHorizontal[0]),
        t.clear(),
        this.fsQuad.render(t),
        this.fsQuad.material = this.blendMaterial,
        this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture,
        s && t.state.buffers.stencil.setTest(!0),
        this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(n), this.fsQuad.render(t)),
        t.setClearColor(this._oldClearColor, this.oldClearAlpha),
        t.autoClear = o
    }
    getSeperableBlurMaterial(t)
    {
        const e = [];
        for (let n = 0; n < t; n++)
            e.push(.39894 * Math.exp(-.5 * n * n / (t * t)) / t);
        return new On({
            defines: {
                KERNEL_RADIUS: t
            },
            uniforms: {
                colorTexture: {
                    value: null
                },
                invSize: {
                    value: new St(.5, .5)
                },
                direction: {
                    value: new St(.5, .5)
                },
                gaussianCoefficients: {
                    value: e
                }
            },
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`



            ,
            fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`



















        })
    }
    getCompositeMaterial(t)
    {
        return new On({
            defines: {
                NUM_MIPS: t
            },
            uniforms: {
                blurTexture1: {
                    value: null
                },
                blurTexture2: {
                    value: null
                },
                blurTexture3: {
                    value: null
                },
                blurTexture4: {
                    value: null
                },
                blurTexture5: {
                    value: null
                },
                bloomStrength: {
                    value: 1
                },
                bloomFactors: {
                    value: null
                },
                bloomTintColors: {
                    value: null
                },
                bloomRadius: {
                    value: 0
                }
            },
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`



            ,
            fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`





















        })
    }
}
No.BlurDirectionX = new St(1, 0);
No.BlurDirectionY = new St(0, 1);
const tw = {
        name: "GrainShader",
        uniforms: {
            tDiffuse: {
                value: null
            },
            tSize: {
                value: new St(256, 256)
            },
            center: {
                value: new St(.5, .5)
            },
            angle: {
                value: 1.57
            },
            scale: {
                value: 1
            }
        },
        vertexShader: `
		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`







        ,
        fragmentShader: `
		uniform sampler2D tDiffuse;

		varying vec2 vUv;

        float rand(vec2 p) {
            vec2 k1 = vec2(
                23.14069263277926, // e^pi (Gelfond's constant)
                2.665144142690225 // 2^sqrt(2) (Gelfond–Schneider constant)
            );
            return fract(
                cos(dot(p, k1)) * 12345.6789
            );
        }

		void main() {

			vec4 color = texture2D( tDiffuse, vUv );
            vec2 uvRandom = vUv;
            uvRandom.x *= rand(vec2(uvRandom.x, 0.2353));
			float average = ( color.r + color.g + color.b ) / 3.0;
            float strength =  smoothstep(0.1, 0.2, average);
            color.rgb += rand( uvRandom) * 0.1 * strength;
            gl_FragColor = color;
		}`























    },
    ew = {
        name: "BlurShader",
        uniforms: {
            tDiffuse: {
                value: null
            },
            resolution: {
                value: new St(256, 256)
            },
            radius: {
                value: 5
            }
        },
        vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`








        ,
        fragmentShader: `

		uniform sampler2D tDiffuse; // Input texture
        uniform vec2 resolution;    // Resolution of the texture
        uniform float radius;       // Blur radius

        varying vec2 vUv;

        void main() {
 vec2 texelSize = vec2(1.0) / resolution;
    vec4 color = vec4(0.0);

    // Hardcoded weights for a simple 9-tap Gaussian blur
    float weight[5] = float[](0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

    // Sample the texture at 9 offsets (4 in each direction)
    color += texture2D(tDiffuse, vUv) * weight[0];
    color += texture2D(tDiffuse, vUv + vec2(texelSize.x * radius, 0.0)) * weight[1];
    color += texture2D(tDiffuse, vUv - vec2(texelSize.x * radius, 0.0)) * weight[1];
    color += texture2D(tDiffuse, vUv + vec2(0.0, texelSize.y * radius)) * weight[1];
    color += texture2D(tDiffuse, vUv - vec2(0.0, texelSize.y * radius)) * weight[1];

    color += texture2D(tDiffuse, vUv + vec2(texelSize.x * 2.0 * radius, 0.0)) * weight[2];
    color += texture2D(tDiffuse, vUv - vec2(texelSize.x * 2.0 * radius, 0.0)) * weight[2];
    color += texture2D(tDiffuse, vUv + vec2(0.0, texelSize.y * 2.0 * radius)) * weight[2];
    color += texture2D(tDiffuse, vUv - vec2(0.0, texelSize.y * 2.0 * radius)) * weight[2];

    gl_FragColor = color;
        }`



























    };
class nw {
    constructor(t)
    {
        this.mouse = new St,
        me.enabled = !0,
        this.container = t.dom,
        this.width = this.container.offsetWidth,
        this.height = this.container.offsetHeight,
        this.time = 0,
        this.setup(),
        this.addObjects(),
        this.addEventListeners(),
        this.addPostprocessing()
    }
    setup()
    {
        this.camera = new yn,
        this.camera.position.z = 1,
        this.scene = new Ag;
        const t = 4.5;
        this.scene.background = new Gt(t / 255, t / 255, t * 1.296 / 255),
        this.renderer = new wg({
            antialias: !0
        }),
        this.renderer.setSize(this.width, this.height),
        this.renderer.setAnimationLoop(this.animate.bind(this)),
        this.container.appendChild(this.renderer.domElement)
    }
    addPostprocessing()
    {
        this.composer = new Zb(this.renderer),
        this.composer.addPass(new Jb(this.scene, this.camera)),
        this.composer.setSize(this.width, this.height),
        this.grainEffect = new Du(tw),
        this.blurEffect = new Du(ew),
        this.blurEffect.uniforms.radius.value = 10,
        this.blurEffect.uniforms.resolution.value = new St(window.innerWidth, window.innerHeight),
        this.bloomPass = new No(new St(window.innerWidth, window.innerHeight), 1.5, .4, .85),
        this.bloomPass.threshold = 0,
        this.bloomPass.strength = .7,
        this.bloomPass.radius = .1,
        this.composer.addPass(this.bloomPass),
        this.composer.addPass(this.grainEffect)
    }
    addGui()
    {
        this.gui = new Nd,
        this.gui.add(this.shaderMaterial.uniforms.uMix1.value, "x", 0, .5, 1e-4),
        this.gui.add(this.shaderMaterial.uniforms.uMix1.value, "y", 0, .5, 1e-4),
        this.gui.add(this.shaderMaterial.uniforms.uMix2.value, "x", 0, .5, 1e-4),
        this.gui.add(this.shaderMaterial.uniforms.uMix2.value, "y", 0, .5, 1e-4),
        this.gui.add(this.shaderMaterial.uniforms.uMix3.value, "x", 0, .5, 1e-4),
        this.gui.add(this.shaderMaterial.uniforms.uMix3.value, "y", 0, .5, 1e-4),
        this.gui.addColor(this.shaderMaterial.uniforms.uColor1, "value"),
        this.gui.addColor(this.shaderMaterial.uniforms.uColor2, "value"),
        this.gui.addColor(this.shaderMaterial.uniforms.uColor3, "value"),
        this.gui.addColor(this.shaderMaterial.uniforms.uColor4, "value"),
        this.gui.add(this.bloomPass, "threshold").min(0).max(1).step(.001),
        this.gui.add(this.bloomPass, "strength").min(0).max(10).step(.001),
        this.gui.add(this.bloomPass, "radius").min(0).max(10).step(.001)
    }
    addEventListeners()
    {
        window.addEventListener("mousemove", this.handleMouseMove.bind(this)),
        window.addEventListener("resize", this.handleOnResize.bind(this))
    }
    handleMouseMove(t)
    {
        this.mouse.x = t.clientX / window.innerWidth * 2 - 1,
        this.mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;
        const e = new St(this.mouse.x, this.mouse.y);
        this.shaderMaterial.uniforms.uMouse.value = e
    }
    handleOnResize()
    {
        this.shaderMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight),
        this.width = this.container.offsetWidth,
        this.height = this.container.offsetHeight,
        this.camera.aspect = this.width / this.height,
        this.renderer.setSize(this.width, this.height),
        this.composer.setSize(this.width, this.height),
        this.camera.updateProjectionMatrix(),
        this.blurEffect.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        const t = 2 * Math.tan(fc.degToRad(this.camera.fov / 2)) * this.camera.position.z,
            e = t * this.camera.aspect;
        this.plane.scale.x = e,
        this.plane.scale.y = t
    }
    addObjects()
    {
        this.planeGeometry = new qa(1, 1, 1, 1),
        new Gt(27, 27, 35),
        this.shaderMaterial = new On({
            transparent: !0,
            uniforms: {
                uTime: {
                    value: 0
                },
                uMouse: {
                    value: new St(.5, .5)
                },
                uResolution: {
                    value: new St(window.innerWidth, window.innerHeight)
                },
                uMix1: {
                    value: new St(0, .076)
                },
                uMix2: {
                    value: new St(0, .0944)
                },
                uMix3: {
                    value: new St(0, .0575)
                },
                uColor1: {
                    value: new Gt(143 / 255, 0 / 255, 0 / 255)
                },
                uColor2: {
                    value: new Gt(189 / 255, 3 / 255, 5 / 255)
                },
                uColor3: {
                    value: new Gt(125 / 255, 161 / 255, 48 / 255)
                },
                uColor4: {
                    value: new Gt(3 / 255, 3 / 255, 5 / 255)
                }
            },
            vertexShader: JE,
            fragmentShader: QE
        }),
        this.shaderMaterial.outputColorSpace,
        this.plane = new Un(this.planeGeometry, this.shaderMaterial),
        this.plane.position.set(0, 0, 0);
        const t = 2 * Math.tan(fc.degToRad(this.camera.fov / 2)) * this.camera.position.z,
            e = t * this.camera.aspect;
        this.plane.scale.x = e,
        this.plane.scale.y = t,
        this.scene.add(this.plane)
    }
    animate(t)
    {
        this.time = t,
        this.shaderMaterial.uniforms.uTime.value = this.time,
        this.composer.render()
    }
}
function os(r) {
    if (r === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return r
}
function kg(r, t) {
    r.prototype = Object.create(t.prototype),
    r.prototype.constructor = r,
    r.__proto__ = t
} /*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/







var si = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
            lineHeight: ""
        }
    },
    Io = {
        duration: .5,
        overwrite: !1,
        delay: 0
    },
    Id,
    Sn,
    Ue,
    pi = 1e8,
    Re = 1 / pi,
    Nu = Math.PI * 2,
    iw = Nu / 4,
    sw = 0,
    Hg = Math.sqrt,
    rw = Math.cos,
    ow = Math.sin,
    ln = function(t) {
        return typeof t == "string"
    },
    Ve = function(t) {
        return typeof t == "function"
    },
    vs = function(t) {
        return typeof t == "number"
    },
    Fd = function(t) {
        return typeof t > "u"
    },
    Yi = function(t) {
        return typeof t == "object"
    },
    Hn = function(t) {
        return t !== !1
    },
    Ud = function() {
        return typeof window < "u"
    },
    Rl = function(t) {
        return Ve(t) || ln(t)
    },
    Vg = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {},
    Tn = Array.isArray,
    Iu = /(?:-?\.?\d|\.)+/gi,
    Gg = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    ao = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    Eh = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    Wg = /[+-]=-?[.\d]+/,
    Xg = /[^,'"\[\]\s]+/gi,
    aw = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    Be,
    Ii,
    Fu,
    Od,
    ri = {},
    _c = {},
    Yg,
    $g = function(t) {
        return (_c = Er(t, ri)) && Xn
    },
    zd = function(t, e) {
        return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
    },
    Ua = function(t, e) {
        return !e && console.warn(t)
    },
    qg = function(t, e) {
        return t && (ri[t] = e) && _c && (_c[t] = e) || ri
    },
    Oa = function() {
        return 0
    },
    lw = {
        suppressEvents: !0,
        isStart: !0,
        kill: !1
    },
    Jl = {
        suppressEvents: !0,
        kill: !1
    },
    cw = {
        suppressEvents: !0
    },
    Bd = {},
    Ys = [],
    Uu = {},
    Kg,
    Qn = {},
    bh = {},
    Zp = 30,
    Ql = [],
    kd = "",
    Hd = function(t) {
        var e = t[0],
            n,
            i;
        if (Yi(e) || Ve(e) || (t = [t]), !(n = (e._gsap || {}).harness)) {
            for (i = Ql.length; i-- && !Ql[i].targetTest(e);)
                ;
            n = Ql[i]
        }
        for (i = t.length; i--;)
            t[i] && (t[i]._gsap || (t[i]._gsap = new v_(t[i], n))) || t.splice(i, 1);
        return t
    },
    gr = function(t) {
        return t._gsap || Hd(mi(t))[0]._gsap
    },
    jg = function(t, e, n) {
        return (n = t[e]) && Ve(n) ? t[e]() : Fd(n) && t.getAttribute && t.getAttribute(e) || n
    },
    Vn = function(t, e) {
        return (t = t.split(",")).forEach(e) || t
    },
    Ge = function(t) {
        return Math.round(t * 1e5) / 1e5 || 0
    },
    rn = function(t) {
        return Math.round(t * 1e7) / 1e7 || 0
    },
    _o = function(t, e) {
        var n = e.charAt(0),
            i = parseFloat(e.substr(2));
        return t = parseFloat(t), n === "+" ? t + i : n === "-" ? t - i : n === "*" ? t * i : t / i
    },
    hw = function(t, e) {
        for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;)
            ;
        return i < n
    },
    xc = function() {
        var t = Ys.length,
            e = Ys.slice(0),
            n,
            i;
        for (Uu = {}, Ys.length = 0, n = 0; n < t; n++)
            i = e[n],
            i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
    },
    Zg = function(t, e, n, i) {
        Ys.length && !Sn && xc(),
        t.render(e, n, Sn && e < 0 && (t._initted || t._startAt)),
        Ys.length && !Sn && xc()
    },
    Jg = function(t) {
        var e = parseFloat(t);
        return (e || e === 0) && (t + "").match(Xg).length < 2 ? e : ln(t) ? t.trim() : t
    },
    Qg = function(t) {
        return t
    },
    _i = function(t, e) {
        for (var n in e)
            n in t || (t[n] = e[n]);
        return t
    },
    uw = function(t) {
        return function(e, n) {
            for (var i in n)
                i in e || i === "duration" && t || i === "ease" || (e[i] = n[i])
        }
    },
    Er = function(t, e) {
        for (var n in e)
            t[n] = e[n];
        return t
    },
    Jp = function r(t, e) {
        for (var n in e)
            n !== "__proto__" && n !== "constructor" && n !== "prototype" && (t[n] = Yi(e[n]) ? r(t[n] || (t[n] = {}), e[n]) : e[n]);
        return t
    },
    vc = function(t, e) {
        var n = {},
            i;
        for (i in t)
            i in e || (n[i] = t[i]);
        return n
    },
    _a = function(t) {
        var e = t.parent || Be,
            n = t.keyframes ? uw(Tn(t.keyframes)) : _i;
        if (Hn(t.inherit))
            for (; e;)
                n(t, e.vars.defaults),
                e = e.parent || e._dp;
        return t
    },
    dw = function(t, e) {
        for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];)
            ;
        return n < 0
    },
    t_ = function(t, e, n, i, s) {
        var o = t[i],
            a;
        if (s)
            for (a = e[s]; o && o[s] > a;)
                o = o._prev;
        return o ? (e._next = o._next, o._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = o, e.parent = e._dp = t, e
    },
    Nc = function(t, e, n, i) {
        n === void 0 && (n = "_first"),
        i === void 0 && (i = "_last");
        var s = e._prev,
            o = e._next;
        s ? s._next = o : t[n] === e && (t[n] = o),
        o ? o._prev = s : t[i] === e && (t[i] = s),
        e._next = e._prev = e.parent = null
    },
    Ks = function(t, e) {
        t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t),
        t._act = 0
    },
    _r = function(t, e) {
        if (t && (!e || e._end > t._dur || e._start < 0))
            for (var n = t; n;)
                n._dirty = 1,
                n = n.parent;
        return t
    },
    fw = function(t) {
        for (var e = t.parent; e && e.parent;)
            e._dirty = 1,
            e.totalDuration(),
            e = e.parent;
        return t
    },
    Ou = function(t, e, n, i) {
        return t._startAt && (Sn ? t._startAt.revert(Jl) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, i))
    },
    pw = function r(t) {
        return !t || t._ts && r(t.parent)
    },
    Qp = function(t) {
        return t._repeat ? Fo(t._tTime, t = t.duration() + t._rDelay) * t : 0
    },
    Fo = function(t, e) {
        var n = Math.floor(t /= e);
        return t && n === t ? n - 1 : n
    },
    yc = function(t, e) {
        return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
    },
    Ic = function(t) {
        return t._end = rn(t._start + (t._tDur / Math.abs(t._ts || t._rts || Re) || 0))
    },
    Fc = function(t, e) {
        var n = t._dp;
        return n && n.smoothChildTiming && t._ts && (t._start = rn(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Ic(t), n._dirty || _r(n, t)), t
    },
    e_ = function(t, e) {
        var n;
        if ((e._time || !e._dur && e._initted || e._start < t._time && (e._dur || !e.add)) && (n = yc(t.rawTime(), e), (!e._dur || Za(0, e.totalDuration(), n) - e._tTime > Re) && e.render(n, !0)), _r(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
            if (t._dur < t.duration())
                for (n = t; n._dp;)
                    n.rawTime() >= 0 && n.totalTime(n._tTime),
                    n = n._dp;
            t._zTime = -Re
        }
    },
    zi = function(t, e, n, i) {
        return e.parent && Ks(e), e._start = rn((vs(n) ? n : n || t !== Be ? ci(t, n, e) : t._time) + e._delay), e._end = rn(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), t_(t, e, "_first", "_last", t._sort ? "_start" : 0), zu(e) || (t._recent = e), i || e_(t, e), t._ts < 0 && Fc(t, t._tTime), t
    },
    n_ = function(t, e) {
        return (ri.ScrollTrigger || zd("scrollTrigger", e)) && ri.ScrollTrigger.create(e, t)
    },
    i_ = function(t, e, n, i, s) {
        if (Gd(t, e, s), !t._initted)
            return 1;
        if (!n && t._pt && !Sn && (t._dur && t.vars.lazy !== !1 || !t._dur && t.vars.lazy) && Kg !== ei.frame)
            return Ys.push(t), t._lazy = [s, i], 1
    },
    mw = function r(t) {
        var e = t.parent;
        return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || r(e))
    },
    zu = function(t) {
        var e = t.data;
        return e === "isFromStart" || e === "isStart"
    },
    gw = function(t, e, n, i) {
        var s = t.ratio,
            o = e < 0 || !e && (!t._start && mw(t) && !(!t._initted && zu(t)) || (t._ts < 0 || t._dp._ts < 0) && !zu(t)) ? 0 : 1,
            a = t._rDelay,
            l = 0,
            c,
            h,
            u;
        if (a && t._repeat && (l = Za(0, t._tDur, e), h = Fo(l, a), t._yoyo && h & 1 && (o = 1 - o), h !== Fo(t._tTime, a) && (s = 1 - o, t.vars.repeatRefresh && t._initted && t.invalidate())), o !== s || Sn || i || t._zTime === Re || !e && t._zTime) {
            if (!t._initted && i_(t, e, i, n, l))
                return;
            for (u = t._zTime, t._zTime = e || (n ? Re : 0), n || (n = e && !u), t.ratio = o, t._from && (o = 1 - o), t._time = 0, t._tTime = l, c = t._pt; c;)
                c.r(o, c.d),
                c = c._next;
            e < 0 && Ou(t, e, n, !0),
            t._onUpdate && !n && ii(t, "onUpdate"),
            l && t._repeat && !n && t.parent && ii(t, "onRepeat"),
            (e >= t._tDur || e < 0) && t.ratio === o && (o && Ks(t, 1), !n && !Sn && (ii(t, o ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
        } else
            t._zTime || (t._zTime = e)
    },
    _w = function(t, e, n) {
        var i;
        if (n > e)
            for (i = t._first; i && i._start <= n;) {
                if (i.data === "isPause" && i._start > e)
                    return i;
                i = i._next
            }
        else
            for (i = t._last; i && i._start >= n;) {
                if (i.data === "isPause" && i._start < e)
                    return i;
                i = i._prev
            }
    },
    Uo = function(t, e, n, i) {
        var s = t._repeat,
            o = rn(e) || 0,
            a = t._tTime / t._tDur;
        return a && !i && (t._time *= o / t._dur), t._dur = o, t._tDur = s ? s < 0 ? 1e10 : rn(o * (s + 1) + t._rDelay * s) : o, a > 0 && !i && Fc(t, t._tTime = t._tDur * a), t.parent && Ic(t), n || _r(t.parent, t), t
    },
    tm = function(t) {
        return t instanceof Dn ? _r(t) : Uo(t, t._dur)
    },
    xw = {
        _start: 0,
        endTime: Oa,
        totalDuration: Oa
    },
    ci = function r(t, e, n) {
        var i = t.labels,
            s = t._recent || xw,
            o = t.duration() >= pi ? s.endTime(!1) : t._dur,
            a,
            l,
            c;
        return ln(e) && (isNaN(e) || e in i) ? (l = e.charAt(0), c = e.substr(-1) === "%", a = e.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (e = e.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(e.substr(1)) || 0) * (c ? (a < 0 ? s : n).totalDuration() / 100 : 1)) : a < 0 ? (e in i || (i[e] = o), i[e]) : (l = parseFloat(e.charAt(a - 1) + e.substr(a + 1)), c && n && (l = l / 100 * (Tn(n) ? n[0] : n).totalDuration()), a > 1 ? r(t, e.substr(0, a - 1), n) + l : o + l)) : e == null ? o : +e
    },
    xa = function(t, e, n) {
        var i = vs(e[1]),
            s = (i ? 2 : 1) + (t < 2 ? 0 : 1),
            o = e[s],
            a,
            l;
        if (i && (o.duration = e[1]), o.parent = n, t) {
            for (a = o, l = n; l && !("immediateRender" in a);)
                a = l.vars.defaults || {},
                l = Hn(l.vars.inherit) && l.parent;
            o.immediateRender = Hn(a.immediateRender),
            t < 2 ? o.runBackwards = 1 : o.startAt = e[s - 1]
        }
        return new qe(e[0], o, e[s + 1])
    },
    Js = function(t, e) {
        return t || t === 0 ? e(t) : e
    },
    Za = function(t, e, n) {
        return n < t ? t : n > e ? e : n
    },
    Mn = function(t, e) {
        return !ln(t) || !(e = aw.exec(t)) ? "" : e[1]
    },
    vw = function(t, e, n) {
        return Js(n, function(i) {
            return Za(t, e, i)
        })
    },
    Bu = [].slice,
    s_ = function(t, e) {
        return t && Yi(t) && "length" in t && (!e && !t.length || t.length - 1 in t && Yi(t[0])) && !t.nodeType && t !== Ii
    },
    yw = function(t, e, n) {
        return n === void 0 && (n = []), t.forEach(function(i) {
            var s;
            return ln(i) && !e || s_(i, 1) ? (s = n).push.apply(s, mi(i)) : n.push(i)
        }) || n
    },
    mi = function(t, e, n) {
        return Ue && !e && Ue.selector ? Ue.selector(t) : ln(t) && !n && (Fu || !Oo()) ? Bu.call((e || Od).querySelectorAll(t), 0) : Tn(t) ? yw(t, n) : s_(t) ? Bu.call(t, 0) : t ? [t] : []
    },
    ku = function(t) {
        return t = mi(t)[0] || Ua("Invalid scope") || {}, function(e) {
            var n = t.current || t.nativeElement || t;
            return mi(e, n.querySelectorAll ? n : n === t ? Ua("Invalid scope") || Od.createElement("div") : t)
        }
    },
    r_ = function(t) {
        return t.sort(function() {
            return .5 - Math.random()
        })
    },
    o_ = function(t) {
        if (Ve(t))
            return t;
        var e = Yi(t) ? t : {
                each: t
            },
            n = xr(e.ease),
            i = e.from || 0,
            s = parseFloat(e.base) || 0,
            o = {},
            a = i > 0 && i < 1,
            l = isNaN(i) || a,
            c = e.axis,
            h = i,
            u = i;
        return ln(i) ? h = u = {
            center: .5,
            edges: .5,
            end: 1
        }[i] || 0 : !a && l && (h = i[0], u = i[1]), function(d, f, m) {
            var _ = (m || e).length,
                g = o[_],
                p,
                x,
                v,
                y,
                C,
                A,
                T,
                R,
                E;
            if (!g) {
                if (E = e.grid === "auto" ? 0 : (e.grid || [1, pi])[1], !E) {
                    for (T = -pi; T < (T = m[E++].getBoundingClientRect().left) && E < _;)
                        ;
                    E < _ && E--
                }
                for (g = o[_] = [], p = l ? Math.min(E, _) * h - .5 : i % E, x = E === pi ? 0 : l ? _ * u / E - .5 : i / E | 0, T = 0, R = pi, A = 0; A < _; A++)
                    v = A % E - p,
                    y = x - (A / E | 0),
                    g[A] = C = c ? Math.abs(c === "y" ? y : v) : Hg(v * v + y * y),
                    C > T && (T = C),
                    C < R && (R = C);
                i === "random" && r_(g),
                g.max = T - R,
                g.min = R,
                g.v = _ = (parseFloat(e.amount) || parseFloat(e.each) * (E > _ ? _ - 1 : c ? c === "y" ? _ / E : E : Math.max(E, _ / E)) || 0) * (i === "edges" ? -1 : 1),
                g.b = _ < 0 ? s - _ : s,
                g.u = Mn(e.amount || e.each) || 0,
                n = n && _ < 0 ? g_(n) : n
            }
            return _ = (g[d] - g.min) / g.max || 0, rn(g.b + (n ? n(_) : _) * g.v) + g.u
        }
    },
    Hu = function(t) {
        var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
        return function(n) {
            var i = rn(Math.round(parseFloat(n) / t) * t * e);
            return (i - i % 1) / e + (vs(n) ? 0 : Mn(n))
        }
    },
    a_ = function(t, e) {
        var n = Tn(t),
            i,
            s;
        return !n && Yi(t) && (i = n = t.radius || pi, t.values ? (t = mi(t.values), (s = !vs(t[0])) && (i *= i)) : t = Hu(t.increment)), Js(e, n ? Ve(t) ? function(o) {
            return s = t(o), Math.abs(s - o) <= i ? s : o
        } : function(o) {
            for (var a = parseFloat(s ? o.x : o), l = parseFloat(s ? o.y : 0), c = pi, h = 0, u = t.length, d, f; u--;)
                s ? (d = t[u].x - a, f = t[u].y - l, d = d * d + f * f) : d = Math.abs(t[u] - a),
                d < c && (c = d, h = u);
            return h = !i || c <= i ? t[h] : o, s || h === o || vs(o) ? h : h + Mn(o)
        } : Hu(t))
    },
    l_ = function(t, e, n, i) {
        return Js(Tn(t) ? !e : n === !0 ? !!(n = 0) : !i, function() {
            return Tn(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + n * .99)) / n) * n * i) / i
        })
    },
    Mw = function() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
        return function(i) {
            return e.reduce(function(s, o) {
                return o(s)
            }, i)
        }
    },
    Sw = function(t, e) {
        return function(n) {
            return t(parseFloat(n)) + (e || Mn(n))
        }
    },
    Tw = function(t, e, n) {
        return h_(t, e, 0, 1, n)
    },
    c_ = function(t, e, n) {
        return Js(n, function(i) {
            return t[~~e(i)]
        })
    },
    Ew = function r(t, e, n) {
        var i = e - t;
        return Tn(t) ? c_(t, r(0, t.length), e) : Js(n, function(s) {
            return (i + (s - t) % i) % i + t
        })
    },
    bw = function r(t, e, n) {
        var i = e - t,
            s = i * 2;
        return Tn(t) ? c_(t, r(0, t.length - 1), e) : Js(n, function(o) {
            return o = (s + (o - t) % s) % s || 0, t + (o > i ? s - o : o)
        })
    },
    za = function(t) {
        for (var e = 0, n = "", i, s, o, a; ~(i = t.indexOf("random(", e));)
            o = t.indexOf(")", i),
            a = t.charAt(i + 7) === "[",
            s = t.substr(i + 7, o - i - 7).match(a ? Xg : Iu),
            n += t.substr(e, i - e) + l_(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5),
            e = o + 1;
        return n + t.substr(e, t.length - e)
    },
    h_ = function(t, e, n, i, s) {
        var o = e - t,
            a = i - n;
        return Js(s, function(l) {
            return n + ((l - t) / o * a || 0)
        })
    },
    ww = function r(t, e, n, i) {
        var s = isNaN(t + e) ? 0 : function(f) {
            return (1 - f) * t + f * e
        };
        if (!s) {
            var o = ln(t),
                a = {},
                l,
                c,
                h,
                u,
                d;
            if (n === !0 && (i = 1) && (n = null), o)
                t = {
                    p: t
                },
                e = {
                    p: e
                };
            else if (Tn(t) && !Tn(e)) {
                for (h = [], u = t.length, d = u - 2, c = 1; c < u; c++)
                    h.push(r(t[c - 1], t[c]));
                u--,
                s = function(m) {
                    m *= u;
                    var _ = Math.min(d, ~~m);
                    return h[_](m - _)
                },
                n = e
            } else
                i || (t = Er(Tn(t) ? [] : {}, t));
            if (!h) {
                for (l in e)
                    Vd.call(a, t, l, "get", e[l]);
                s = function(m) {
                    return Yd(m, a) || (o ? t.p : t)
                }
            }
        }
        return Js(n, s)
    },
    em = function(t, e, n) {
        var i = t.labels,
            s = pi,
            o,
            a,
            l;
        for (o in i)
            a = i[o] - e,
            a < 0 == !!n && a && s > (a = Math.abs(a)) && (l = o, s = a);
        return l
    },
    ii = function(t, e, n) {
        var i = t.vars,
            s = i[e],
            o = Ue,
            a = t._ctx,
            l,
            c,
            h;
        if (s)
            return l = i[e + "Params"], c = i.callbackScope || t, n && Ys.length && xc(), a && (Ue = a), h = l ? s.apply(c, l) : s.call(c), Ue = o, h
    },
    aa = function(t) {
        return Ks(t), t.scrollTrigger && t.scrollTrigger.kill(!!Sn), t.progress() < 1 && ii(t, "onInterrupt"), t
    },
    lo,
    u_ = [],
    d_ = function(t) {
        if (t)
            if (t = !t.name && t.default || t, Ud() || t.headless) {
                var e = t.name,
                    n = Ve(t),
                    i = e && !n && t.init ? function() {
                        this._props = []
                    } : t,
                    s = {
                        init: Oa,
                        render: Yd,
                        add: Vd,
                        kill: Vw,
                        modifier: Hw,
                        rawVars: 0
                    },
                    o = {
                        targetTest: 0,
                        get: 0,
                        getSetter: Xd,
                        aliases: {},
                        register: 0
                    };
                if (Oo(), t !== i) {
                    if (Qn[e])
                        return;
                    _i(i, _i(vc(t, s), o)),
                    Er(i.prototype, Er(s, vc(t, o))),
                    Qn[i.prop = e] = i,
                    t.targetTest && (Ql.push(i), Bd[e] = 1),
                    e = (e === "css" ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                }
                qg(e, i),
                t.register && t.register(Xn, i, Gn)
            } else
                u_.push(t)
    },
    we = 255,
    la = {
        aqua: [0, we, we],
        lime: [0, we, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, we],
        navy: [0, 0, 128],
        white: [we, we, we],
        olive: [128, 128, 0],
        yellow: [we, we, 0],
        orange: [we, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [we, 0, 0],
        pink: [we, 192, 203],
        cyan: [0, we, we],
        transparent: [we, we, we, 0]
    },
    wh = function(t, e, n) {
        return t += t < 0 ? 1 : t > 1 ? -1 : 0, (t * 6 < 1 ? e + (n - e) * t * 6 : t < .5 ? n : t * 3 < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * we + .5 | 0
    },
    f_ = function(t, e, n) {
        var i = t ? vs(t) ? [t >> 16, t >> 8 & we, t & we] : 0 : la.black,
            s,
            o,
            a,
            l,
            c,
            h,
            u,
            d,
            f,
            m;
        if (!i) {
            if (t.substr(-1) === "," && (t = t.substr(0, t.length - 1)), la[t])
                i = la[t];
            else if (t.charAt(0) === "#") {
                if (t.length < 6 && (s = t.charAt(1), o = t.charAt(2), a = t.charAt(3), t = "#" + s + s + o + o + a + a + (t.length === 5 ? t.charAt(4) + t.charAt(4) : "")), t.length === 9)
                    return i = parseInt(t.substr(1, 6), 16), [i >> 16, i >> 8 & we, i & we, parseInt(t.substr(7), 16) / 255];
                t = parseInt(t.substr(1), 16),
                i = [t >> 16, t >> 8 & we, t & we]
            } else if (t.substr(0, 3) === "hsl") {
                if (i = m = t.match(Iu), !e)
                    l = +i[0] % 360 / 360,
                    c = +i[1] / 100,
                    h = +i[2] / 100,
                    o = h <= .5 ? h * (c + 1) : h + c - h * c,
                    s = h * 2 - o,
                    i.length > 3 && (i[3] *= 1),
                    i[0] = wh(l + 1 / 3, s, o),
                    i[1] = wh(l, s, o),
                    i[2] = wh(l - 1 / 3, s, o);
                else if (~t.indexOf("="))
                    return i = t.match(Gg), n && i.length < 4 && (i[3] = 1), i
            } else
                i = t.match(Iu) || la.transparent;
            i = i.map(Number)
        }
        return e && !m && (s = i[0] / we, o = i[1] / we, a = i[2] / we, u = Math.max(s, o, a), d = Math.min(s, o, a), h = (u + d) / 2, u === d ? l = c = 0 : (f = u - d, c = h > .5 ? f / (2 - u - d) : f / (u + d), l = u === s ? (o - a) / f + (o < a ? 6 : 0) : u === o ? (a - s) / f + 2 : (s - o) / f + 4, l *= 60), i[0] = ~~(l + .5), i[1] = ~~(c * 100 + .5), i[2] = ~~(h * 100 + .5)), n && i.length < 4 && (i[3] = 1), i
    },
    p_ = function(t) {
        var e = [],
            n = [],
            i = -1;
        return t.split($s).forEach(function(s) {
            var o = s.match(ao) || [];
            e.push.apply(e, o),
            n.push(i += o.length + 1)
        }), e.c = n, e
    },
    nm = function(t, e, n) {
        var i = "",
            s = (t + i).match($s),
            o = e ? "hsla(" : "rgba(",
            a = 0,
            l,
            c,
            h,
            u;
        if (!s)
            return t;
        if (s = s.map(function(d) {
            return (d = f_(d, e, 1)) && o + (e ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")"
        }), n && (h = p_(t), l = n.c, l.join(i) !== h.c.join(i)))
            for (c = t.replace($s, "1").split(ao), u = c.length - 1; a < u; a++)
                i += c[a] + (~l.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (h.length ? h : s.length ? s : n).shift());
        if (!c)
            for (c = t.split($s), u = c.length - 1; a < u; a++)
                i += c[a] + s[a];
        return i + c[u]
    },
    $s = function() {
        var r = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
            t;
        for (t in la)
            r += "|" + t + "\\b";
        return new RegExp(r + ")", "gi")
    }(),
    Aw = /hsl[a]?\(/,
    m_ = function(t) {
        var e = t.join(" "),
            n;
        if ($s.lastIndex = 0, $s.test(e))
            return n = Aw.test(e), t[1] = nm(t[1], n), t[0] = nm(t[0], n, p_(t[1])), !0
    },
    Ba,
    ei = function() {
        var r = Date.now,
            t = 500,
            e = 33,
            n = r(),
            i = n,
            s = 1e3 / 240,
            o = s,
            a = [],
            l,
            c,
            h,
            u,
            d,
            f,
            m = function _(g) {
                var p = r() - i,
                    x = g === !0,
                    v,
                    y,
                    C,
                    A;
                if ((p > t || p < 0) && (n += p - e), i += p, C = i - n, v = C - o, (v > 0 || x) && (A = ++u.frame, d = C - u.time * 1e3, u.time = C = C / 1e3, o += v + (v >= s ? 4 : s - v), y = 1), x || (l = c(_)), y)
                    for (f = 0; f < a.length; f++)
                        a[f](C, d, A, g)
            };
        return u = {
            time: 0,
            frame: 0,
            tick: function() {
                m(!0)
            },
            deltaRatio: function(g) {
                return d / (1e3 / (g || 60))
            },
            wake: function() {
                Yg && (!Fu && Ud() && (Ii = Fu = window, Od = Ii.document || {}, ri.gsap = Xn, (Ii.gsapVersions || (Ii.gsapVersions = [])).push(Xn.version), $g(_c || Ii.GreenSockGlobals || !Ii.gsap && Ii || {}), u_.forEach(d_)), h = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && u.sleep(), c = h || function(g) {
                    return setTimeout(g, o - u.time * 1e3 + 1 | 0)
                }, Ba = 1, m(2))
            },
            sleep: function() {
                (h ? cancelAnimationFrame : clearTimeout)(l),
                Ba = 0,
                c = Oa
            },
            lagSmoothing: function(g, p) {
                t = g || 1 / 0,
                e = Math.min(p || 33, t)
            },
            fps: function(g) {
                s = 1e3 / (g || 240),
                o = u.time * 1e3 + s
            },
            add: function(g, p, x) {
                var v = p ? function(y, C, A, T) {
                    g(y, C, A, T),
                    u.remove(v)
                } : g;
                return u.remove(g), a[x ? "unshift" : "push"](v), Oo(), v
            },
            remove: function(g, p) {
                ~(p = a.indexOf(g)) && a.splice(p, 1) && f >= p && f--
            },
            _listeners: a
        }, u
    }(),
    Oo = function() {
        return !Ba && ei.wake()
    },
    ue = {},
    Cw = /^[\d.\-M][\d.\-,\s]/,
    Rw = /["']/g,
    Pw = function(t) {
        for (var e = {}, n = t.substr(1, t.length - 3).split(":"), i = n[0], s = 1, o = n.length, a, l, c; s < o; s++)
            l = n[s],
            a = s !== o - 1 ? l.lastIndexOf(",") : l.length,
            c = l.substr(0, a),
            e[i] = isNaN(c) ? c.replace(Rw, "").trim() : +c,
            i = l.substr(a + 1).trim();
        return e
    },
    Lw = function(t) {
        var e = t.indexOf("(") + 1,
            n = t.indexOf(")"),
            i = t.indexOf("(", e);
        return t.substring(e, ~i && i < n ? t.indexOf(")", n + 1) : n)
    },
    Dw = function(t) {
        var e = (t + "").split("("),
            n = ue[e[0]];
        return n && e.length > 1 && n.config ? n.config.apply(null, ~t.indexOf("{") ? [Pw(e[1])] : Lw(t).split(",").map(Jg)) : ue._CE && Cw.test(t) ? ue._CE("", t) : n
    },
    g_ = function(t) {
        return function(e) {
            return 1 - t(1 - e)
        }
    },
    __ = function r(t, e) {
        for (var n = t._first, i; n;)
            n instanceof Dn ? r(n, e) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== e && (n.timeline ? r(n.timeline, e) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = e)),
            n = n._next
    },
    xr = function(t, e) {
        return t && (Ve(t) ? t : ue[t] || Dw(t)) || e
    },
    Pr = function(t, e, n, i) {
        n === void 0 && (n = function(l) {
            return 1 - e(1 - l)
        }),
        i === void 0 && (i = function(l) {
            return l < .5 ? e(l * 2) / 2 : 1 - e((1 - l) * 2) / 2
        });
        var s = {
                easeIn: e,
                easeOut: n,
                easeInOut: i
            },
            o;
        return Vn(t, function(a) {
            ue[a] = ri[a] = s,
            ue[o = a.toLowerCase()] = n;
            for (var l in s)
                ue[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = ue[a + "." + l] = s[l]
        }), s
    },
    x_ = function(t) {
        return function(e) {
            return e < .5 ? (1 - t(1 - e * 2)) / 2 : .5 + t((e - .5) * 2) / 2
        }
    },
    Ah = function r(t, e, n) {
        var i = e >= 1 ? e : 1,
            s = (n || (t ? .3 : .45)) / (e < 1 ? e : 1),
            o = s / Nu * (Math.asin(1 / i) || 0),
            a = function(h) {
                return h === 1 ? 1 : i * Math.pow(2, -10 * h) * ow((h - o) * s) + 1
            },
            l = t === "out" ? a : t === "in" ? function(c) {
                return 1 - a(1 - c)
            } : x_(a);
        return s = Nu / s, l.config = function(c, h) {
            return r(t, c, h)
        }, l
    },
    Ch = function r(t, e) {
        e === void 0 && (e = 1.70158);
        var n = function(o) {
                return o ? --o * o * ((e + 1) * o + e) + 1 : 0
            },
            i = t === "out" ? n : t === "in" ? function(s) {
                return 1 - n(1 - s)
            } : x_(n);
        return i.config = function(s) {
            return r(t, s)
        }, i
    };
Vn("Linear,Quad,Cubic,Quart,Quint,Strong", function(r, t) {
    var e = t < 5 ? t + 1 : t;
    Pr(r + ",Power" + (e - 1), t ? function(n) {
        return Math.pow(n, e)
    } : function(n) {
        return n
    }, function(n) {
        return 1 - Math.pow(1 - n, e)
    }, function(n) {
        return n < .5 ? Math.pow(n * 2, e) / 2 : 1 - Math.pow((1 - n) * 2, e) / 2
    })
});
ue.Linear.easeNone = ue.none = ue.Linear.easeIn;
Pr("Elastic", Ah("in"), Ah("out"), Ah());
(function(r, t) {
    var e = 1 / t,
        n = 2 * e,
        i = 2.5 * e,
        s = function(a) {
            return a < e ? r * a * a : a < n ? r * Math.pow(a - 1.5 / t, 2) + .75 : a < i ? r * (a -= 2.25 / t) * a + .9375 : r * Math.pow(a - 2.625 / t, 2) + .984375
        };
    Pr("Bounce", function(o) {
        return 1 - s(1 - o)
    }, s)
})(7.5625, 2.75);
Pr("Expo", function(r) {
    return r ? Math.pow(2, 10 * (r - 1)) : 0
});
Pr("Circ", function(r) {
    return -(Hg(1 - r * r) - 1)
});
Pr("Sine", function(r) {
    return r === 1 ? 1 : -rw(r * iw) + 1
});
Pr("Back", Ch("in"), Ch("out"), Ch());
ue.SteppedEase = ue.steps = ri.SteppedEase = {
    config: function(t, e) {
        t === void 0 && (t = 1);
        var n = 1 / t,
            i = t + (e ? 0 : 1),
            s = e ? 1 : 0,
            o = 1 - Re;
        return function(a) {
            return ((i * Za(0, o, a) | 0) + s) * n
        }
    }
};
Io.ease = ue["quad.out"];
Vn("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(r) {
    return kd += r + "," + r + "Params,"
});
var v_ = function(t, e) {
        this.id = sw++,
        t._gsap = this,
        this.target = t,
        this.harness = e,
        this.get = e ? e.get : jg,
        this.set = e ? e.getSetter : Xd
    },
    ka = function() {
        function r(e) {
            this.vars = e,
            this._delay = +e.delay || 0,
            (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase),
            this._ts = 1,
            Uo(this, +e.duration, 1, 1),
            this.data = e.data,
            Ue && (this._ctx = Ue, Ue.data.push(this)),
            Ba || ei.wake()
        }
        var t = r.prototype;
        return t.delay = function(n) {
            return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay
        }, t.duration = function(n) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
        }, t.totalDuration = function(n) {
            return arguments.length ? (this._dirty = 0, Uo(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }, t.totalTime = function(n, i) {
            if (Oo(), !arguments.length)
                return this._tTime;
            var s = this._dp;
            if (s && s.smoothChildTiming && this._ts) {
                for (Fc(this, n), !s._dp || s.parent || e_(s, this); s && s.parent;)
                    s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0),
                    s = s.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && zi(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === Re || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), Zg(this, n, i)), this
        }, t.time = function(n, i) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + Qp(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time
        }, t.totalProgress = function(n, i) {
            return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
        }, t.progress = function(n, i) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + Qp(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
        }, t.iteration = function(n, i) {
            var s = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (n - 1) * s, i) : this._repeat ? Fo(this._tTime, s) + 1 : 1
        }, t.timeScale = function(n, i) {
            if (!arguments.length)
                return this._rts === -Re ? 0 : this._rts;
            if (this._rts === n)
                return this;
            var s = this.parent && this._ts ? yc(this.parent._time, this) : this._tTime;
            return this._rts = +n || 0, this._ts = this._ps || n === -Re ? 0 : this._rts, this.totalTime(Za(-Math.abs(this._delay), this._tDur, s), i !== !1), Ic(this), fw(this)
        }, t.paused = function(n) {
            return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Oo(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Re && (this._tTime -= Re)))), this) : this._ps
        }, t.startTime = function(n) {
            if (arguments.length) {
                this._start = n;
                var i = this.parent || this._dp;
                return i && (i._sort || !this.parent) && zi(i, this, n - this._delay), this
            }
            return this._start
        }, t.endTime = function(n) {
            return this._start + (Hn(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }, t.rawTime = function(n) {
            var i = this.parent || this._dp;
            return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? yc(i.rawTime(n), this) : this._tTime : this._tTime
        }, t.revert = function(n) {
            n === void 0 && (n = cw);
            var i = Sn;
            return Sn = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), Sn = i, this
        }, t.globalTime = function(n) {
            for (var i = this, s = arguments.length ? n : i.rawTime(); i;)
                s = i._start + s / (Math.abs(i._ts) || 1),
                i = i._dp;
            return !this.parent && this._sat ? this._sat.globalTime(n) : s
        }, t.repeat = function(n) {
            return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, tm(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
        }, t.repeatDelay = function(n) {
            if (arguments.length) {
                var i = this._time;
                return this._rDelay = n, tm(this), i ? this.time(i) : this
            }
            return this._rDelay
        }, t.yoyo = function(n) {
            return arguments.length ? (this._yoyo = n, this) : this._yoyo
        }, t.seek = function(n, i) {
            return this.totalTime(ci(this, n), Hn(i))
        }, t.restart = function(n, i) {
            return this.play().totalTime(n ? -this._delay : 0, Hn(i))
        }, t.play = function(n, i) {
            return n != null && this.seek(n, i), this.reversed(!1).paused(!1)
        }, t.reverse = function(n, i) {
            return n != null && this.seek(n || this.totalDuration(), i), this.reversed(!0).paused(!1)
        }, t.pause = function(n, i) {
            return n != null && this.seek(n, i), this.paused(!0)
        }, t.resume = function() {
            return this.paused(!1)
        }, t.reversed = function(n) {
            return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -Re : 0)), this) : this._rts < 0
        }, t.invalidate = function() {
            return this._initted = this._act = 0, this._zTime = -Re, this
        }, t.isActive = function() {
            var n = this.parent || this._dp,
                i = this._start,
                s;
            return !!(!n || this._ts && this._initted && n.isActive() && (s = n.rawTime(!0)) >= i && s < this.endTime(!0) - Re)
        }, t.eventCallback = function(n, i, s) {
            var o = this.vars;
            return arguments.length > 1 ? (i ? (o[n] = i, s && (o[n + "Params"] = s), n === "onUpdate" && (this._onUpdate = i)) : delete o[n], this) : o[n]
        }, t.then = function(n) {
            var i = this;
            return new Promise(function(s) {
                var o = Ve(n) ? n : Qg,
                    a = function() {
                        var c = i.then;
                        i.then = null,
                        Ve(o) && (o = o(i)) && (o.then || o === i) && (i.then = c),
                        s(o),
                        i.then = c
                    };
                i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? a() : i._prom = a
            })
        }, t.kill = function() {
            aa(this)
        }, r
    }();
_i(ka.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Re,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Dn = function(r) {
    kg(t, r);
    function t(n, i) {
        var s;
        return n === void 0 && (n = {}), s = r.call(this, n) || this, s.labels = {}, s.smoothChildTiming = !!n.smoothChildTiming, s.autoRemoveChildren = !!n.autoRemoveChildren, s._sort = Hn(n.sortChildren), Be && zi(n.parent || Be, os(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), n.scrollTrigger && n_(os(s), n.scrollTrigger), s
    }
    var e = t.prototype;
    return e.to = function(i, s, o) {
        return xa(0, arguments, this), this
    }, e.from = function(i, s, o) {
        return xa(1, arguments, this), this
    }, e.fromTo = function(i, s, o, a) {
        return xa(2, arguments, this), this
    }, e.set = function(i, s, o) {
        return s.duration = 0, s.parent = this, _a(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new qe(i, s, ci(this, o), 1), this
    }, e.call = function(i, s, o) {
        return zi(this, qe.delayedCall(0, i, s), o)
    }, e.staggerTo = function(i, s, o, a, l, c, h) {
        return o.duration = s, o.stagger = o.stagger || a, o.onComplete = c, o.onCompleteParams = h, o.parent = this, new qe(i, o, ci(this, l)), this
    }, e.staggerFrom = function(i, s, o, a, l, c, h) {
        return o.runBackwards = 1, _a(o).immediateRender = Hn(o.immediateRender), this.staggerTo(i, s, o, a, l, c, h)
    }, e.staggerFromTo = function(i, s, o, a, l, c, h, u) {
        return a.startAt = o, _a(a).immediateRender = Hn(a.immediateRender), this.staggerTo(i, s, a, l, c, h, u)
    }, e.render = function(i, s, o) {
        var a = this._time,
            l = this._dirty ? this.totalDuration() : this._tDur,
            c = this._dur,
            h = i <= 0 ? 0 : rn(i),
            u = this._zTime < 0 != i < 0 && (this._initted || !c),
            d,
            f,
            m,
            _,
            g,
            p,
            x,
            v,
            y,
            C,
            A,
            T;
        if (this !== Be && h > l && i >= 0 && (h = l), h !== this._tTime || o || u) {
            if (a !== this._time && c && (h += this._time - a, i += this._time - a), d = h, y = this._start, v = this._ts, p = !v, u && (c || (a = this._zTime), (i || !s) && (this._zTime = i)), this._repeat) {
                if (A = this._yoyo, g = c + this._rDelay, this._repeat < -1 && i < 0)
                    return this.totalTime(g * 100 + i, s, o);
                if (d = rn(h % g), h === l ? (_ = this._repeat, d = c) : (_ = ~~(h / g), _ && _ === h / g && (d = c, _--), d > c && (d = c)), C = Fo(this._tTime, g), !a && this._tTime && C !== _ && this._tTime - C * g - this._dur <= 0 && (C = _), A && _ & 1 && (d = c - d, T = 1), _ !== C && !this._lock) {
                    var R = A && C & 1,
                        E = R === (A && _ & 1);
                    if (_ < C && (R = !R), a = R ? 0 : h % c ? c : h, this._lock = 1, this.render(a || (T ? 0 : rn(_ * g)), s, !c)._lock = 0, this._tTime = h, !s && this.parent && ii(this, "onRepeat"), this.vars.repeatRefresh && !T && (this.invalidate()._lock = 1), a && a !== this._time || p !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (c = this._dur, l = this._tDur, E && (this._lock = 2, a = R ? c : -1e-4, this.render(a, !0), this.vars.repeatRefresh && !T && this.invalidate()), this._lock = 0, !this._ts && !p)
                        return this;
                    __(this, T)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (x = _w(this, rn(a), rn(d)), x && (h -= d - (d = x._start))), this._tTime = h, this._time = d, this._act = !v, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, a = 0), !a && d && !s && !_ && (ii(this, "onStart"), this._tTime !== h))
                return this;
            if (d >= a && i >= 0)
                for (f = this._first; f;) {
                    if (m = f._next, (f._act || d >= f._start) && f._ts && x !== f) {
                        if (f.parent !== this)
                            return this.render(i, s, o);
                        if (f.render(f._ts > 0 ? (d - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (d - f._start) * f._ts, s, o), d !== this._time || !this._ts && !p) {
                            x = 0,
                            m && (h += this._zTime = -Re);
                            break
                        }
                    }
                    f = m
                }
            else {
                f = this._last;
                for (var M = i < 0 ? i : d; f;) {
                    if (m = f._prev, (f._act || M <= f._end) && f._ts && x !== f) {
                        if (f.parent !== this)
                            return this.render(i, s, o);
                        if (f.render(f._ts > 0 ? (M - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (M - f._start) * f._ts, s, o || Sn && (f._initted || f._startAt)), d !== this._time || !this._ts && !p) {
                            x = 0,
                            m && (h += this._zTime = M ? -Re : Re);
                            break
                        }
                    }
                    f = m
                }
            }
            if (x && !s && (this.pause(), x.render(d >= a ? 0 : -Re)._zTime = d >= a ? 1 : -1, this._ts))
                return this._start = y, Ic(this), this.render(i, s, o);
            this._onUpdate && !s && ii(this, "onUpdate", !0),
            (h === l && this._tTime >= this.totalDuration() || !h && a) && (y === this._start || Math.abs(v) !== Math.abs(this._ts)) && (this._lock || ((i || !c) && (h === l && this._ts > 0 || !h && this._ts < 0) && Ks(this, 1), !s && !(i < 0 && !a) && (h || a || !l) && (ii(this, h === l && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }, e.add = function(i, s) {
        var o = this;
        if (vs(s) || (s = ci(this, s, i)), !(i instanceof ka)) {
            if (Tn(i))
                return i.forEach(function(a) {
                    return o.add(a, s)
                }), this;
            if (ln(i))
                return this.addLabel(i, s);
            if (Ve(i))
                i = qe.delayedCall(0, i);
            else
                return this
        }
        return this !== i ? zi(this, i, s) : this
    }, e.getChildren = function(i, s, o, a) {
        i === void 0 && (i = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -pi);
        for (var l = [], c = this._first; c;)
            c._start >= a && (c instanceof qe ? s && l.push(c) : (o && l.push(c), i && l.push.apply(l, c.getChildren(!0, s, o)))),
            c = c._next;
        return l
    }, e.getById = function(i) {
        for (var s = this.getChildren(1, 1, 1), o = s.length; o--;)
            if (s[o].vars.id === i)
                return s[o]
    }, e.remove = function(i) {
        return ln(i) ? this.removeLabel(i) : Ve(i) ? this.killTweensOf(i) : (Nc(this, i), i === this._recent && (this._recent = this._last), _r(this))
    }, e.totalTime = function(i, s) {
        return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = rn(ei.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), r.prototype.totalTime.call(this, i, s), this._forcing = 0, this) : this._tTime
    }, e.addLabel = function(i, s) {
        return this.labels[i] = ci(this, s), this
    }, e.removeLabel = function(i) {
        return delete this.labels[i], this
    }, e.addPause = function(i, s, o) {
        var a = qe.delayedCall(0, s || Oa, o);
        return a.data = "isPause", this._hasPause = 1, zi(this, a, ci(this, i))
    }, e.removePause = function(i) {
        var s = this._first;
        for (i = ci(this, i); s;)
            s._start === i && s.data === "isPause" && Ks(s),
            s = s._next
    }, e.killTweensOf = function(i, s, o) {
        for (var a = this.getTweensOf(i, o), l = a.length; l--;)
            ks !== a[l] && a[l].kill(i, s);
        return this
    }, e.getTweensOf = function(i, s) {
        for (var o = [], a = mi(i), l = this._first, c = vs(s), h; l;)
            l instanceof qe ? hw(l._targets, a) && (c ? (!ks || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && o.push(l) : (h = l.getTweensOf(a, s)).length && o.push.apply(o, h),
            l = l._next;
        return o
    }, e.tweenTo = function(i, s) {
        s = s || {};
        var o = this,
            a = ci(o, i),
            l = s,
            c = l.startAt,
            h = l.onStart,
            u = l.onStartParams,
            d = l.immediateRender,
            f,
            m = qe.to(o, _i({
                ease: s.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: a,
                overwrite: "auto",
                duration: s.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale()) || Re,
                onStart: function() {
                    if (o.pause(), !f) {
                        var g = s.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale());
                        m._dur !== g && Uo(m, g, 0, 1).render(m._time, !0, !0),
                        f = 1
                    }
                    h && h.apply(m, u || [])
                }
            }, s));
        return d ? m.render(0) : m
    }, e.tweenFromTo = function(i, s, o) {
        return this.tweenTo(s, _i({
            startAt: {
                time: ci(this, i)
            }
        }, o))
    }, e.recent = function() {
        return this._recent
    }, e.nextLabel = function(i) {
        return i === void 0 && (i = this._time), em(this, ci(this, i))
    }, e.previousLabel = function(i) {
        return i === void 0 && (i = this._time), em(this, ci(this, i), 1)
    }, e.currentLabel = function(i) {
        return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + Re)
    }, e.shiftChildren = function(i, s, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, l = this.labels, c; a;)
            a._start >= o && (a._start += i, a._end += i),
            a = a._next;
        if (s)
            for (c in l)
                l[c] >= o && (l[c] += i);
        return _r(this)
    }, e.invalidate = function(i) {
        var s = this._first;
        for (this._lock = 0; s;)
            s.invalidate(i),
            s = s._next;
        return r.prototype.invalidate.call(this, i)
    }, e.clear = function(i) {
        i === void 0 && (i = !0);
        for (var s = this._first, o; s;)
            o = s._next,
            this.remove(s),
            s = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), _r(this)
    }, e.totalDuration = function(i) {
        var s = 0,
            o = this,
            a = o._last,
            l = pi,
            c,
            h,
            u;
        if (arguments.length)
            return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -i : i));
        if (o._dirty) {
            for (u = o.parent; a;)
                c = a._prev,
                a._dirty && a.totalDuration(),
                h = a._start,
                h > l && o._sort && a._ts && !o._lock ? (o._lock = 1, zi(o, a, h - a._delay, 1)._lock = 0) : l = h,
                h < 0 && a._ts && (s -= h, (!u && !o._dp || u && u.smoothChildTiming) && (o._start += h / o._ts, o._time -= h, o._tTime -= h), o.shiftChildren(-h, !1, -1 / 0), l = 0),
                a._end > s && a._ts && (s = a._end),
                a = c;
            Uo(o, o === Be && o._time > s ? o._time : s, 1, 1),
            o._dirty = 0
        }
        return o._tDur
    }, t.updateRoot = function(i) {
        if (Be._ts && (Zg(Be, yc(i, Be)), Kg = ei.frame), ei.frame >= Zp) {
            Zp += si.autoSleep || 120;
            var s = Be._first;
            if ((!s || !s._ts) && si.autoSleep && ei._listeners.length < 2) {
                for (; s && !s._ts;)
                    s = s._next;
                s || ei.sleep()
            }
        }
    }, t
}(ka);
_i(Dn.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var Nw = function(t, e, n, i, s, o, a) {
        var l = new Gn(this._pt, t, e, 0, 1, b_, null, s),
            c = 0,
            h = 0,
            u,
            d,
            f,
            m,
            _,
            g,
            p,
            x;
        for (l.b = n, l.e = i, n += "", i += "", (p = ~i.indexOf("random(")) && (i = za(i)), o && (x = [n, i], o(x, t, e), n = x[0], i = x[1]), d = n.match(Eh) || []; u = Eh.exec(i);)
            m = u[0],
            _ = i.substring(c, u.index),
            f ? f = (f + 1) % 5 : _.substr(-5) === "rgba(" && (f = 1),
            m !== d[h++] && (g = parseFloat(d[h - 1]) || 0, l._pt = {
                _next: l._pt,
                p: _ || h === 1 ? _ : ",",
                s: g,
                c: m.charAt(1) === "=" ? _o(g, m) - g : parseFloat(m) - g,
                m: f && f < 4 ? Math.round : 0
            }, c = Eh.lastIndex);
        return l.c = c < i.length ? i.substring(c, i.length) : "", l.fp = a, (Wg.test(i) || p) && (l.e = 0), this._pt = l, l
    },
    Vd = function(t, e, n, i, s, o, a, l, c, h) {
        Ve(i) && (i = i(s || 0, t, o));
        var u = t[e],
            d = n !== "get" ? n : Ve(u) ? c ? t[e.indexOf("set") || !Ve(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](c) : t[e]() : u,
            f = Ve(u) ? c ? zw : T_ : Wd,
            m;
        if (ln(i) && (~i.indexOf("random(") && (i = za(i)), i.charAt(1) === "=" && (m = _o(d, i) + (Mn(d) || 0), (m || m === 0) && (i = m))), !h || d !== i || Vu)
            return !isNaN(d * i) && i !== "" ? (m = new Gn(this._pt, t, e, +d || 0, i - (d || 0), typeof u == "boolean" ? kw : E_, 0, f), c && (m.fp = c), a && m.modifier(a, this, t), this._pt = m) : (!u && !(e in t) && zd(e, i), Nw.call(this, t, e, d, i, f, l || si.stringFilter, c))
    },
    Iw = function(t, e, n, i, s) {
        if (Ve(t) && (t = va(t, s, e, n, i)), !Yi(t) || t.style && t.nodeType || Tn(t) || Vg(t))
            return ln(t) ? va(t, s, e, n, i) : t;
        var o = {},
            a;
        for (a in t)
            o[a] = va(t[a], s, e, n, i);
        return o
    },
    y_ = function(t, e, n, i, s, o) {
        var a,
            l,
            c,
            h;
        if (Qn[t] && (a = new Qn[t]).init(s, a.rawVars ? e[t] : Iw(e[t], i, s, o, n), n, i, o) !== !1 && (n._pt = l = new Gn(n._pt, s, t, 0, 1, a.render, a, 0, a.priority), n !== lo))
            for (c = n._ptLookup[n._targets.indexOf(s)], h = a._props.length; h--;)
                c[a._props[h]] = l;
        return a
    },
    ks,
    Vu,
    Gd = function r(t, e, n) {
        var i = t.vars,
            s = i.ease,
            o = i.startAt,
            a = i.immediateRender,
            l = i.lazy,
            c = i.onUpdate,
            h = i.runBackwards,
            u = i.yoyoEase,
            d = i.keyframes,
            f = i.autoRevert,
            m = t._dur,
            _ = t._startAt,
            g = t._targets,
            p = t.parent,
            x = p && p.data === "nested" ? p.vars.targets : g,
            v = t._overwrite === "auto" && !Id,
            y = t.timeline,
            C,
            A,
            T,
            R,
            E,
            M,
            D,
            I,
            k,
            $,
            j,
            G,
            H;
        if (y && (!d || !s) && (s = "none"), t._ease = xr(s, Io.ease), t._yEase = u ? g_(xr(u === !0 ? s : u, Io.ease)) : 0, u && t._yoyo && !t._repeat && (u = t._yEase, t._yEase = t._ease, t._ease = u), t._from = !y && !!i.runBackwards, !y || d && !i.stagger) {
            if (I = g[0] ? gr(g[0]).harness : 0, G = I && i[I.prop], C = vc(i, Bd), _ && (_._zTime < 0 && _.progress(1), e < 0 && h && a && !f ? _.render(-1, !0) : _.revert(h && m ? Jl : lw), _._lazy = 0), o) {
                if (Ks(t._startAt = qe.set(g, _i({
                    data: "isStart",
                    overwrite: !1,
                    parent: p,
                    immediateRender: !0,
                    lazy: !_ && Hn(l),
                    startAt: null,
                    delay: 0,
                    onUpdate: c && function() {
                        return ii(t, "onUpdate")
                    },
                    stagger: 0
                }, o))), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (Sn || !a && !f) && t._startAt.revert(Jl), a && m && e <= 0 && n <= 0) {
                    e && (t._zTime = e);
                    return
                }
            } else if (h && m && !_) {
                if (e && (a = !1), T = _i({
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: a && !_ && Hn(l),
                    immediateRender: a,
                    stagger: 0,
                    parent: p
                }, C), G && (T[I.prop] = G), Ks(t._startAt = qe.set(g, T)), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (Sn ? t._startAt.revert(Jl) : t._startAt.render(-1, !0)), t._zTime = e, !a)
                    r(t._startAt, Re, Re);
                else if (!e)
                    return
            }
            for (t._pt = t._ptCache = 0, l = m && Hn(l) || l && !m, A = 0; A < g.length; A++) {
                if (E = g[A], D = E._gsap || Hd(g)[A]._gsap, t._ptLookup[A] = $ = {}, Uu[D.id] && Ys.length && xc(), j = x === g ? A : x.indexOf(E), I && (k = new I).init(E, G || C, t, j, x) !== !1 && (t._pt = R = new Gn(t._pt, E, k.name, 0, 1, k.render, k, 0, k.priority), k._props.forEach(function(V) {
                    $[V] = R
                }), k.priority && (M = 1)), !I || G)
                    for (T in C)
                        Qn[T] && (k = y_(T, C, t, j, E, x)) ? k.priority && (M = 1) : $[T] = R = Vd.call(t, E, T, "get", C[T], j, x, 0, i.stringFilter);
                t._op && t._op[A] && t.kill(E, t._op[A]),
                v && t._pt && (ks = t, Be.killTweensOf(E, $, t.globalTime(e)), H = !t.parent, ks = 0),
                t._pt && l && (Uu[D.id] = 1)
            }
            M && w_(t),
            t._onInit && t._onInit(t)
        }
        t._onUpdate = c,
        t._initted = (!t._op || t._pt) && !H,
        d && e <= 0 && y.render(pi, !0, !0)
    },
    Fw = function(t, e, n, i, s, o, a, l) {
        var c = (t._pt && t._ptCache || (t._ptCache = {}))[e],
            h,
            u,
            d,
            f;
        if (!c)
            for (c = t._ptCache[e] = [], d = t._ptLookup, f = t._targets.length; f--;) {
                if (h = d[f][e], h && h.d && h.d._pt)
                    for (h = h.d._pt; h && h.p !== e && h.fp !== e;)
                        h = h._next;
                if (!h)
                    return Vu = 1, t.vars[e] = "+=0", Gd(t, a), Vu = 0, l ? Ua(e + " not eligible for reset") : 1;
                c.push(h)
            }
        for (f = c.length; f--;)
            u = c[f],
            h = u._pt || u,
            h.s = (i || i === 0) && !s ? i : h.s + (i || 0) + o * h.c,
            h.c = n - h.s,
            u.e && (u.e = Ge(n) + Mn(u.e)),
            u.b && (u.b = h.s + Mn(u.b))
    },
    Uw = function(t, e) {
        var n = t[0] ? gr(t[0]).harness : 0,
            i = n && n.aliases,
            s,
            o,
            a,
            l;
        if (!i)
            return e;
        s = Er({}, e);
        for (o in i)
            if (o in s)
                for (l = i[o].split(","), a = l.length; a--;)
                    s[l[a]] = s[o];
        return s
    },
    Ow = function(t, e, n, i) {
        var s = e.ease || i || "power1.inOut",
            o,
            a;
        if (Tn(e))
            a = n[t] || (n[t] = []),
            e.forEach(function(l, c) {
                return a.push({
                    t: c / (e.length - 1) * 100,
                    v: l,
                    e: s
                })
            });
        else
            for (o in e)
                a = n[o] || (n[o] = []),
                o === "ease" || a.push({
                    t: parseFloat(t),
                    v: e[o],
                    e: s
                })
    },
    va = function(t, e, n, i, s) {
        return Ve(t) ? t.call(e, n, i, s) : ln(t) && ~t.indexOf("random(") ? za(t) : t
    },
    M_ = kd + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    S_ = {};
Vn(M_ + ",id,stagger,delay,duration,paused,scrollTrigger", function(r) {
    return S_[r] = 1
});
var qe = function(r) {
    kg(t, r);
    function t(n, i, s, o) {
        var a;
        typeof i == "number" && (s.duration = i, i = s, s = null),
        a = r.call(this, o ? i : _a(i)) || this;
        var l = a.vars,
            c = l.duration,
            h = l.delay,
            u = l.immediateRender,
            d = l.stagger,
            f = l.overwrite,
            m = l.keyframes,
            _ = l.defaults,
            g = l.scrollTrigger,
            p = l.yoyoEase,
            x = i.parent || Be,
            v = (Tn(n) || Vg(n) ? vs(n[0]) : "length" in i) ? [n] : mi(n),
            y,
            C,
            A,
            T,
            R,
            E,
            M,
            D;
        if (a._targets = v.length ? Hd(v) : Ua("GSAP target " + n + " not found. https://gsap.com", !si.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = f, m || d || Rl(c) || Rl(h)) {
            if (i = a.vars, y = a.timeline = new Dn({
                data: "nested",
                defaults: _ || {},
                targets: x && x.data === "nested" ? x.vars.targets : v
            }), y.kill(), y.parent = y._dp = os(a), y._start = 0, d || Rl(c) || Rl(h)) {
                if (T = v.length, M = d && o_(d), Yi(d))
                    for (R in d)
                        ~M_.indexOf(R) && (D || (D = {}), D[R] = d[R]);
                for (C = 0; C < T; C++)
                    A = vc(i, S_),
                    A.stagger = 0,
                    p && (A.yoyoEase = p),
                    D && Er(A, D),
                    E = v[C],
                    A.duration = +va(c, os(a), C, E, v),
                    A.delay = (+va(h, os(a), C, E, v) || 0) - a._delay,
                    !d && T === 1 && A.delay && (a._delay = h = A.delay, a._start += h, A.delay = 0),
                    y.to(E, A, M ? M(C, E, v) : 0),
                    y._ease = ue.none;
                y.duration() ? c = h = 0 : a.timeline = 0
            } else if (m) {
                _a(_i(y.vars.defaults, {
                    ease: "none"
                })),
                y._ease = xr(m.ease || i.ease || "none");
                var I = 0,
                    k,
                    $,
                    j;
                if (Tn(m))
                    m.forEach(function(G) {
                        return y.to(v, G, ">")
                    }),
                    y.duration();
                else {
                    A = {};
                    for (R in m)
                        R === "ease" || R === "easeEach" || Ow(R, m[R], A, m.easeEach);
                    for (R in A)
                        for (k = A[R].sort(function(G, H) {
                            return G.t - H.t
                        }), I = 0, C = 0; C < k.length; C++)
                            $ = k[C],
                            j = {
                                ease: $.e,
                                duration: ($.t - (C ? k[C - 1].t : 0)) / 100 * c
                            },
                            j[R] = $.v,
                            y.to(v, j, I),
                            I += j.duration;
                    y.duration() < c && y.to({}, {
                        duration: c - y.duration()
                    })
                }
            }
            c || a.duration(c = y.duration())
        } else
            a.timeline = 0;
        return f === !0 && !Id && (ks = os(a), Be.killTweensOf(v), ks = 0), zi(x, os(a), s), i.reversed && a.reverse(), i.paused && a.paused(!0), (u || !c && !m && a._start === rn(x._time) && Hn(u) && pw(os(a)) && x.data !== "nested") && (a._tTime = -Re, a.render(Math.max(0, -h) || 0)), g && n_(os(a), g), a
    }
    var e = t.prototype;
    return e.render = function(i, s, o) {
        var a = this._time,
            l = this._tDur,
            c = this._dur,
            h = i < 0,
            u = i > l - Re && !h ? l : i < Re ? 0 : i,
            d,
            f,
            m,
            _,
            g,
            p,
            x,
            v,
            y;
        if (!c)
            gw(this, i, s, o);
        else if (u !== this._tTime || !i || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h) {
            if (d = u, v = this.timeline, this._repeat) {
                if (_ = c + this._rDelay, this._repeat < -1 && h)
                    return this.totalTime(_ * 100 + i, s, o);
                if (d = rn(u % _), u === l ? (m = this._repeat, d = c) : (m = ~~(u / _), m && m === rn(u / _) && (d = c, m--), d > c && (d = c)), p = this._yoyo && m & 1, p && (y = this._yEase, d = c - d), g = Fo(this._tTime, _), d === a && !o && this._initted && m === g)
                    return this._tTime = u, this;
                m !== g && (v && this._yEase && __(v, p), this.vars.repeatRefresh && !p && !this._lock && this._time !== _ && this._initted && (this._lock = o = 1, this.render(rn(_ * m), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (i_(this, h ? i : d, o, s, u))
                    return this._tTime = 0, this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && m !== g))
                    return this;
                if (c !== this._dur)
                    return this.render(i, s, o)
            }
            if (this._tTime = u, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = x = (y || this._ease)(d / c), this._from && (this.ratio = x = 1 - x), d && !a && !s && !m && (ii(this, "onStart"), this._tTime !== u))
                return this;
            for (f = this._pt; f;)
                f.r(x, f.d),
                f = f._next;
            v && v.render(i < 0 ? i : v._dur * v._ease(d / this._dur), s, o) || this._startAt && (this._zTime = i),
            this._onUpdate && !s && (h && Ou(this, i, s, o), ii(this, "onUpdate")),
            this._repeat && m !== g && this.vars.onRepeat && !s && this.parent && ii(this, "onRepeat"),
            (u === this._tDur || !u) && this._tTime === u && (h && !this._onUpdate && Ou(this, i, !0, !0), (i || !c) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && Ks(this, 1), !s && !(h && !a) && (u || a || p) && (ii(this, u === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }, e.targets = function() {
        return this._targets
    }, e.invalidate = function(i) {
        return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), r.prototype.invalidate.call(this, i)
    }, e.resetTo = function(i, s, o, a, l) {
        Ba || ei.wake(),
        this._ts || this.play();
        var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
            h;
        return this._initted || Gd(this, c), h = this._ease(c / this._dur), Fw(this, i, s, o, a, h, c, l) ? this.resetTo(i, s, o, a, 1) : (Fc(this, 0), this.parent || t_(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
    }, e.kill = function(i, s) {
        if (s === void 0 && (s = "all"), !i && (!s || s === "all"))
            return this._lazy = this._pt = 0, this.parent ? aa(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(i, s, ks && ks.vars.overwrite !== !0)._first || aa(this), this.parent && o !== this.timeline.totalDuration() && Uo(this, this._dur * this.timeline._tDur / o, 0, 1), this
        }
        var a = this._targets,
            l = i ? mi(i) : a,
            c = this._ptLookup,
            h = this._pt,
            u,
            d,
            f,
            m,
            _,
            g,
            p;
        if ((!s || s === "all") && dw(a, l))
            return s === "all" && (this._pt = 0), aa(this);
        for (u = this._op = this._op || [], s !== "all" && (ln(s) && (_ = {}, Vn(s, function(x) {
            return _[x] = 1
        }), s = _), s = Uw(a, s)), p = a.length; p--;)
            if (~l.indexOf(a[p])) {
                d = c[p],
                s === "all" ? (u[p] = s, m = d, f = {}) : (f = u[p] = u[p] || {}, m = s);
                for (_ in m)
                    g = d && d[_],
                    g && ((!("kill" in g.d) || g.d.kill(_) === !0) && Nc(this, g, "_pt"), delete d[_]),
                    f !== "all" && (f[_] = 1)
            }
        return this._initted && !this._pt && h && aa(this), this
    }, t.to = function(i, s) {
        return new t(i, s, arguments[2])
    }, t.from = function(i, s) {
        return xa(1, arguments)
    }, t.delayedCall = function(i, s, o, a) {
        return new t(s, 0, {
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: i,
            onComplete: s,
            onReverseComplete: s,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }, t.fromTo = function(i, s, o) {
        return xa(2, arguments)
    }, t.set = function(i, s) {
        return s.duration = 0, s.repeatDelay || (s.repeat = 0), new t(i, s)
    }, t.killTweensOf = function(i, s, o) {
        return Be.killTweensOf(i, s, o)
    }, t
}(ka);
_i(qe.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
Vn("staggerTo,staggerFrom,staggerFromTo", function(r) {
    qe[r] = function() {
        var t = new Dn,
            e = Bu.call(arguments, 0);
        return e.splice(r === "staggerFromTo" ? 5 : 4, 0, 0), t[r].apply(t, e)
    }
});
var Wd = function(t, e, n) {
        return t[e] = n
    },
    T_ = function(t, e, n) {
        return t[e](n)
    },
    zw = function(t, e, n, i) {
        return t[e](i.fp, n)
    },
    Bw = function(t, e, n) {
        return t.setAttribute(e, n)
    },
    Xd = function(t, e) {
        return Ve(t[e]) ? T_ : Fd(t[e]) && t.setAttribute ? Bw : Wd
    },
    E_ = function(t, e) {
        return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e6) / 1e6, e)
    },
    kw = function(t, e) {
        return e.set(e.t, e.p, !!(e.s + e.c * t), e)
    },
    b_ = function(t, e) {
        var n = e._pt,
            i = "";
        if (!t && e.b)
            i = e.b;
        else if (t === 1 && e.e)
            i = e.e;
        else {
            for (; n;)
                i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round((n.s + n.c * t) * 1e4) / 1e4) + i,
                n = n._next;
            i += e.c
        }
        e.set(e.t, e.p, i, e)
    },
    Yd = function(t, e) {
        for (var n = e._pt; n;)
            n.r(t, n.d),
            n = n._next
    },
    Hw = function(t, e, n, i) {
        for (var s = this._pt, o; s;)
            o = s._next,
            s.p === i && s.modifier(t, e, n),
            s = o
    },
    Vw = function(t) {
        for (var e = this._pt, n, i; e;)
            i = e._next,
            e.p === t && !e.op || e.op === t ? Nc(this, e, "_pt") : e.dep || (n = 1),
            e = i;
        return !n
    },
    Gw = function(t, e, n, i) {
        i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
    },
    w_ = function(t) {
        for (var e = t._pt, n, i, s, o; e;) {
            for (n = e._next, i = s; i && i.pr > e.pr;)
                i = i._next;
            (e._prev = i ? i._prev : o) ? e._prev._next = e : s = e,
            (e._next = i) ? i._prev = e : o = e,
            e = n
        }
        t._pt = s
    },
    Gn = function() {
        function r(e, n, i, s, o, a, l, c, h) {
            this.t = n,
            this.s = s,
            this.c = o,
            this.p = i,
            this.r = a || E_,
            this.d = l || this,
            this.set = c || Wd,
            this.pr = h || 0,
            this._next = e,
            e && (e._prev = this)
        }
        var t = r.prototype;
        return t.modifier = function(n, i, s) {
            this.mSet = this.mSet || this.set,
            this.set = Gw,
            this.m = n,
            this.mt = s,
            this.tween = i
        }, r
    }();
Vn(kd + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(r) {
    return Bd[r] = 1
});
ri.TweenMax = ri.TweenLite = qe;
ri.TimelineLite = ri.TimelineMax = Dn;
Be = new Dn({
    sortChildren: !1,
    defaults: Io,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
si.stringFilter = m_;
var vr = [],
    tc = {},
    Ww = [],
    im = 0,
    Xw = 0,
    Rh = function(t) {
        return (tc[t] || Ww).map(function(e) {
            return e()
        })
    },
    Gu = function() {
        var t = Date.now(),
            e = [];
        t - im > 2 && (Rh("matchMediaInit"), vr.forEach(function(n) {
            var i = n.queries,
                s = n.conditions,
                o,
                a,
                l,
                c;
            for (a in i)
                o = Ii.matchMedia(i[a]).matches,
                o && (l = 1),
                o !== s[a] && (s[a] = o, c = 1);
            c && (n.revert(), l && e.push(n))
        }), Rh("matchMediaRevert"), e.forEach(function(n) {
            return n.onMatch(n, function(i) {
                return n.add(null, i)
            })
        }), im = t, Rh("matchMedia"))
    },
    A_ = function() {
        function r(e, n) {
            this.selector = n && ku(n),
            this.data = [],
            this._r = [],
            this.isReverted = !1,
            this.id = Xw++,
            e && this.add(e)
        }
        var t = r.prototype;
        return t.add = function(n, i, s) {
            Ve(n) && (s = i, i = n, n = Ve);
            var o = this,
                a = function() {
                    var c = Ue,
                        h = o.selector,
                        u;
                    return c && c !== o && c.data.push(o), s && (o.selector = ku(s)), Ue = o, u = i.apply(o, arguments), Ve(u) && o._r.push(u), Ue = c, o.selector = h, o.isReverted = !1, u
                };
            return o.last = a, n === Ve ? a(o, function(l) {
                return o.add(null, l)
            }) : n ? o[n] = a : a
        }, t.ignore = function(n) {
            var i = Ue;
            Ue = null,
            n(this),
            Ue = i
        }, t.getTweens = function() {
            var n = [];
            return this.data.forEach(function(i) {
                return i instanceof r ? n.push.apply(n, i.getTweens()) : i instanceof qe && !(i.parent && i.parent.data === "nested") && n.push(i)
            }), n
        }, t.clear = function() {
            this._r.length = this.data.length = 0
        }, t.kill = function(n, i) {
            var s = this;
            if (n ? function() {
                for (var a = s.getTweens(), l = s.data.length, c; l--;)
                    c = s.data[l],
                    c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function(h) {
                        return a.splice(a.indexOf(h), 1)
                    }));
                for (a.map(function(h) {
                    return {
                        g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0,
                        t: h
                    }
                }).sort(function(h, u) {
                    return u.g - h.g || -1 / 0
                }).forEach(function(h) {
                    return h.t.revert(n)
                }), l = s.data.length; l--;)
                    c = s.data[l],
                    c instanceof Dn ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof qe) && c.revert && c.revert(n);
                s._r.forEach(function(h) {
                    return h(n, s)
                }),
                s.isReverted = !0
            }() : this.data.forEach(function(a) {
                return a.kill && a.kill()
            }), this.clear(), i)
                for (var o = vr.length; o--;)
                    vr[o].id === this.id && vr.splice(o, 1)
        }, t.revert = function(n) {
            this.kill(n || {})
        }, r
    }(),
    Yw = function() {
        function r(e) {
            this.contexts = [],
            this.scope = e,
            Ue && Ue.data.push(this)
        }
        var t = r.prototype;
        return t.add = function(n, i, s) {
            Yi(n) || (n = {
                matches: n
            });
            var o = new A_(0, s || this.scope),
                a = o.conditions = {},
                l,
                c,
                h;
            Ue && !o.selector && (o.selector = Ue.selector),
            this.contexts.push(o),
            i = o.add("onMatch", i),
            o.queries = n;
            for (c in n)
                c === "all" ? h = 1 : (l = Ii.matchMedia(n[c]), l && (vr.indexOf(o) < 0 && vr.push(o), (a[c] = l.matches) && (h = 1), l.addListener ? l.addListener(Gu) : l.addEventListener("change", Gu)));
            return h && i(o, function(u) {
                return o.add(null, u)
            }), this
        }, t.revert = function(n) {
            this.kill(n || {})
        }, t.kill = function(n) {
            this.contexts.forEach(function(i) {
                return i.kill(n, !0)
            })
        }, r
    }(),
    Mc = {
        registerPlugin: function() {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                e[n] = arguments[n];
            e.forEach(function(i) {
                return d_(i)
            })
        },
        timeline: function(t) {
            return new Dn(t)
        },
        getTweensOf: function(t, e) {
            return Be.getTweensOf(t, e)
        },
        getProperty: function(t, e, n, i) {
            ln(t) && (t = mi(t)[0]);
            var s = gr(t || {}).get,
                o = n ? Qg : Jg;
            return n === "native" && (n = ""), t && (e ? o((Qn[e] && Qn[e].get || s)(t, e, n, i)) : function(a, l, c) {
                return o((Qn[a] && Qn[a].get || s)(t, a, l, c))
            })
        },
        quickSetter: function(t, e, n) {
            if (t = mi(t), t.length > 1) {
                var i = t.map(function(h) {
                        return Xn.quickSetter(h, e, n)
                    }),
                    s = i.length;
                return function(h) {
                    for (var u = s; u--;)
                        i[u](h)
                }
            }
            t = t[0] || {};
            var o = Qn[e],
                a = gr(t),
                l = a.harness && (a.harness.aliases || {})[e] || e,
                c = o ? function(h) {
                    var u = new o;
                    lo._pt = 0,
                    u.init(t, n ? h + n : h, lo, 0, [t]),
                    u.render(1, u),
                    lo._pt && Yd(1, lo)
                } : a.set(t, l);
            return o ? c : function(h) {
                return c(t, l, n ? h + n : h, a, 1)
            }
        },
        quickTo: function(t, e, n) {
            var i,
                s = Xn.to(t, Er((i = {}, i[e] = "+=0.1", i.paused = !0, i), n || {})),
                o = function(l, c, h) {
                    return s.resetTo(e, l, c, h)
                };
            return o.tween = s, o
        },
        isTweening: function(t) {
            return Be.getTweensOf(t, !0).length > 0
        },
        defaults: function(t) {
            return t && t.ease && (t.ease = xr(t.ease, Io.ease)), Jp(Io, t || {})
        },
        config: function(t) {
            return Jp(si, t || {})
        },
        registerEffect: function(t) {
            var e = t.name,
                n = t.effect,
                i = t.plugins,
                s = t.defaults,
                o = t.extendTimeline;
            (i || "").split(",").forEach(function(a) {
                return a && !Qn[a] && !ri[a] && Ua(e + " effect requires " + a + " plugin.")
            }),
            bh[e] = function(a, l, c) {
                return n(mi(a), _i(l || {}, s), c)
            },
            o && (Dn.prototype[e] = function(a, l, c) {
                return this.add(bh[e](a, Yi(l) ? l : (c = l) && {}, this), c)
            })
        },
        registerEase: function(t, e) {
            ue[t] = xr(e)
        },
        parseEase: function(t, e) {
            return arguments.length ? xr(t, e) : ue
        },
        getById: function(t) {
            return Be.getById(t)
        },
        exportRoot: function(t, e) {
            t === void 0 && (t = {});
            var n = new Dn(t),
                i,
                s;
            for (n.smoothChildTiming = Hn(t.smoothChildTiming), Be.remove(n), n._dp = 0, n._time = n._tTime = Be._time, i = Be._first; i;)
                s = i._next,
                (e || !(!i._dur && i instanceof qe && i.vars.onComplete === i._targets[0])) && zi(n, i, i._start - i._delay),
                i = s;
            return zi(Be, n, 0), n
        },
        context: function(t, e) {
            return t ? new A_(t, e) : Ue
        },
        matchMedia: function(t) {
            return new Yw(t)
        },
        matchMediaRefresh: function() {
            return vr.forEach(function(t) {
                    var e = t.conditions,
                        n,
                        i;
                    for (i in e)
                        e[i] && (e[i] = !1, n = 1);
                    n && t.revert()
                }) || Gu()
        },
        addEventListener: function(t, e) {
            var n = tc[t] || (tc[t] = []);
            ~n.indexOf(e) || n.push(e)
        },
        removeEventListener: function(t, e) {
            var n = tc[t],
                i = n && n.indexOf(e);
            i >= 0 && n.splice(i, 1)
        },
        utils: {
            wrap: Ew,
            wrapYoyo: bw,
            distribute: o_,
            random: l_,
            snap: a_,
            normalize: Tw,
            getUnit: Mn,
            clamp: vw,
            splitColor: f_,
            toArray: mi,
            selector: ku,
            mapRange: h_,
            pipe: Mw,
            unitize: Sw,
            interpolate: ww,
            shuffle: r_
        },
        install: $g,
        effects: bh,
        ticker: ei,
        updateRoot: Dn.updateRoot,
        plugins: Qn,
        globalTimeline: Be,
        core: {
            PropTween: Gn,
            globals: qg,
            Tween: qe,
            Timeline: Dn,
            Animation: ka,
            getCache: gr,
            _removeLinkedListItem: Nc,
            reverting: function() {
                return Sn
            },
            context: function(t) {
                return t && Ue && (Ue.data.push(t), t._ctx = Ue), Ue
            },
            suppressOverwrites: function(t) {
                return Id = t
            }
        }
    };
Vn("to,from,fromTo,delayedCall,set,killTweensOf", function(r) {
    return Mc[r] = qe[r]
});
ei.add(Dn.updateRoot);
lo = Mc.to({}, {
    duration: 0
});
var $w = function(t, e) {
        for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;)
            n = n._next;
        return n
    },
    qw = function(t, e) {
        var n = t._targets,
            i,
            s,
            o;
        for (i in e)
            for (s = n.length; s--;)
                o = t._ptLookup[s][i],
                o && (o = o.d) && (o._pt && (o = $w(o, i)), o && o.modifier && o.modifier(e[i], t, n[s], i))
    },
    Ph = function(t, e) {
        return {
            name: t,
            rawVars: 1,
            init: function(i, s, o) {
                o._onInit = function(a) {
                    var l,
                        c;
                    if (ln(s) && (l = {}, Vn(s, function(h) {
                        return l[h] = 1
                    }), s = l), e) {
                        l = {};
                        for (c in s)
                            l[c] = e(s[c]);
                        s = l
                    }
                    qw(a, s)
                }
            }
        }
    },
    Xn = Mc.registerPlugin({
        name: "attr",
        init: function(t, e, n, i, s) {
            var o,
                a,
                l;
            this.tween = n;
            for (o in e)
                l = t.getAttribute(o) || "",
                a = this.add(t, "setAttribute", (l || 0) + "", e[o], i, s, 0, 0, o),
                a.op = o,
                a.b = l,
                this._props.push(o)
        },
        render: function(t, e) {
            for (var n = e._pt; n;)
                Sn ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d),
                n = n._next
        }
    }, {
        name: "endArray",
        init: function(t, e) {
            for (var n = e.length; n--;)
                this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1)
        }
    }, Ph("roundProps", Hu), Ph("modifiers"), Ph("snap", a_)) || Mc;
qe.version = Dn.version = Xn.version = "3.12.5";
Yg = 1;
Ud() && Oo();
ue.Power0;
ue.Power1;
ue.Power2;
ue.Power3;
ue.Power4;
ue.Linear;
ue.Quad;
ue.Cubic;
ue.Quart;
ue.Quint;
ue.Strong;
ue.Elastic;
ue.Back;
ue.SteppedEase;
ue.Bounce;
ue.Sine;
ue.Expo;
ue.Circ; /*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/







var sm,
    Hs,
    xo,
    $d,
    pr,
    rm,
    qd,
    Kw = function() {
        return typeof window < "u"
    },
    ys = {},
    cr = 180 / Math.PI,
    vo = Math.PI / 180,
    Qr = Math.atan2,
    om = 1e8,
    Kd = /([A-Z])/g,
    jw = /(left|right|width|margin|padding|x)/i,
    Zw = /[\s,\(]\S/,
    Bi = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
    },
    Wu = function(t, e) {
        return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u, e)
    },
    Jw = function(t, e) {
        return e.set(e.t, e.p, t === 1 ? e.e : Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u, e)
    },
    Qw = function(t, e) {
        return e.set(e.t, e.p, t ? Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u : e.b, e)
    },
    t1 = function(t, e) {
        var n = e.s + e.c * t;
        e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
    },
    C_ = function(t, e) {
        return e.set(e.t, e.p, t ? e.e : e.b, e)
    },
    R_ = function(t, e) {
        return e.set(e.t, e.p, t !== 1 ? e.b : e.e, e)
    },
    e1 = function(t, e, n) {
        return t.style[e] = n
    },
    n1 = function(t, e, n) {
        return t.style.setProperty(e, n)
    },
    i1 = function(t, e, n) {
        return t._gsap[e] = n
    },
    s1 = function(t, e, n) {
        return t._gsap.scaleX = t._gsap.scaleY = n
    },
    r1 = function(t, e, n, i, s) {
        var o = t._gsap;
        o.scaleX = o.scaleY = n,
        o.renderTransform(s, o)
    },
    o1 = function(t, e, n, i, s) {
        var o = t._gsap;
        o[e] = n,
        o.renderTransform(s, o)
    },
    ke = "transform",
    Wn = ke + "Origin",
    a1 = function r(t, e) {
        var n = this,
            i = this.target,
            s = i.style,
            o = i._gsap;
        if (t in ys && s) {
            if (this.tfm = this.tfm || {}, t !== "transform")
                t = Bi[t] || t,
                ~t.indexOf(",") ? t.split(",").forEach(function(a) {
                    return n.tfm[a] = as(i, a)
                }) : this.tfm[t] = o.x ? o[t] : as(i, t),
                t === Wn && (this.tfm.zOrigin = o.zOrigin);
            else
                return Bi.transform.split(",").forEach(function(a) {
                    return r.call(n, a, e)
                });
            if (this.props.indexOf(ke) >= 0)
                return;
            o.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(Wn, e, "")),
            t = ke
        }
        (s || e) && this.props.push(t, e, s[t])
    },
    P_ = function(t) {
        t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"))
    },
    l1 = function() {
        var t = this.props,
            e = this.target,
            n = e.style,
            i = e._gsap,
            s,
            o;
        for (s = 0; s < t.length; s += 3)
            t[s + 1] ? e[t[s]] = t[s + 2] : t[s + 2] ? n[t[s]] = t[s + 2] : n.removeProperty(t[s].substr(0, 2) === "--" ? t[s] : t[s].replace(Kd, "-$1").toLowerCase());
        if (this.tfm) {
            for (o in this.tfm)
                i[o] = this.tfm[o];
            i.svg && (i.renderTransform(), e.setAttribute("data-svg-origin", this.svgo || "")),
            s = qd(),
            (!s || !s.isStart) && !n[ke] && (P_(n), i.zOrigin && n[Wn] && (n[Wn] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1)
        }
    },
    L_ = function(t, e) {
        var n = {
            target: t,
            props: [],
            revert: l1,
            save: a1
        };
        return t._gsap || Xn.core.getCache(t), e && e.split(",").forEach(function(i) {
            return n.save(i)
        }), n
    },
    D_,
    Xu = function(t, e) {
        var n = Hs.createElementNS ? Hs.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Hs.createElement(t);
        return n && n.style ? n : Hs.createElement(t)
    },
    Vi = function r(t, e, n) {
        var i = getComputedStyle(t);
        return i[e] || i.getPropertyValue(e.replace(Kd, "-$1").toLowerCase()) || i.getPropertyValue(e) || !n && r(t, zo(e) || e, 1) || ""
    },
    am = "O,Moz,ms,Ms,Webkit".split(","),
    zo = function(t, e, n) {
        var i = e || pr,
            s = i.style,
            o = 5;
        if (t in s && !n)
            return t;
        for (t = t.charAt(0).toUpperCase() + t.substr(1); o-- && !(am[o] + t in s);)
            ;
        return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? am[o] : "") + t
    },
    Yu = function() {
        Kw() && window.document && (sm = window, Hs = sm.document, xo = Hs.documentElement, pr = Xu("div") || {
            style: {}
        }, Xu("div"), ke = zo(ke), Wn = ke + "Origin", pr.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", D_ = !!zo("perspective"), qd = Xn.core.reverting, $d = 1)
    },
    Lh = function r(t) {
        var e = Xu("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
            n = this.parentNode,
            i = this.nextSibling,
            s = this.style.cssText,
            o;
        if (xo.appendChild(e), e.appendChild(this), this.style.display = "block", t)
            try {
                o = this.getBBox(),
                this._gsapBBox = this.getBBox,
                this.getBBox = r
            } catch {}
        else
            this._gsapBBox && (o = this._gsapBBox());
        return n && (i ? n.insertBefore(this, i) : n.appendChild(this)), xo.removeChild(e), this.style.cssText = s, o
    },
    lm = function(t, e) {
        for (var n = e.length; n--;)
            if (t.hasAttribute(e[n]))
                return t.getAttribute(e[n])
    },
    N_ = function(t) {
        var e;
        try {
            e = t.getBBox()
        } catch {
            e = Lh.call(t, !0)
        }
        return e && (e.width || e.height) || t.getBBox === Lh || (e = Lh.call(t, !0)), e && !e.width && !e.x && !e.y ? {
            x: +lm(t, ["x", "cx", "x1"]) || 0,
            y: +lm(t, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        } : e
    },
    I_ = function(t) {
        return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && N_(t))
    },
    br = function(t, e) {
        if (e) {
            var n = t.style,
                i;
            e in ys && e !== Wn && (e = ke),
            n.removeProperty ? (i = e.substr(0, 2), (i === "ms" || e.substr(0, 6) === "webkit") && (e = "-" + e), n.removeProperty(i === "--" ? e : e.replace(Kd, "-$1").toLowerCase())) : n.removeAttribute(e)
        }
    },
    Vs = function(t, e, n, i, s, o) {
        var a = new Gn(t._pt, e, n, 0, 1, o ? R_ : C_);
        return t._pt = a, a.b = i, a.e = s, t._props.push(n), a
    },
    cm = {
        deg: 1,
        rad: 1,
        turn: 1
    },
    c1 = {
        grid: 1,
        flex: 1
    },
    js = function r(t, e, n, i) {
        var s = parseFloat(n) || 0,
            o = (n + "").trim().substr((s + "").length) || "px",
            a = pr.style,
            l = jw.test(e),
            c = t.tagName.toLowerCase() === "svg",
            h = (c ? "client" : "offset") + (l ? "Width" : "Height"),
            u = 100,
            d = i === "px",
            f = i === "%",
            m,
            _,
            g,
            p;
        if (i === o || !s || cm[i] || cm[o])
            return s;
        if (o !== "px" && !d && (s = r(t, e, n, "px")), p = t.getCTM && I_(t), (f || o === "%") && (ys[e] || ~e.indexOf("adius")))
            return m = p ? t.getBBox()[l ? "width" : "height"] : t[h], Ge(f ? s / m * u : s / 100 * m);
        if (a[l ? "width" : "height"] = u + (d ? o : i), _ = ~e.indexOf("adius") || i === "em" && t.appendChild && !c ? t : t.parentNode, p && (_ = (t.ownerSVGElement || {}).parentNode), (!_ || _ === Hs || !_.appendChild) && (_ = Hs.body), g = _._gsap, g && f && g.width && l && g.time === ei.time && !g.uncache)
            return Ge(s / g.width * u);
        if (f && (e === "height" || e === "width")) {
            var x = t.style[e];
            t.style[e] = u + i,
            m = t[h],
            x ? t.style[e] = x : br(t, e)
        } else
            (f || o === "%") && !c1[Vi(_, "display")] && (a.position = Vi(t, "position")),
            _ === t && (a.position = "static"),
            _.appendChild(pr),
            m = pr[h],
            _.removeChild(pr),
            a.position = "absolute";
        return l && f && (g = gr(_), g.time = ei.time, g.width = _[h]), Ge(d ? m * s / u : m && s ? u / m * s : 0)
    },
    as = function(t, e, n, i) {
        var s;
        return $d || Yu(), e in Bi && e !== "transform" && (e = Bi[e], ~e.indexOf(",") && (e = e.split(",")[0])), ys[e] && e !== "transform" ? (s = Va(t, i), s = e !== "transformOrigin" ? s[e] : s.svg ? s.origin : Tc(Vi(t, Wn)) + " " + s.zOrigin + "px") : (s = t.style[e], (!s || s === "auto" || i || ~(s + "").indexOf("calc(")) && (s = Sc[e] && Sc[e](t, e, n) || Vi(t, e) || jg(t, e) || (e === "opacity" ? 1 : 0))), n && !~(s + "").trim().indexOf(" ") ? js(t, e, s, n) + n : s
    },
    h1 = function(t, e, n, i) {
        if (!n || n === "none") {
            var s = zo(e, t, 1),
                o = s && Vi(t, s, 1);
            o && o !== n ? (e = s, n = o) : e === "borderColor" && (n = Vi(t, "borderTopColor"))
        }
        var a = new Gn(this._pt, t.style, e, 0, 1, b_),
            l = 0,
            c = 0,
            h,
            u,
            d,
            f,
            m,
            _,
            g,
            p,
            x,
            v,
            y,
            C;
        if (a.b = n, a.e = i, n += "", i += "", i === "auto" && (_ = t.style[e], t.style[e] = i, i = Vi(t, e) || i, _ ? t.style[e] = _ : br(t, e)), h = [n, i], m_(h), n = h[0], i = h[1], d = n.match(ao) || [], C = i.match(ao) || [], C.length) {
            for (; u = ao.exec(i);)
                g = u[0],
                x = i.substring(l, u.index),
                m ? m = (m + 1) % 5 : (x.substr(-5) === "rgba(" || x.substr(-5) === "hsla(") && (m = 1),
                g !== (_ = d[c++] || "") && (f = parseFloat(_) || 0, y = _.substr((f + "").length), g.charAt(1) === "=" && (g = _o(f, g) + y), p = parseFloat(g), v = g.substr((p + "").length), l = ao.lastIndex - v.length, v || (v = v || si.units[e] || y, l === i.length && (i += v, a.e += v)), y !== v && (f = js(t, e, _, v) || 0), a._pt = {
                    _next: a._pt,
                    p: x || c === 1 ? x : ",",
                    s: f,
                    c: p - f,
                    m: m && m < 4 || e === "zIndex" ? Math.round : 0
                });
            a.c = l < i.length ? i.substring(l, i.length) : ""
        } else
            a.r = e === "display" && i === "none" ? R_ : C_;
        return Wg.test(i) && (a.e = 0), this._pt = a, a
    },
    hm = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
    },
    u1 = function(t) {
        var e = t.split(" "),
            n = e[0],
            i = e[1] || "50%";
        return (n === "top" || n === "bottom" || i === "left" || i === "right") && (t = n, n = i, i = t), e[0] = hm[n] || n, e[1] = hm[i] || i, e.join(" ")
    },
    d1 = function(t, e) {
        if (e.tween && e.tween._time === e.tween._dur) {
            var n = e.t,
                i = n.style,
                s = e.u,
                o = n._gsap,
                a,
                l,
                c;
            if (s === "all" || s === !0)
                i.cssText = "",
                l = 1;
            else
                for (s = s.split(","), c = s.length; --c > -1;)
                    a = s[c],
                    ys[a] && (l = 1, a = a === "transformOrigin" ? Wn : ke),
                    br(n, a);
            l && (br(n, ke), o && (o.svg && n.removeAttribute("transform"), Va(n, 1), o.uncache = 1, P_(i)))
        }
    },
    Sc = {
        clearProps: function(t, e, n, i, s) {
            if (s.data !== "isFromStart") {
                var o = t._pt = new Gn(t._pt, e, n, 0, 0, d1);
                return o.u = i, o.pr = -10, o.tween = s, t._props.push(n), 1
            }
        }
    },
    Ha = [1, 0, 0, 1, 0, 0],
    F_ = {},
    U_ = function(t) {
        return t === "matrix(1, 0, 0, 1, 0, 0)" || t === "none" || !t
    },
    um = function(t) {
        var e = Vi(t, ke);
        return U_(e) ? Ha : e.substr(7).match(Gg).map(Ge)
    },
    jd = function(t, e) {
        var n = t._gsap || gr(t),
            i = t.style,
            s = um(t),
            o,
            a,
            l,
            c;
        return n.svg && t.getAttribute("transform") ? (l = t.transform.baseVal.consolidate().matrix, s = [l.a, l.b, l.c, l.d, l.e, l.f], s.join(",") === "1,0,0,1,0,0" ? Ha : s) : (s === Ha && !t.offsetParent && t !== xo && !n.svg && (l = i.display, i.display = "block", o = t.parentNode, (!o || !t.offsetParent) && (c = 1, a = t.nextElementSibling, xo.appendChild(t)), s = um(t), l ? i.display = l : br(t, "display"), c && (a ? o.insertBefore(t, a) : o ? o.appendChild(t) : xo.removeChild(t))), e && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
    },
    $u = function(t, e, n, i, s, o) {
        var a = t._gsap,
            l = s || jd(t, !0),
            c = a.xOrigin || 0,
            h = a.yOrigin || 0,
            u = a.xOffset || 0,
            d = a.yOffset || 0,
            f = l[0],
            m = l[1],
            _ = l[2],
            g = l[3],
            p = l[4],
            x = l[5],
            v = e.split(" "),
            y = parseFloat(v[0]) || 0,
            C = parseFloat(v[1]) || 0,
            A,
            T,
            R,
            E;
        n ? l !== Ha && (T = f * g - m * _) && (R = y * (g / T) + C * (-_ / T) + (_ * x - g * p) / T, E = y * (-m / T) + C * (f / T) - (f * x - m * p) / T, y = R, C = E) : (A = N_(t), y = A.x + (~v[0].indexOf("%") ? y / 100 * A.width : y), C = A.y + (~(v[1] || v[0]).indexOf("%") ? C / 100 * A.height : C)),
        i || i !== !1 && a.smooth ? (p = y - c, x = C - h, a.xOffset = u + (p * f + x * _) - p, a.yOffset = d + (p * m + x * g) - x) : a.xOffset = a.yOffset = 0,
        a.xOrigin = y,
        a.yOrigin = C,
        a.smooth = !!i,
        a.origin = e,
        a.originIsAbsolute = !!n,
        t.style[Wn] = "0px 0px",
        o && (Vs(o, a, "xOrigin", c, y), Vs(o, a, "yOrigin", h, C), Vs(o, a, "xOffset", u, a.xOffset), Vs(o, a, "yOffset", d, a.yOffset)),
        t.setAttribute("data-svg-origin", y + " " + C)
    },
    Va = function(t, e) {
        var n = t._gsap || new v_(t);
        if ("x" in n && !e && !n.uncache)
            return n;
        var i = t.style,
            s = n.scaleX < 0,
            o = "px",
            a = "deg",
            l = getComputedStyle(t),
            c = Vi(t, Wn) || "0",
            h,
            u,
            d,
            f,
            m,
            _,
            g,
            p,
            x,
            v,
            y,
            C,
            A,
            T,
            R,
            E,
            M,
            D,
            I,
            k,
            $,
            j,
            G,
            H,
            V,
            nt,
            P,
            ct,
            Ut,
            Zt,
            J,
            it;
        return h = u = d = _ = g = p = x = v = y = 0, f = m = 1, n.svg = !!(t.getCTM && I_(t)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (i[ke] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[ke] !== "none" ? l[ke] : "")), i.scale = i.rotate = i.translate = "none"), T = jd(t, n.svg), n.svg && (n.uncache ? (V = t.getBBox(), c = n.xOrigin - V.x + "px " + (n.yOrigin - V.y) + "px", H = "") : H = !e && t.getAttribute("data-svg-origin"), $u(t, H || c, !!H || n.originIsAbsolute, n.smooth !== !1, T)), C = n.xOrigin || 0, A = n.yOrigin || 0, T !== Ha && (D = T[0], I = T[1], k = T[2], $ = T[3], h = j = T[4], u = G = T[5], T.length === 6 ? (f = Math.sqrt(D * D + I * I), m = Math.sqrt($ * $ + k * k), _ = D || I ? Qr(I, D) * cr : 0, x = k || $ ? Qr(k, $) * cr + _ : 0, x && (m *= Math.abs(Math.cos(x * vo))), n.svg && (h -= C - (C * D + A * k), u -= A - (C * I + A * $))) : (it = T[6], Zt = T[7], P = T[8], ct = T[9], Ut = T[10], J = T[11], h = T[12], u = T[13], d = T[14], R = Qr(it, Ut), g = R * cr, R && (E = Math.cos(-R), M = Math.sin(-R), H = j * E + P * M, V = G * E + ct * M, nt = it * E + Ut * M, P = j * -M + P * E, ct = G * -M + ct * E, Ut = it * -M + Ut * E, J = Zt * -M + J * E, j = H, G = V, it = nt), R = Qr(-k, Ut), p = R * cr, R && (E = Math.cos(-R), M = Math.sin(-R), H = D * E - P * M, V = I * E - ct * M, nt = k * E - Ut * M, J = $ * M + J * E, D = H, I = V, k = nt), R = Qr(I, D), _ = R * cr, R && (E = Math.cos(R), M = Math.sin(R), H = D * E + I * M, V = j * E + G * M, I = I * E - D * M, G = G * E - j * M, D = H, j = V), g && Math.abs(g) + Math.abs(_) > 359.9 && (g = _ = 0, p = 180 - p), f = Ge(Math.sqrt(D * D + I * I + k * k)), m = Ge(Math.sqrt(G * G + it * it)), R = Qr(j, G), x = Math.abs(R) > 2e-4 ? R * cr : 0, y = J ? 1 / (J < 0 ? -J : J) : 0), n.svg && (H = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !U_(Vi(t, ke)), H && t.setAttribute("transform", H))), Math.abs(x) > 90 && Math.abs(x) < 270 && (s ? (f *= -1, x += _ <= 0 ? 180 : -180, _ += _ <= 0 ? 180 : -180) : (m *= -1, x += x <= 0 ? 180 : -180)), e = e || n.uncache, n.x = h - ((n.xPercent = h && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + o, n.y = u - ((n.yPercent = u && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + o, n.z = d + o, n.scaleX = Ge(f), n.scaleY = Ge(m), n.rotation = Ge(_) + a, n.rotationX = Ge(g) + a, n.rotationY = Ge(p) + a, n.skewX = x + a, n.skewY = v + a, n.transformPerspective = y + o, (n.zOrigin = parseFloat(c.split(" ")[2]) || !e && n.zOrigin || 0) && (i[Wn] = Tc(c)), n.xOffset = n.yOffset = 0, n.force3D = si.force3D, n.renderTransform = n.svg ? p1 : D_ ? O_ : f1, n.uncache = 0, n
    },
    Tc = function(t) {
        return (t = t.split(" "))[0] + " " + t[1]
    },
    Dh = function(t, e, n) {
        var i = Mn(e);
        return Ge(parseFloat(e) + parseFloat(js(t, "x", n + "px", i))) + i
    },
    f1 = function(t, e) {
        e.z = "0px",
        e.rotationY = e.rotationX = "0deg",
        e.force3D = 0,
        O_(t, e)
    },
    or = "0deg",
    ea = "0px",
    ar = ") ",
    O_ = function(t, e) {
        var n = e || this,
            i = n.xPercent,
            s = n.yPercent,
            o = n.x,
            a = n.y,
            l = n.z,
            c = n.rotation,
            h = n.rotationY,
            u = n.rotationX,
            d = n.skewX,
            f = n.skewY,
            m = n.scaleX,
            _ = n.scaleY,
            g = n.transformPerspective,
            p = n.force3D,
            x = n.target,
            v = n.zOrigin,
            y = "",
            C = p === "auto" && t && t !== 1 || p === !0;
        if (v && (u !== or || h !== or)) {
            var A = parseFloat(h) * vo,
                T = Math.sin(A),
                R = Math.cos(A),
                E;
            A = parseFloat(u) * vo,
            E = Math.cos(A),
            o = Dh(x, o, T * E * -v),
            a = Dh(x, a, -Math.sin(A) * -v),
            l = Dh(x, l, R * E * -v + v)
        }
        g !== ea && (y += "perspective(" + g + ar),
        (i || s) && (y += "translate(" + i + "%, " + s + "%) "),
        (C || o !== ea || a !== ea || l !== ea) && (y += l !== ea || C ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + ar),
        c !== or && (y += "rotate(" + c + ar),
        h !== or && (y += "rotateY(" + h + ar),
        u !== or && (y += "rotateX(" + u + ar),
        (d !== or || f !== or) && (y += "skew(" + d + ", " + f + ar),
        (m !== 1 || _ !== 1) && (y += "scale(" + m + ", " + _ + ar),
        x.style[ke] = y || "translate(0, 0)"
    },
    p1 = function(t, e) {
        var n = e || this,
            i = n.xPercent,
            s = n.yPercent,
            o = n.x,
            a = n.y,
            l = n.rotation,
            c = n.skewX,
            h = n.skewY,
            u = n.scaleX,
            d = n.scaleY,
            f = n.target,
            m = n.xOrigin,
            _ = n.yOrigin,
            g = n.xOffset,
            p = n.yOffset,
            x = n.forceCSS,
            v = parseFloat(o),
            y = parseFloat(a),
            C,
            A,
            T,
            R,
            E;
        l = parseFloat(l),
        c = parseFloat(c),
        h = parseFloat(h),
        h && (h = parseFloat(h), c += h, l += h),
        l || c ? (l *= vo, c *= vo, C = Math.cos(l) * u, A = Math.sin(l) * u, T = Math.sin(l - c) * -d, R = Math.cos(l - c) * d, c && (h *= vo, E = Math.tan(c - h), E = Math.sqrt(1 + E * E), T *= E, R *= E, h && (E = Math.tan(h), E = Math.sqrt(1 + E * E), C *= E, A *= E)), C = Ge(C), A = Ge(A), T = Ge(T), R = Ge(R)) : (C = u, R = d, A = T = 0),
        (v && !~(o + "").indexOf("px") || y && !~(a + "").indexOf("px")) && (v = js(f, "x", o, "px"), y = js(f, "y", a, "px")),
        (m || _ || g || p) && (v = Ge(v + m - (m * C + _ * T) + g), y = Ge(y + _ - (m * A + _ * R) + p)),
        (i || s) && (E = f.getBBox(), v = Ge(v + i / 100 * E.width), y = Ge(y + s / 100 * E.height)),
        E = "matrix(" + C + "," + A + "," + T + "," + R + "," + v + "," + y + ")",
        f.setAttribute("transform", E),
        x && (f.style[ke] = E)
    },
    m1 = function(t, e, n, i, s) {
        var o = 360,
            a = ln(s),
            l = parseFloat(s) * (a && ~s.indexOf("rad") ? cr : 1),
            c = l - i,
            h = i + c + "deg",
            u,
            d;
        return a && (u = s.split("_")[1], u === "short" && (c %= o, c !== c % (o / 2) && (c += c < 0 ? o : -o)), u === "cw" && c < 0 ? c = (c + o * om) % o - ~~(c / o) * o : u === "ccw" && c > 0 && (c = (c - o * om) % o - ~~(c / o) * o)), t._pt = d = new Gn(t._pt, e, n, i, c, Jw), d.e = h, d.u = "deg", t._props.push(n), d
    },
    dm = function(t, e) {
        for (var n in e)
            t[n] = e[n];
        return t
    },
    g1 = function(t, e, n) {
        var i = dm({}, n._gsap),
            s = "perspective,force3D,transformOrigin,svgOrigin",
            o = n.style,
            a,
            l,
            c,
            h,
            u,
            d,
            f,
            m;
        i.svg ? (c = n.getAttribute("transform"), n.setAttribute("transform", ""), o[ke] = e, a = Va(n, 1), br(n, ke), n.setAttribute("transform", c)) : (c = getComputedStyle(n)[ke], o[ke] = e, a = Va(n, 1), o[ke] = c);
        for (l in ys)
            c = i[l],
            h = a[l],
            c !== h && s.indexOf(l) < 0 && (f = Mn(c), m = Mn(h), u = f !== m ? js(n, l, c, m) : parseFloat(c), d = parseFloat(h), t._pt = new Gn(t._pt, a, l, u, d - u, Wu), t._pt.u = m || 0, t._props.push(l));
        dm(a, i)
    };
Vn("padding,margin,Width,Radius", function(r, t) {
    var e = "Top",
        n = "Right",
        i = "Bottom",
        s = "Left",
        o = (t < 3 ? [e, n, i, s] : [e + s, e + n, i + n, i + s]).map(function(a) {
            return t < 2 ? r + a : "border" + a + r
        });
    Sc[t > 1 ? "border" + r : r] = function(a, l, c, h, u) {
        var d,
            f;
        if (arguments.length < 4)
            return d = o.map(function(m) {
                return as(a, m, c)
            }), f = d.join(" "), f.split(d[0]).length === 5 ? d[0] : f;
        d = (h + "").split(" "),
        f = {},
        o.forEach(function(m, _) {
            return f[m] = d[_] = d[_] || d[(_ - 1) / 2 | 0]
        }),
        a.init(l, f, u)
    }
});
var z_ = {
    name: "css",
    register: Yu,
    targetTest: function(t) {
        return t.style && t.nodeType
    },
    init: function(t, e, n, i, s) {
        var o = this._props,
            a = t.style,
            l = n.vars.startAt,
            c,
            h,
            u,
            d,
            f,
            m,
            _,
            g,
            p,
            x,
            v,
            y,
            C,
            A,
            T,
            R;
        $d || Yu(),
        this.styles = this.styles || L_(t),
        R = this.styles.props,
        this.tween = n;
        for (_ in e)
            if (_ !== "autoRound" && (h = e[_], !(Qn[_] && y_(_, e, n, i, t, s)))) {
                if (f = typeof h, m = Sc[_], f === "function" && (h = h.call(n, i, t, s), f = typeof h), f === "string" && ~h.indexOf("random(") && (h = za(h)), m)
                    m(this, t, _, h, n) && (T = 1);
                else if (_.substr(0, 2) === "--")
                    c = (getComputedStyle(t).getPropertyValue(_) + "").trim(),
                    h += "",
                    $s.lastIndex = 0,
                    $s.test(c) || (g = Mn(c), p = Mn(h)),
                    p ? g !== p && (c = js(t, _, c, p) + p) : g && (h += g),
                    this.add(a, "setProperty", c, h, i, s, 0, 0, _),
                    o.push(_),
                    R.push(_, 0, a[_]);
                else if (f !== "undefined") {
                    if (l && _ in l ? (c = typeof l[_] == "function" ? l[_].call(n, i, t, s) : l[_], ln(c) && ~c.indexOf("random(") && (c = za(c)), Mn(c + "") || c === "auto" || (c += si.units[_] || Mn(as(t, _)) || ""), (c + "").charAt(1) === "=" && (c = as(t, _))) : c = as(t, _), d = parseFloat(c), x = f === "string" && h.charAt(1) === "=" && h.substr(0, 2), x && (h = h.substr(2)), u = parseFloat(h), _ in Bi && (_ === "autoAlpha" && (d === 1 && as(t, "visibility") === "hidden" && u && (d = 0), R.push("visibility", 0, a.visibility), Vs(this, a, "visibility", d ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), _ !== "scale" && _ !== "transform" && (_ = Bi[_], ~_.indexOf(",") && (_ = _.split(",")[0]))), v = _ in ys, v) {
                        if (this.styles.save(_), y || (C = t._gsap, C.renderTransform && !e.parseTransform || Va(t, e.parseTransform), A = e.smoothOrigin !== !1 && C.smooth, y = this._pt = new Gn(this._pt, a, ke, 0, 1, C.renderTransform, C, 0, -1), y.dep = 1), _ === "scale")
                            this._pt = new Gn(this._pt, C, "scaleY", C.scaleY, (x ? _o(C.scaleY, x + u) : u) - C.scaleY || 0, Wu),
                            this._pt.u = 0,
                            o.push("scaleY", _),
                            _ += "X";
                        else if (_ === "transformOrigin") {
                            R.push(Wn, 0, a[Wn]),
                            h = u1(h),
                            C.svg ? $u(t, h, 0, A, 0, this) : (p = parseFloat(h.split(" ")[2]) || 0, p !== C.zOrigin && Vs(this, C, "zOrigin", C.zOrigin, p), Vs(this, a, _, Tc(c), Tc(h)));
                            continue
                        } else if (_ === "svgOrigin") {
                            $u(t, h, 1, A, 0, this);
                            continue
                        } else if (_ in F_) {
                            m1(this, C, _, d, x ? _o(d, x + h) : h);
                            continue
                        } else if (_ === "smoothOrigin") {
                            Vs(this, C, "smooth", C.smooth, h);
                            continue
                        } else if (_ === "force3D") {
                            C[_] = h;
                            continue
                        } else if (_ === "transform") {
                            g1(this, h, t);
                            continue
                        }
                    } else
                        _ in a || (_ = zo(_) || _);
                    if (v || (u || u === 0) && (d || d === 0) && !Zw.test(h) && _ in a)
                        g = (c + "").substr((d + "").length),
                        u || (u = 0),
                        p = Mn(h) || (_ in si.units ? si.units[_] : g),
                        g !== p && (d = js(t, _, c, p)),
                        this._pt = new Gn(this._pt, v ? C : a, _, d, (x ? _o(d, x + u) : u) - d, !v && (p === "px" || _ === "zIndex") && e.autoRound !== !1 ? t1 : Wu),
                        this._pt.u = p || 0,
                        g !== p && p !== "%" && (this._pt.b = c, this._pt.r = Qw);
                    else if (_ in a)
                        h1.call(this, t, _, c, x ? x + h : h);
                    else if (_ in t)
                        this.add(t, _, c || t[_], x ? x + h : h, i, s);
                    else if (_ !== "parseTransform") {
                        zd(_, h);
                        continue
                    }
                    v || (_ in a ? R.push(_, 0, a[_]) : R.push(_, 1, c || t[_])),
                    o.push(_)
                }
            }
        T && w_(this)
    },
    render: function(t, e) {
        if (e.tween._time || !qd())
            for (var n = e._pt; n;)
                n.r(t, n.d),
                n = n._next;
        else
            e.styles.revert()
    },
    get: as,
    aliases: Bi,
    getSetter: function(t, e, n) {
        var i = Bi[e];
        return i && i.indexOf(",") < 0 && (e = i), e in ys && e !== Wn && (t._gsap.x || as(t, "x")) ? n && rm === n ? e === "scale" ? s1 : i1 : (rm = n || {}) && (e === "scale" ? r1 : o1) : t.style && !Fd(t.style[e]) ? e1 : ~e.indexOf("-") ? n1 : Xd(t, e)
    },
    core: {
        _removeProperty: br,
        _getMatrix: jd
    }
};
Xn.utils.checkPrefix = zo;
Xn.core.getStyleSaver = L_;
(function(r, t, e, n) {
    var i = Vn(r + "," + t + "," + e, function(s) {
        ys[s] = 1
    });
    Vn(t, function(s) {
        si.units[s] = "deg",
        F_[s] = 1
    }),
    Bi[i[13]] = r + "," + t,
    Vn(n, function(s) {
        var o = s.split(":");
        Bi[o[1]] = i[o[0]]
    })
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Vn("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(r) {
    si.units[r] = "px"
});
Xn.registerPlugin(z_);
var on = Xn.registerPlugin(z_) || Xn;
on.core.Tween;
const _1 = "/build/assets/bubble-DZrCbWwK.glb",
    x1 = "/build/assets/matcap-18-BhSJAhdI.webp",
    to = {
        NONE: "none",
        FRAME: "frame",
        RENDER: "render",
        OBJECT: "object"
    },
    Zd = ["x", "y", "z", "w"],
    gn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let fm = 1234567;
const B_ = Math.PI / 180,
    k_ = 180 / Math.PI;
function v1() {
    const r = Math.random() * 4294967295 | 0,
        t = Math.random() * 4294967295 | 0,
        e = Math.random() * 4294967295 | 0,
        n = Math.random() * 4294967295 | 0;
    return (gn[r & 255] + gn[r >> 8 & 255] + gn[r >> 16 & 255] + gn[r >> 24 & 255] + "-" + gn[t & 255] + gn[t >> 8 & 255] + "-" + gn[t >> 16 & 15 | 64] + gn[t >> 24 & 255] + "-" + gn[e & 63 | 128] + gn[e >> 8 & 255] + "-" + gn[e >> 16 & 255] + gn[e >> 24 & 255] + gn[n & 255] + gn[n >> 8 & 255] + gn[n >> 16 & 255] + gn[n >> 24 & 255]).toLowerCase()
}
function ls(r, t, e) {
    return Math.max(t, Math.min(e, r))
}
function Jd(r, t) {
    return (r % t + t) % t
}
function y1(r, t, e, n, i) {
    return n + (r - t) * (i - n) / (e - t)
}
function M1(r, t, e) {
    return r !== t ? (e - r) / (t - r) : 0
}
function ya(r, t, e) {
    return (1 - e) * r + e * t
}
function S1(r, t, e, n) {
    return ya(r, t, 1 - Math.exp(-e * n))
}
function T1(r, t=1) {
    return t - Math.abs(Jd(r, t * 2) - t)
}
function E1(r, t, e) {
    return r <= t ? 0 : r >= e ? 1 : (r = (r - t) / (e - t), r * r * (3 - 2 * r))
}
function b1(r, t, e) {
    return r <= t ? 0 : r >= e ? 1 : (r = (r - t) / (e - t), r * r * r * (r * (r * 6 - 15) + 10))
}
function w1(r, t) {
    return r + Math.floor(Math.random() * (t - r + 1))
}
function A1(r, t) {
    return r + Math.random() * (t - r)
}
function C1(r) {
    return r * (.5 - Math.random())
}
function R1(r) {
    r !== void 0 && (fm = r);
    let t = fm += 1831565813;
    return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296
}
function P1(r) {
    return r * B_
}
function L1(r) {
    return r * k_
}
function D1(r) {
    return (r & r - 1) === 0 && r !== 0
}
function N1(r) {
    return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
}
function I1(r) {
    return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
}
function F1(r, t, e, n, i) {
    const s = Math.cos,
        o = Math.sin,
        a = s(e / 2),
        l = o(e / 2),
        c = s((t + n) / 2),
        h = o((t + n) / 2),
        u = s((t - n) / 2),
        d = o((t - n) / 2),
        f = s((n - t) / 2),
        m = o((n - t) / 2);
    switch (i) {
    case "XYX":
        r.set(a * h, l * u, l * d, a * c);
        break;
    case "YZY":
        r.set(l * d, a * h, l * u, a * c);
        break;
    case "ZXZ":
        r.set(l * u, l * d, a * h, a * c);
        break;
    case "XZX":
        r.set(a * h, l * m, l * f, a * c);
        break;
    case "YXY":
        r.set(l * f, a * h, l * m, a * c);
        break;
    case "ZYZ":
        r.set(l * m, l * f, a * h, a * c);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}
function U1(r, t) {
    switch (t.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return r / 4294967295;
    case Uint16Array:
        return r / 65535;
    case Uint8Array:
        return r / 255;
    case Int32Array:
        return Math.max(r / 2147483647, -1);
    case Int16Array:
        return Math.max(r / 32767, -1);
    case Int8Array:
        return Math.max(r / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function O1(r, t) {
    switch (t.constructor) {
    case Float32Array:
        return r;
    case Uint32Array:
        return Math.round(r * 4294967295);
    case Uint16Array:
        return Math.round(r * 65535);
    case Uint8Array:
        return Math.round(r * 255);
    case Int32Array:
        return Math.round(r * 2147483647);
    case Int16Array:
        return Math.round(r * 32767);
    case Int8Array:
        return Math.round(r * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const z1 = {
        DEG2RAD: B_,
        RAD2DEG: k_,
        generateUUID: v1,
        clamp: ls,
        euclideanModulo: Jd,
        mapLinear: y1,
        inverseLerp: M1,
        lerp: ya,
        damp: S1,
        pingpong: T1,
        smoothstep: E1,
        smootherstep: b1,
        randInt: w1,
        randFloat: A1,
        randFloatSpread: C1,
        seededRandom: R1,
        degToRad: P1,
        radToDeg: L1,
        isPowerOfTwo: D1,
        ceilPowerOfTwo: N1,
        floorPowerOfTwo: I1,
        setQuaternionFromProperEuler: F1,
        normalize: O1,
        denormalize: U1
    },
    B1 = "",
    Ns = "srgb",
    Qd = "srgb-linear",
    k1 = "display-p3",
    H_ = "display-p3-linear",
    qu = "linear",
    pm = "srgb",
    mm = "rec709",
    gm = "p3",
    Pl = 2e3,
    _m = 2001;
class Wo {
    constructor(t, e, n, i, s, o, a, l, c)
    {
        Wo.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        t !== void 0 && this.set(t, e, n, i, s, o, a, l, c)
    }
    set(t, e, n, i, s, o, a, l, c)
    {
        const h = this.elements;
        return h[0] = t, h[1] = i, h[2] = a, h[3] = e, h[4] = s, h[5] = l, h[6] = n, h[7] = o, h[8] = c, this
    }
    identity()
    {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(t)
    {
        const e = this.elements,
            n = t.elements;
        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
    }
    extractBasis(t, e, n)
    {
        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(t)
    {
        const e = t.elements;
        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    }
    multiply(t)
    {
        return this.multiplyMatrices(this, t)
    }
    premultiply(t)
    {
        return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, e)
    {
        const n = t.elements,
            i = e.elements,
            s = this.elements,
            o = n[0],
            a = n[3],
            l = n[6],
            c = n[1],
            h = n[4],
            u = n[7],
            d = n[2],
            f = n[5],
            m = n[8],
            _ = i[0],
            g = i[3],
            p = i[6],
            x = i[1],
            v = i[4],
            y = i[7],
            C = i[2],
            A = i[5],
            T = i[8];
        return s[0] = o * _ + a * x + l * C, s[3] = o * g + a * v + l * A, s[6] = o * p + a * y + l * T, s[1] = c * _ + h * x + u * C, s[4] = c * g + h * v + u * A, s[7] = c * p + h * y + u * T, s[2] = d * _ + f * x + m * C, s[5] = d * g + f * v + m * A, s[8] = d * p + f * y + m * T, this
    }
    multiplyScalar(t)
    {
        const e = this.elements;
        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
    }
    determinant()
    {
        const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            s = t[3],
            o = t[4],
            a = t[5],
            l = t[6],
            c = t[7],
            h = t[8];
        return e * o * h - e * a * c - n * s * h + n * a * l + i * s * c - i * o * l
    }
    invert()
    {
        const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            s = t[3],
            o = t[4],
            a = t[5],
            l = t[6],
            c = t[7],
            h = t[8],
            u = h * o - a * c,
            d = a * l - h * s,
            f = c * s - o * l,
            m = e * u + n * d + i * f;
        if (m === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const _ = 1 / m;
        return t[0] = u * _, t[1] = (i * c - h * n) * _, t[2] = (a * n - i * o) * _, t[3] = d * _, t[4] = (h * e - i * l) * _, t[5] = (i * s - a * e) * _, t[6] = f * _, t[7] = (n * l - c * e) * _, t[8] = (o * e - n * s) * _, this
    }
    transpose()
    {
        let t;
        const e = this.elements;
        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
    }
    getNormalMatrix(t)
    {
        return this.setFromMatrix4(t).invert().transpose()
    }
    transposeIntoArray(t)
    {
        const e = this.elements;
        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
    }
    setUvTransform(t, e, n, i, s, o, a)
    {
        const l = Math.cos(s),
            c = Math.sin(s);
        return this.set(n * l, n * c, -n * (l * o + c * a) + o + t, -i * c, i * l, -i * (-c * o + l * a) + a + e, 0, 0, 1), this
    }
    scale(t, e)
    {
        return this.premultiply(Nh.makeScale(t, e)), this
    }
    rotate(t)
    {
        return this.premultiply(Nh.makeRotation(-t)), this
    }
    translate(t, e)
    {
        return this.premultiply(Nh.makeTranslation(t, e)), this
    }
    makeTranslation(t, e)
    {
        return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
    }
    makeRotation(t)
    {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
    }
    makeScale(t, e)
    {
        return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
    }
    equals(t)
    {
        const e = this.elements,
            n = t.elements;
        for (let i = 0; i < 9; i++)
            if (e[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(t, e=0)
    {
        for (let n = 0; n < 9; n++)
            this.elements[n] = t[n + e];
        return this
    }
    toArray(t=[], e=0)
    {
        const n = this.elements;
        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
    }
    clone()
    {
        return new this.constructor().fromArray(this.elements)
    }
}
const Nh = new Wo,
    xm = new Wo().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
    vm = new Wo().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
    na = {
        [Qd]: {
            transfer: qu,
            primaries: mm,
            luminanceCoefficients: [.2126, .7152, .0722],
            toReference: r => r,
            fromReference: r => r
        },
        [Ns]: {
            transfer: pm,
            primaries: mm,
            luminanceCoefficients: [.2126, .7152, .0722],
            toReference: r => r.convertSRGBToLinear(),
            fromReference: r => r.convertLinearToSRGB()
        },
        [H_]: {
            transfer: qu,
            primaries: gm,
            luminanceCoefficients: [.2289, .6917, .0793],
            toReference: r => r.applyMatrix3(vm),
            fromReference: r => r.applyMatrix3(xm)
        },
        [k1]: {
            transfer: pm,
            primaries: gm,
            luminanceCoefficients: [.2289, .6917, .0793],
            toReference: r => r.convertSRGBToLinear().applyMatrix3(vm),
            fromReference: r => r.applyMatrix3(xm).convertLinearToSRGB()
        }
    },
    H1 = new Set([Qd, H_]),
    Si = {
        enabled: !0,
        _workingColorSpace: Qd,
        get workingColorSpace() {
            return this._workingColorSpace
        },
        set workingColorSpace(r) {
            if (!H1.has(r))
                throw new Error(`Unsupported working color space, "${r}".`);
            this._workingColorSpace = r
        },
        convert: function(r, t, e) {
            if (this.enabled === !1 || t === e || !t || !e)
                return r;
            const n = na[t].toReference,
                i = na[e].fromReference;
            return i(n(r))
        },
        fromWorkingColorSpace: function(r, t) {
            return this.convert(r, this._workingColorSpace, t)
        },
        toWorkingColorSpace: function(r, t) {
            return this.convert(r, t, this._workingColorSpace)
        },
        getPrimaries: function(r) {
            return na[r].primaries
        },
        getTransfer: function(r) {
            return r === B1 ? qu : na[r].transfer
        },
        getLuminanceCoefficients: function(r, t=this._workingColorSpace) {
            return r.fromArray(na[t].luminanceCoefficients)
        }
    };
function Ih(r) {
    return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
}
function Fh(r) {
    return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
}
const V_ = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    Ls = {
        h: 0,
        s: 0,
        l: 0
    },
    Ll = {
        h: 0,
        s: 0,
        l: 0
    };
function Uh(r, t, e) {
    return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? r + (t - r) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? r + (t - r) * 6 * (2 / 3 - e) : r
}
class tf {
    constructor(t, e, n)
    {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n)
    }
    set(t, e, n)
    {
        if (e === void 0 && n === void 0) {
            const i = t;
            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
        } else
            this.setRGB(t, e, n);
        return this
    }
    setScalar(t)
    {
        return this.r = t, this.g = t, this.b = t, this
    }
    setHex(t, e=Ns)
    {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, Si.toWorkingColorSpace(this, e), this
    }
    setRGB(t, e, n, i=Si.workingColorSpace)
    {
        return this.r = t, this.g = e, this.b = n, Si.toWorkingColorSpace(this, i), this
    }
    setHSL(t, e, n, i=Si.workingColorSpace)
    {
        if (t = Jd(t, 1), e = ls(e, 0, 1), n = ls(n, 0, 1), e === 0)
            this.r = this.g = this.b = n;
        else {
            const s = n <= .5 ? n * (1 + e) : n + e - n * e,
                o = 2 * n - s;
            this.r = Uh(o, s, t + 1 / 3),
            this.g = Uh(o, s, t),
            this.b = Uh(o, s, t - 1 / 3)
        }
        return Si.toWorkingColorSpace(this, i), this
    }
    setStyle(t, e=Ns)
    {
        function n(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
            let s;
            const o = i[1],
                a = i[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, e);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, e);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, e);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + t)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const s = i[1],
                o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, e);
            if (o === 6)
                return this.setHex(parseInt(s, 16), e);
            console.warn("THREE.Color: Invalid hex color " + t)
        } else if (t && t.length > 0)
            return this.setColorName(t, e);
        return this
    }
    setColorName(t, e=Ns)
    {
        const n = V_[t.toLowerCase()];
        return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
    }
    clone()
    {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(t)
    {
        return this.r = t.r, this.g = t.g, this.b = t.b, this
    }
    copySRGBToLinear(t)
    {
        return this.r = Ih(t.r), this.g = Ih(t.g), this.b = Ih(t.b), this
    }
    copyLinearToSRGB(t)
    {
        return this.r = Fh(t.r), this.g = Fh(t.g), this.b = Fh(t.b), this
    }
    convertSRGBToLinear()
    {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB()
    {
        return this.copyLinearToSRGB(this), this
    }
    getHex(t=Ns)
    {
        return Si.fromWorkingColorSpace(_n.copy(this), t), Math.round(ls(_n.r * 255, 0, 255)) * 65536 + Math.round(ls(_n.g * 255, 0, 255)) * 256 + Math.round(ls(_n.b * 255, 0, 255))
    }
    getHexString(t=Ns)
    {
        return ("000000" + this.getHex(t).toString(16)).slice(-6)
    }
    getHSL(t, e=Si.workingColorSpace)
    {
        Si.fromWorkingColorSpace(_n.copy(this), e);
        const n = _n.r,
            i = _n.g,
            s = _n.b,
            o = Math.max(n, i, s),
            a = Math.min(n, i, s);
        let l,
            c;
        const h = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const u = o - a;
            switch (c = h <= .5 ? u / (o + a) : u / (2 - o - a), o) {
            case n:
                l = (i - s) / u + (i < s ? 6 : 0);
                break;
            case i:
                l = (s - n) / u + 2;
                break;
            case s:
                l = (n - i) / u + 4;
                break
            }
            l /= 6
        }
        return t.h = l, t.s = c, t.l = h, t
    }
    getRGB(t, e=Si.workingColorSpace)
    {
        return Si.fromWorkingColorSpace(_n.copy(this), e), t.r = _n.r, t.g = _n.g, t.b = _n.b, t
    }
    getStyle(t=Ns)
    {
        Si.fromWorkingColorSpace(_n.copy(this), t);
        const e = _n.r,
            n = _n.g,
            i = _n.b;
        return t !== Ns ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
    }
    offsetHSL(t, e, n)
    {
        return this.getHSL(Ls), this.setHSL(Ls.h + t, Ls.s + e, Ls.l + n)
    }
    add(t)
    {
        return this.r += t.r, this.g += t.g, this.b += t.b, this
    }
    addColors(t, e)
    {
        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
    }
    addScalar(t)
    {
        return this.r += t, this.g += t, this.b += t, this
    }
    sub(t)
    {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
    }
    multiply(t)
    {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
    }
    multiplyScalar(t)
    {
        return this.r *= t, this.g *= t, this.b *= t, this
    }
    lerp(t, e)
    {
        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
    }
    lerpColors(t, e, n)
    {
        return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
    }
    lerpHSL(t, e)
    {
        this.getHSL(Ls),
        t.getHSL(Ll);
        const n = ya(Ls.h, Ll.h, e),
            i = ya(Ls.s, Ll.s, e),
            s = ya(Ls.l, Ll.l, e);
        return this.setHSL(n, i, s), this
    }
    setFromVector3(t)
    {
        return this.r = t.x, this.g = t.y, this.b = t.z, this
    }
    applyMatrix3(t)
    {
        const e = this.r,
            n = this.g,
            i = this.b,
            s = t.elements;
        return this.r = s[0] * e + s[3] * n + s[6] * i, this.g = s[1] * e + s[4] * n + s[7] * i, this.b = s[2] * e + s[5] * n + s[8] * i, this
    }
    equals(t)
    {
        return t.r === this.r && t.g === this.g && t.b === this.b
    }
    fromArray(t, e=0)
    {
        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
    }
    toArray(t=[], e=0)
    {
        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
    }
    fromBufferAttribute(t, e)
    {
        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
    }
    toJSON()
    {
        return this.getHex()
    }
    *[Symbol.iterator]()
    {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const _n = new tf;
tf.NAMES = V_;
class V1 {
    constructor(t=0, e=0, n=0, i=1)
    {
        this.isQuaternion = !0,
        this._x = t,
        this._y = e,
        this._z = n,
        this._w = i
    }
    static slerpFlat(t, e, n, i, s, o, a)
    {
        let l = n[i + 0],
            c = n[i + 1],
            h = n[i + 2],
            u = n[i + 3];
        const d = s[o + 0],
            f = s[o + 1],
            m = s[o + 2],
            _ = s[o + 3];
        if (a === 0) {
            t[e + 0] = l,
            t[e + 1] = c,
            t[e + 2] = h,
            t[e + 3] = u;
            return
        }
        if (a === 1) {
            t[e + 0] = d,
            t[e + 1] = f,
            t[e + 2] = m,
            t[e + 3] = _;
            return
        }
        if (u !== _ || l !== d || c !== f || h !== m) {
            let g = 1 - a;
            const p = l * d + c * f + h * m + u * _,
                x = p >= 0 ? 1 : -1,
                v = 1 - p * p;
            if (v > Number.EPSILON) {
                const C = Math.sqrt(v),
                    A = Math.atan2(C, p * x);
                g = Math.sin(g * A) / C,
                a = Math.sin(a * A) / C
            }
            const y = a * x;
            if (l = l * g + d * y, c = c * g + f * y, h = h * g + m * y, u = u * g + _ * y, g === 1 - a) {
                const C = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
                l *= C,
                c *= C,
                h *= C,
                u *= C
            }
        }
        t[e] = l,
        t[e + 1] = c,
        t[e + 2] = h,
        t[e + 3] = u
    }
    static multiplyQuaternionsFlat(t, e, n, i, s, o)
    {
        const a = n[i],
            l = n[i + 1],
            c = n[i + 2],
            h = n[i + 3],
            u = s[o],
            d = s[o + 1],
            f = s[o + 2],
            m = s[o + 3];
        return t[e] = a * m + h * u + l * f - c * d, t[e + 1] = l * m + h * d + c * u - a * f, t[e + 2] = c * m + h * f + a * d - l * u, t[e + 3] = h * m - a * u - l * d - c * f, t
    }
    get x()
    {
        return this._x
    }
    set x(t)
    {
        this._x = t,
        this._onChangeCallback()
    }
    get y()
    {
        return this._y
    }
    set y(t)
    {
        this._y = t,
        this._onChangeCallback()
    }
    get z()
    {
        return this._z
    }
    set z(t)
    {
        this._z = t,
        this._onChangeCallback()
    }
    get w()
    {
        return this._w
    }
    set w(t)
    {
        this._w = t,
        this._onChangeCallback()
    }
    set(t, e, n, i)
    {
        return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
    }
    clone()
    {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(t)
    {
        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
    }
    setFromEuler(t, e=!0)
    {
        const n = t._x,
            i = t._y,
            s = t._z,
            o = t._order,
            a = Math.cos,
            l = Math.sin,
            c = a(n / 2),
            h = a(i / 2),
            u = a(s / 2),
            d = l(n / 2),
            f = l(i / 2),
            m = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = d * h * u + c * f * m,
            this._y = c * f * u - d * h * m,
            this._z = c * h * m + d * f * u,
            this._w = c * h * u - d * f * m;
            break;
        case "YXZ":
            this._x = d * h * u + c * f * m,
            this._y = c * f * u - d * h * m,
            this._z = c * h * m - d * f * u,
            this._w = c * h * u + d * f * m;
            break;
        case "ZXY":
            this._x = d * h * u - c * f * m,
            this._y = c * f * u + d * h * m,
            this._z = c * h * m + d * f * u,
            this._w = c * h * u - d * f * m;
            break;
        case "ZYX":
            this._x = d * h * u - c * f * m,
            this._y = c * f * u + d * h * m,
            this._z = c * h * m - d * f * u,
            this._w = c * h * u + d * f * m;
            break;
        case "YZX":
            this._x = d * h * u + c * f * m,
            this._y = c * f * u + d * h * m,
            this._z = c * h * m - d * f * u,
            this._w = c * h * u - d * f * m;
            break;
        case "XZY":
            this._x = d * h * u - c * f * m,
            this._y = c * f * u - d * h * m,
            this._z = c * h * m + d * f * u,
            this._w = c * h * u + d * f * m;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return e === !0 && this._onChangeCallback(), this
    }
    setFromAxisAngle(t, e)
    {
        const n = e / 2,
            i = Math.sin(n);
        return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
    }
    setFromRotationMatrix(t)
    {
        const e = t.elements,
            n = e[0],
            i = e[4],
            s = e[8],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[2],
            h = e[6],
            u = e[10],
            d = n + a + u;
        if (d > 0) {
            const f = .5 / Math.sqrt(d + 1);
            this._w = .25 / f,
            this._x = (h - l) * f,
            this._y = (s - c) * f,
            this._z = (o - i) * f
        } else if (n > a && n > u) {
            const f = 2 * Math.sqrt(1 + n - a - u);
            this._w = (h - l) / f,
            this._x = .25 * f,
            this._y = (i + o) / f,
            this._z = (s + c) / f
        } else if (a > u) {
            const f = 2 * Math.sqrt(1 + a - n - u);
            this._w = (s - c) / f,
            this._x = (i + o) / f,
            this._y = .25 * f,
            this._z = (l + h) / f
        } else {
            const f = 2 * Math.sqrt(1 + u - n - a);
            this._w = (o - i) / f,
            this._x = (s + c) / f,
            this._y = (l + h) / f,
            this._z = .25 * f
        }
        return this._onChangeCallback(), this
    }
    setFromUnitVectors(t, e)
    {
        let n = t.dot(e) + 1;
        return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
    }
    angleTo(t)
    {
        return 2 * Math.acos(Math.abs(ls(this.dot(t), -1, 1)))
    }
    rotateTowards(t, e)
    {
        const n = this.angleTo(t);
        if (n === 0)
            return this;
        const i = Math.min(1, e / n);
        return this.slerp(t, i), this
    }
    identity()
    {
        return this.set(0, 0, 0, 1)
    }
    invert()
    {
        return this.conjugate()
    }
    conjugate()
    {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }
    dot(t)
    {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
    }
    lengthSq()
    {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length()
    {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize()
    {
        let t = this.length();
        return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
    }
    multiply(t)
    {
        return this.multiplyQuaternions(this, t)
    }
    premultiply(t)
    {
        return this.multiplyQuaternions(t, this)
    }
    multiplyQuaternions(t, e)
    {
        const n = t._x,
            i = t._y,
            s = t._z,
            o = t._w,
            a = e._x,
            l = e._y,
            c = e._z,
            h = e._w;
        return this._x = n * h + o * a + i * c - s * l, this._y = i * h + o * l + s * a - n * c, this._z = s * h + o * c + n * l - i * a, this._w = o * h - n * a - i * l - s * c, this._onChangeCallback(), this
    }
    slerp(t, e)
    {
        if (e === 0)
            return this;
        if (e === 1)
            return this.copy(t);
        const n = this._x,
            i = this._y,
            s = this._z,
            o = this._w;
        let a = o * t._w + n * t._x + i * t._y + s * t._z;
        if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1)
            return this._w = o, this._x = n, this._y = i, this._z = s, this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const f = 1 - e;
            return this._w = f * o + e * this._w, this._x = f * n + e * this._x, this._y = f * i + e * this._y, this._z = f * s + e * this._z, this.normalize(), this
        }
        const c = Math.sqrt(l),
            h = Math.atan2(c, a),
            u = Math.sin((1 - e) * h) / c,
            d = Math.sin(e * h) / c;
        return this._w = o * u + this._w * d, this._x = n * u + this._x * d, this._y = i * u + this._y * d, this._z = s * u + this._z * d, this._onChangeCallback(), this
    }
    slerpQuaternions(t, e, n)
    {
        return this.copy(t).slerp(e, n)
    }
    random()
    {
        const t = 2 * Math.PI * Math.random(),
            e = 2 * Math.PI * Math.random(),
            n = Math.random(),
            i = Math.sqrt(1 - n),
            s = Math.sqrt(n);
        return this.set(i * Math.sin(t), i * Math.cos(t), s * Math.sin(e), s * Math.cos(e))
    }
    equals(t)
    {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
    }
    fromArray(t, e=0)
    {
        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
    }
    toArray(t=[], e=0)
    {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
    }
    fromBufferAttribute(t, e)
    {
        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this
    }
    toJSON()
    {
        return this.toArray()
    }
    _onChange(t)
    {
        return this._onChangeCallback = t, this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]()
    {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class ji {
    constructor(t=0, e=0, n=0)
    {
        ji.prototype.isVector3 = !0,
        this.x = t,
        this.y = e,
        this.z = n
    }
    set(t, e, n)
    {
        return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this
    }
    setScalar(t)
    {
        return this.x = t, this.y = t, this.z = t, this
    }
    setX(t)
    {
        return this.x = t, this
    }
    setY(t)
    {
        return this.y = t, this
    }
    setZ(t)
    {
        return this.z = t, this
    }
    setComponent(t, e)
    {
        switch (t) {
        case 0:
            this.x = e;
            break;
        case 1:
            this.y = e;
            break;
        case 2:
            this.z = e;
            break;
        default:
            throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t)
    {
        switch (t) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + t)
        }
    }
    clone()
    {
        return new this.constructor(this.x, this.y, this.z)
    }
    copy(t)
    {
        return this.x = t.x, this.y = t.y, this.z = t.z, this
    }
    add(t)
    {
        return this.x += t.x, this.y += t.y, this.z += t.z, this
    }
    addScalar(t)
    {
        return this.x += t, this.y += t, this.z += t, this
    }
    addVectors(t, e)
    {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
    }
    addScaledVector(t, e)
    {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
    }
    sub(t)
    {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
    }
    subScalar(t)
    {
        return this.x -= t, this.y -= t, this.z -= t, this
    }
    subVectors(t, e)
    {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
    }
    multiply(t)
    {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
    }
    multiplyScalar(t)
    {
        return this.x *= t, this.y *= t, this.z *= t, this
    }
    multiplyVectors(t, e)
    {
        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
    }
    applyEuler(t)
    {
        return this.applyQuaternion(ym.setFromEuler(t))
    }
    applyAxisAngle(t, e)
    {
        return this.applyQuaternion(ym.setFromAxisAngle(t, e))
    }
    applyMatrix3(t)
    {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = t.elements;
        return this.x = s[0] * e + s[3] * n + s[6] * i, this.y = s[1] * e + s[4] * n + s[7] * i, this.z = s[2] * e + s[5] * n + s[8] * i, this
    }
    applyNormalMatrix(t)
    {
        return this.applyMatrix3(t).normalize()
    }
    applyMatrix4(t)
    {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = t.elements,
            o = 1 / (s[3] * e + s[7] * n + s[11] * i + s[15]);
        return this.x = (s[0] * e + s[4] * n + s[8] * i + s[12]) * o, this.y = (s[1] * e + s[5] * n + s[9] * i + s[13]) * o, this.z = (s[2] * e + s[6] * n + s[10] * i + s[14]) * o, this
    }
    applyQuaternion(t)
    {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = t.x,
            o = t.y,
            a = t.z,
            l = t.w,
            c = 2 * (o * i - a * n),
            h = 2 * (a * e - s * i),
            u = 2 * (s * n - o * e);
        return this.x = e + l * c + o * u - a * h, this.y = n + l * h + a * c - s * u, this.z = i + l * u + s * h - o * c, this
    }
    project(t)
    {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
    }
    unproject(t)
    {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
    }
    transformDirection(t)
    {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = t.elements;
        return this.x = s[0] * e + s[4] * n + s[8] * i, this.y = s[1] * e + s[5] * n + s[9] * i, this.z = s[2] * e + s[6] * n + s[10] * i, this.normalize()
    }
    divide(t)
    {
        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
    }
    divideScalar(t)
    {
        return this.multiplyScalar(1 / t)
    }
    min(t)
    {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
    }
    max(t)
    {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
    }
    clamp(t, e)
    {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
    }
    clampScalar(t, e)
    {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
    }
    clampLength(t, e)
    {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }
    floor()
    {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }
    ceil()
    {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }
    round()
    {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }
    roundToZero()
    {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
    }
    negate()
    {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }
    dot(t)
    {
        return this.x * t.x + this.y * t.y + this.z * t.z
    }
    lengthSq()
    {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length()
    {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength()
    {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize()
    {
        return this.divideScalar(this.length() || 1)
    }
    setLength(t)
    {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e)
    {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
    }
    lerpVectors(t, e, n)
    {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
    }
    cross(t)
    {
        return this.crossVectors(this, t)
    }
    crossVectors(t, e)
    {
        const n = t.x,
            i = t.y,
            s = t.z,
            o = e.x,
            a = e.y,
            l = e.z;
        return this.x = i * l - s * a, this.y = s * o - n * l, this.z = n * a - i * o, this
    }
    projectOnVector(t)
    {
        const e = t.lengthSq();
        if (e === 0)
            return this.set(0, 0, 0);
        const n = t.dot(this) / e;
        return this.copy(t).multiplyScalar(n)
    }
    projectOnPlane(t)
    {
        return Oh.copy(this).projectOnVector(t), this.sub(Oh)
    }
    reflect(t)
    {
        return this.sub(Oh.copy(t).multiplyScalar(2 * this.dot(t)))
    }
    angleTo(t)
    {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (e === 0)
            return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(ls(n, -1, 1))
    }
    distanceTo(t)
    {
        return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t)
    {
        const e = this.x - t.x,
            n = this.y - t.y,
            i = this.z - t.z;
        return e * e + n * n + i * i
    }
    manhattanDistanceTo(t)
    {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    }
    setFromSpherical(t)
    {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
    }
    setFromSphericalCoords(t, e, n)
    {
        const i = Math.sin(e) * t;
        return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
    }
    setFromCylindrical(t)
    {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
    }
    setFromCylindricalCoords(t, e, n)
    {
        return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
    }
    setFromMatrixPosition(t)
    {
        const e = t.elements;
        return this.x = e[12], this.y = e[13], this.z = e[14], this
    }
    setFromMatrixScale(t)
    {
        const e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            i = this.setFromMatrixColumn(t, 2).length();
        return this.x = e, this.y = n, this.z = i, this
    }
    setFromMatrixColumn(t, e)
    {
        return this.fromArray(t.elements, e * 4)
    }
    setFromMatrix3Column(t, e)
    {
        return this.fromArray(t.elements, e * 3)
    }
    setFromEuler(t)
    {
        return this.x = t._x, this.y = t._y, this.z = t._z, this
    }
    setFromColor(t)
    {
        return this.x = t.r, this.y = t.g, this.z = t.b, this
    }
    equals(t)
    {
        return t.x === this.x && t.y === this.y && t.z === this.z
    }
    fromArray(t, e=0)
    {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
    }
    toArray(t=[], e=0)
    {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
    }
    fromBufferAttribute(t, e)
    {
        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
    }
    random()
    {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
    randomDirection()
    {
        const t = Math.random() * Math.PI * 2,
            e = Math.random() * 2 - 1,
            n = Math.sqrt(1 - e * e);
        return this.x = n * Math.cos(t), this.y = e, this.z = n * Math.sin(t), this
    }
    *[Symbol.iterator]()
    {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const Oh = new ji,
    ym = new V1;
class Ga {
    constructor(t, e, n, i, s, o, a, l, c, h, u, d, f, m, _, g)
    {
        Ga.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        t !== void 0 && this.set(t, e, n, i, s, o, a, l, c, h, u, d, f, m, _, g)
    }
    set(t, e, n, i, s, o, a, l, c, h, u, d, f, m, _, g)
    {
        const p = this.elements;
        return p[0] = t, p[4] = e, p[8] = n, p[12] = i, p[1] = s, p[5] = o, p[9] = a, p[13] = l, p[2] = c, p[6] = h, p[10] = u, p[14] = d, p[3] = f, p[7] = m, p[11] = _, p[15] = g, this
    }
    identity()
    {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone()
    {
        return new Ga().fromArray(this.elements)
    }
    copy(t)
    {
        const e = this.elements,
            n = t.elements;
        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
    }
    copyPosition(t)
    {
        const e = this.elements,
            n = t.elements;
        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
    }
    setFromMatrix3(t)
    {
        const e = t.elements;
        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(t, e, n)
    {
        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
    }
    makeBasis(t, e, n)
    {
        return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(t)
    {
        const e = this.elements,
            n = t.elements,
            i = 1 / eo.setFromMatrixColumn(t, 0).length(),
            s = 1 / eo.setFromMatrixColumn(t, 1).length(),
            o = 1 / eo.setFromMatrixColumn(t, 2).length();
        return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }
    makeRotationFromEuler(t)
    {
        const e = this.elements,
            n = t.x,
            i = t.y,
            s = t.z,
            o = Math.cos(n),
            a = Math.sin(n),
            l = Math.cos(i),
            c = Math.sin(i),
            h = Math.cos(s),
            u = Math.sin(s);
        if (t.order === "XYZ") {
            const d = o * h,
                f = o * u,
                m = a * h,
                _ = a * u;
            e[0] = l * h,
            e[4] = -l * u,
            e[8] = c,
            e[1] = f + m * c,
            e[5] = d - _ * c,
            e[9] = -a * l,
            e[2] = _ - d * c,
            e[6] = m + f * c,
            e[10] = o * l
        } else if (t.order === "YXZ") {
            const d = l * h,
                f = l * u,
                m = c * h,
                _ = c * u;
            e[0] = d + _ * a,
            e[4] = m * a - f,
            e[8] = o * c,
            e[1] = o * u,
            e[5] = o * h,
            e[9] = -a,
            e[2] = f * a - m,
            e[6] = _ + d * a,
            e[10] = o * l
        } else if (t.order === "ZXY") {
            const d = l * h,
                f = l * u,
                m = c * h,
                _ = c * u;
            e[0] = d - _ * a,
            e[4] = -o * u,
            e[8] = m + f * a,
            e[1] = f + m * a,
            e[5] = o * h,
            e[9] = _ - d * a,
            e[2] = -o * c,
            e[6] = a,
            e[10] = o * l
        } else if (t.order === "ZYX") {
            const d = o * h,
                f = o * u,
                m = a * h,
                _ = a * u;
            e[0] = l * h,
            e[4] = m * c - f,
            e[8] = d * c + _,
            e[1] = l * u,
            e[5] = _ * c + d,
            e[9] = f * c - m,
            e[2] = -c,
            e[6] = a * l,
            e[10] = o * l
        } else if (t.order === "YZX") {
            const d = o * l,
                f = o * c,
                m = a * l,
                _ = a * c;
            e[0] = l * h,
            e[4] = _ - d * u,
            e[8] = m * u + f,
            e[1] = u,
            e[5] = o * h,
            e[9] = -a * h,
            e[2] = -c * h,
            e[6] = f * u + m,
            e[10] = d - _ * u
        } else if (t.order === "XZY") {
            const d = o * l,
                f = o * c,
                m = a * l,
                _ = a * c;
            e[0] = l * h,
            e[4] = -u,
            e[8] = c * h,
            e[1] = d * u + _,
            e[5] = o * h,
            e[9] = f * u - m,
            e[2] = m * u - f,
            e[6] = a * h,
            e[10] = _ * u + d
        }
        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }
    makeRotationFromQuaternion(t)
    {
        return this.compose(G1, t, W1)
    }
    lookAt(t, e, n)
    {
        const i = this.elements;
        return jn.subVectors(t, e), jn.lengthSq() === 0 && (jn.z = 1), jn.normalize(), Ds.crossVectors(n, jn), Ds.lengthSq() === 0 && (Math.abs(n.z) === 1 ? jn.x += 1e-4 : jn.z += 1e-4, jn.normalize(), Ds.crossVectors(n, jn)), Ds.normalize(), Dl.crossVectors(jn, Ds), i[0] = Ds.x, i[4] = Dl.x, i[8] = jn.x, i[1] = Ds.y, i[5] = Dl.y, i[9] = jn.y, i[2] = Ds.z, i[6] = Dl.z, i[10] = jn.z, this
    }
    multiply(t)
    {
        return this.multiplyMatrices(this, t)
    }
    premultiply(t)
    {
        return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, e)
    {
        const n = t.elements,
            i = e.elements,
            s = this.elements,
            o = n[0],
            a = n[4],
            l = n[8],
            c = n[12],
            h = n[1],
            u = n[5],
            d = n[9],
            f = n[13],
            m = n[2],
            _ = n[6],
            g = n[10],
            p = n[14],
            x = n[3],
            v = n[7],
            y = n[11],
            C = n[15],
            A = i[0],
            T = i[4],
            R = i[8],
            E = i[12],
            M = i[1],
            D = i[5],
            I = i[9],
            k = i[13],
            $ = i[2],
            j = i[6],
            G = i[10],
            H = i[14],
            V = i[3],
            nt = i[7],
            P = i[11],
            ct = i[15];
        return s[0] = o * A + a * M + l * $ + c * V, s[4] = o * T + a * D + l * j + c * nt, s[8] = o * R + a * I + l * G + c * P, s[12] = o * E + a * k + l * H + c * ct, s[1] = h * A + u * M + d * $ + f * V, s[5] = h * T + u * D + d * j + f * nt, s[9] = h * R + u * I + d * G + f * P, s[13] = h * E + u * k + d * H + f * ct, s[2] = m * A + _ * M + g * $ + p * V, s[6] = m * T + _ * D + g * j + p * nt, s[10] = m * R + _ * I + g * G + p * P, s[14] = m * E + _ * k + g * H + p * ct, s[3] = x * A + v * M + y * $ + C * V, s[7] = x * T + v * D + y * j + C * nt, s[11] = x * R + v * I + y * G + C * P, s[15] = x * E + v * k + y * H + C * ct, this
    }
    multiplyScalar(t)
    {
        const e = this.elements;
        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
    }
    determinant()
    {
        const t = this.elements,
            e = t[0],
            n = t[4],
            i = t[8],
            s = t[12],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[13],
            h = t[2],
            u = t[6],
            d = t[10],
            f = t[14],
            m = t[3],
            _ = t[7],
            g = t[11],
            p = t[15];
        return m * (+s * l * u - i * c * u - s * a * d + n * c * d + i * a * f - n * l * f) + _ * (+e * l * f - e * c * d + s * o * d - i * o * f + i * c * h - s * l * h) + g * (+e * c * u - e * a * f - s * o * u + n * o * f + s * a * h - n * c * h) + p * (-i * a * h - e * l * u + e * a * d + i * o * u - n * o * d + n * l * h)
    }
    transpose()
    {
        const t = this.elements;
        let e;
        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
    }
    setPosition(t, e, n)
    {
        const i = this.elements;
        return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
    }
    invert()
    {
        const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            s = t[3],
            o = t[4],
            a = t[5],
            l = t[6],
            c = t[7],
            h = t[8],
            u = t[9],
            d = t[10],
            f = t[11],
            m = t[12],
            _ = t[13],
            g = t[14],
            p = t[15],
            x = u * g * c - _ * d * c + _ * l * f - a * g * f - u * l * p + a * d * p,
            v = m * d * c - h * g * c - m * l * f + o * g * f + h * l * p - o * d * p,
            y = h * _ * c - m * u * c + m * a * f - o * _ * f - h * a * p + o * u * p,
            C = m * u * l - h * _ * l - m * a * d + o * _ * d + h * a * g - o * u * g,
            A = e * x + n * v + i * y + s * C;
        if (A === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / A;
        return t[0] = x * T, t[1] = (_ * d * s - u * g * s - _ * i * f + n * g * f + u * i * p - n * d * p) * T, t[2] = (a * g * s - _ * l * s + _ * i * c - n * g * c - a * i * p + n * l * p) * T, t[3] = (u * l * s - a * d * s - u * i * c + n * d * c + a * i * f - n * l * f) * T, t[4] = v * T, t[5] = (h * g * s - m * d * s + m * i * f - e * g * f - h * i * p + e * d * p) * T, t[6] = (m * l * s - o * g * s - m * i * c + e * g * c + o * i * p - e * l * p) * T, t[7] = (o * d * s - h * l * s + h * i * c - e * d * c - o * i * f + e * l * f) * T, t[8] = y * T, t[9] = (m * u * s - h * _ * s - m * n * f + e * _ * f + h * n * p - e * u * p) * T, t[10] = (o * _ * s - m * a * s + m * n * c - e * _ * c - o * n * p + e * a * p) * T, t[11] = (h * a * s - o * u * s - h * n * c + e * u * c + o * n * f - e * a * f) * T, t[12] = C * T, t[13] = (h * _ * i - m * u * i + m * n * d - e * _ * d - h * n * g + e * u * g) * T, t[14] = (m * a * i - o * _ * i - m * n * l + e * _ * l + o * n * g - e * a * g) * T, t[15] = (o * u * i - h * a * i + h * n * l - e * u * l - o * n * d + e * a * d) * T, this
    }
    scale(t)
    {
        const e = this.elements,
            n = t.x,
            i = t.y,
            s = t.z;
        return e[0] *= n, e[4] *= i, e[8] *= s, e[1] *= n, e[5] *= i, e[9] *= s, e[2] *= n, e[6] *= i, e[10] *= s, e[3] *= n, e[7] *= i, e[11] *= s, this
    }
    getMaxScaleOnAxis()
    {
        const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, i))
    }
    makeTranslation(t, e, n)
    {
        return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
    }
    makeRotationX(t)
    {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
    }
    makeRotationY(t)
    {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(t)
    {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(t, e)
    {
        const n = Math.cos(e),
            i = Math.sin(e),
            s = 1 - n,
            o = t.x,
            a = t.y,
            l = t.z,
            c = s * o,
            h = s * a;
        return this.set(c * o + n, c * a - i * l, c * l + i * a, 0, c * a + i * l, h * a + n, h * l - i * o, 0, c * l - i * a, h * l + i * o, s * l * l + n, 0, 0, 0, 0, 1), this
    }
    makeScale(t, e, n)
    {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
    }
    makeShear(t, e, n, i, s, o)
    {
        return this.set(1, n, s, 0, t, 1, o, 0, e, i, 1, 0, 0, 0, 0, 1), this
    }
    compose(t, e, n)
    {
        const i = this.elements,
            s = e._x,
            o = e._y,
            a = e._z,
            l = e._w,
            c = s + s,
            h = o + o,
            u = a + a,
            d = s * c,
            f = s * h,
            m = s * u,
            _ = o * h,
            g = o * u,
            p = a * u,
            x = l * c,
            v = l * h,
            y = l * u,
            C = n.x,
            A = n.y,
            T = n.z;
        return i[0] = (1 - (_ + p)) * C, i[1] = (f + y) * C, i[2] = (m - v) * C, i[3] = 0, i[4] = (f - y) * A, i[5] = (1 - (d + p)) * A, i[6] = (g + x) * A, i[7] = 0, i[8] = (m + v) * T, i[9] = (g - x) * T, i[10] = (1 - (d + _)) * T, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
    }
    decompose(t, e, n)
    {
        const i = this.elements;
        let s = eo.set(i[0], i[1], i[2]).length();
        const o = eo.set(i[4], i[5], i[6]).length(),
            a = eo.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (s = -s),
        t.x = i[12],
        t.y = i[13],
        t.z = i[14],
        Ti.copy(this);
        const c = 1 / s,
            h = 1 / o,
            u = 1 / a;
        return Ti.elements[0] *= c, Ti.elements[1] *= c, Ti.elements[2] *= c, Ti.elements[4] *= h, Ti.elements[5] *= h, Ti.elements[6] *= h, Ti.elements[8] *= u, Ti.elements[9] *= u, Ti.elements[10] *= u, e.setFromRotationMatrix(Ti), n.x = s, n.y = o, n.z = a, this
    }
    makePerspective(t, e, n, i, s, o, a=Pl)
    {
        const l = this.elements,
            c = 2 * s / (e - t),
            h = 2 * s / (n - i),
            u = (e + t) / (e - t),
            d = (n + i) / (n - i);
        let f,
            m;
        if (a === Pl)
            f = -(o + s) / (o - s),
            m = -2 * o * s / (o - s);
        else if (a === _m)
            f = -o / (o - s),
            m = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c, l[4] = 0, l[8] = u, l[12] = 0, l[1] = 0, l[5] = h, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
    }
    makeOrthographic(t, e, n, i, s, o, a=Pl)
    {
        const l = this.elements,
            c = 1 / (e - t),
            h = 1 / (n - i),
            u = 1 / (o - s),
            d = (e + t) * c,
            f = (n + i) * h;
        let m,
            _;
        if (a === Pl)
            m = (o + s) * u,
            _ = -2 * u;
        else if (a === _m)
            m = s * u,
            _ = -1 * u;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
    }
    equals(t)
    {
        const e = this.elements,
            n = t.elements;
        for (let i = 0; i < 16; i++)
            if (e[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(t, e=0)
    {
        for (let n = 0; n < 16; n++)
            this.elements[n] = t[n + e];
        return this
    }
    toArray(t=[], e=0)
    {
        const n = this.elements;
        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
    }
}
const eo = new ji,
    Ti = new Ga,
    G1 = new ji(0, 0, 0),
    W1 = new ji(1, 1, 1),
    Ds = new ji,
    Dl = new ji,
    jn = new ji;
class ef {
    constructor(t=0, e=0)
    {
        ef.prototype.isVector2 = !0,
        this.x = t,
        this.y = e
    }
    get width()
    {
        return this.x
    }
    set width(t)
    {
        this.x = t
    }
    get height()
    {
        return this.y
    }
    set height(t)
    {
        this.y = t
    }
    set(t, e)
    {
        return this.x = t, this.y = e, this
    }
    setScalar(t)
    {
        return this.x = t, this.y = t, this
    }
    setX(t)
    {
        return this.x = t, this
    }
    setY(t)
    {
        return this.y = t, this
    }
    setComponent(t, e)
    {
        switch (t) {
        case 0:
            this.x = e;
            break;
        case 1:
            this.y = e;
            break;
        default:
            throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t)
    {
        switch (t) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + t)
        }
    }
    clone()
    {
        return new this.constructor(this.x, this.y)
    }
    copy(t)
    {
        return this.x = t.x, this.y = t.y, this
    }
    add(t)
    {
        return this.x += t.x, this.y += t.y, this
    }
    addScalar(t)
    {
        return this.x += t, this.y += t, this
    }
    addVectors(t, e)
    {
        return this.x = t.x + e.x, this.y = t.y + e.y, this
    }
    addScaledVector(t, e)
    {
        return this.x += t.x * e, this.y += t.y * e, this
    }
    sub(t)
    {
        return this.x -= t.x, this.y -= t.y, this
    }
    subScalar(t)
    {
        return this.x -= t, this.y -= t, this
    }
    subVectors(t, e)
    {
        return this.x = t.x - e.x, this.y = t.y - e.y, this
    }
    multiply(t)
    {
        return this.x *= t.x, this.y *= t.y, this
    }
    multiplyScalar(t)
    {
        return this.x *= t, this.y *= t, this
    }
    divide(t)
    {
        return this.x /= t.x, this.y /= t.y, this
    }
    divideScalar(t)
    {
        return this.multiplyScalar(1 / t)
    }
    applyMatrix3(t)
    {
        const e = this.x,
            n = this.y,
            i = t.elements;
        return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
    }
    min(t)
    {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
    }
    max(t)
    {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
    }
    clamp(t, e)
    {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
    }
    clampScalar(t, e)
    {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
    }
    clampLength(t, e)
    {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }
    floor()
    {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil()
    {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round()
    {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero()
    {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
    }
    negate()
    {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(t)
    {
        return this.x * t.x + this.y * t.y
    }
    cross(t)
    {
        return this.x * t.y - this.y * t.x
    }
    lengthSq()
    {
        return this.x * this.x + this.y * this.y
    }
    length()
    {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength()
    {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize()
    {
        return this.divideScalar(this.length() || 1)
    }
    angle()
    {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(t)
    {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (e === 0)
            return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(ls(n, -1, 1))
    }
    distanceTo(t)
    {
        return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t)
    {
        const e = this.x - t.x,
            n = this.y - t.y;
        return e * e + n * n
    }
    manhattanDistanceTo(t)
    {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
    }
    setLength(t)
    {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e)
    {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
    }
    lerpVectors(t, e, n)
    {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
    }
    equals(t)
    {
        return t.x === this.x && t.y === this.y
    }
    fromArray(t, e=0)
    {
        return this.x = t[e], this.y = t[e + 1], this
    }
    toArray(t=[], e=0)
    {
        return t[e] = this.x, t[e + 1] = this.y, t
    }
    fromBufferAttribute(t, e)
    {
        return this.x = t.getX(e), this.y = t.getY(e), this
    }
    rotateAround(t, e)
    {
        const n = Math.cos(e),
            i = Math.sin(e),
            s = this.x - t.x,
            o = this.y - t.y;
        return this.x = s * n - o * i + t.x, this.y = s * i + o * n + t.y, this
    }
    random()
    {
        return this.x = Math.random(), this.y = Math.random(), this
    }
    *[Symbol.iterator]()
    {
        yield this.x,
        yield this.y
    }
}
class nf {
    constructor(t=0, e=0, n=0, i=1)
    {
        nf.prototype.isVector4 = !0,
        this.x = t,
        this.y = e,
        this.z = n,
        this.w = i
    }
    get width()
    {
        return this.z
    }
    set width(t)
    {
        this.z = t
    }
    get height()
    {
        return this.w
    }
    set height(t)
    {
        this.w = t
    }
    set(t, e, n, i)
    {
        return this.x = t, this.y = e, this.z = n, this.w = i, this
    }
    setScalar(t)
    {
        return this.x = t, this.y = t, this.z = t, this.w = t, this
    }
    setX(t)
    {
        return this.x = t, this
    }
    setY(t)
    {
        return this.y = t, this
    }
    setZ(t)
    {
        return this.z = t, this
    }
    setW(t)
    {
        return this.w = t, this
    }
    setComponent(t, e)
    {
        switch (t) {
        case 0:
            this.x = e;
            break;
        case 1:
            this.y = e;
            break;
        case 2:
            this.z = e;
            break;
        case 3:
            this.w = e;
            break;
        default:
            throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t)
    {
        switch (t) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + t)
        }
    }
    clone()
    {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(t)
    {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this
    }
    add(t)
    {
        return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
    }
    addScalar(t)
    {
        return this.x += t, this.y += t, this.z += t, this.w += t, this
    }
    addVectors(t, e)
    {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
    }
    addScaledVector(t, e)
    {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
    }
    sub(t)
    {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
    }
    subScalar(t)
    {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
    }
    subVectors(t, e)
    {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
    }
    multiply(t)
    {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
    }
    multiplyScalar(t)
    {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
    }
    applyMatrix4(t)
    {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = this.w,
            o = t.elements;
        return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * s, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * s, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * s, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * s, this
    }
    divideScalar(t)
    {
        return this.multiplyScalar(1 / t)
    }
    setAxisAngleFromQuaternion(t)
    {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
    }
    setAxisAngleFromRotationMatrix(t)
    {
        let e,
            n,
            i,
            s;
        const l = t.elements,
            c = l[0],
            h = l[4],
            u = l[8],
            d = l[1],
            f = l[5],
            m = l[9],
            _ = l[2],
            g = l[6],
            p = l[10];
        if (Math.abs(h - d) < .01 && Math.abs(u - _) < .01 && Math.abs(m - g) < .01) {
            if (Math.abs(h + d) < .1 && Math.abs(u + _) < .1 && Math.abs(m + g) < .1 && Math.abs(c + f + p - 3) < .1)
                return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const v = (c + 1) / 2,
                y = (f + 1) / 2,
                C = (p + 1) / 2,
                A = (h + d) / 4,
                T = (u + _) / 4,
                R = (m + g) / 4;
            return v > y && v > C ? v < .01 ? (n = 0, i = .707106781, s = .707106781) : (n = Math.sqrt(v), i = A / n, s = T / n) : y > C ? y < .01 ? (n = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(y), n = A / i, s = R / i) : C < .01 ? (n = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(C), n = T / s, i = R / s), this.set(n, i, s, e), this
        }
        let x = Math.sqrt((g - m) * (g - m) + (u - _) * (u - _) + (d - h) * (d - h));
        return Math.abs(x) < .001 && (x = 1), this.x = (g - m) / x, this.y = (u - _) / x, this.z = (d - h) / x, this.w = Math.acos((c + f + p - 1) / 2), this
    }
    setFromMatrixPosition(t)
    {
        const e = t.elements;
        return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this
    }
    min(t)
    {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
    }
    max(t)
    {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
    }
    clamp(t, e)
    {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
    }
    clampScalar(t, e)
    {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
    }
    clampLength(t, e)
    {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }
    floor()
    {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil()
    {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round()
    {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero()
    {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
    }
    negate()
    {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(t)
    {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }
    lengthSq()
    {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length()
    {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength()
    {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize()
    {
        return this.divideScalar(this.length() || 1)
    }
    setLength(t)
    {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e)
    {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
    }
    lerpVectors(t, e, n)
    {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
    }
    equals(t)
    {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
    }
    fromArray(t, e=0)
    {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
    }
    toArray(t=[], e=0)
    {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
    }
    fromBufferAttribute(t, e)
    {
        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
    }
    random()
    {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }
    *[Symbol.iterator]()
    {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
function X1(r, t=!1) {
    let e = "{";
    r.isNode === !0 && (e += r.id);
    for (const {property: n, childNode: i} of Ku(r))
        e += "," + n.slice(0, -4) + ":" + i.getCacheKey(t);
    return e += "}", e
}
function* Ku(r, t=!1) {
    for (const e in r) {
        if (e.startsWith("_") === !0)
            continue;
        const n = r[e];
        if (Array.isArray(n) === !0)
            for (let i = 0; i < n.length; i++) {
                const s = n[i];
                s && (s.isNode === !0 || t && typeof s.toJSON == "function") && (yield {
                    property: e,
                    index: i,
                    childNode: s
                })
            }
        else if (n && n.isNode === !0)
            yield {
                property: e,
                childNode: n
            };
        else if (typeof n == "object")
            for (const i in n) {
                const s = n[i];
                s && (s.isNode === !0 || t && typeof s.toJSON == "function") && (yield {
                    property: e,
                    index: i,
                    childNode: s
                })
            }
    }
}
function ju(r) {
    if (r == null)
        return null;
    const t = typeof r;
    return r.isNode === !0 ? "node" : t === "number" ? "float" : t === "boolean" ? "bool" : t === "string" ? "string" : t === "function" ? "shader" : r.isVector2 === !0 ? "vec2" : r.isVector3 === !0 ? "vec3" : r.isVector4 === !0 ? "vec4" : r.isMatrix3 === !0 ? "mat3" : r.isMatrix4 === !0 ? "mat4" : r.isColor === !0 ? "color" : r instanceof ArrayBuffer ? "ArrayBuffer" : null
}
function G_(r, ...t) {
    const e = r ? r.slice(-4) : void 0;
    return t.length === 1 && (e === "vec2" ? t = [t[0], t[0]] : e === "vec3" ? t = [t[0], t[0], t[0]] : e === "vec4" && (t = [t[0], t[0], t[0], t[0]])), r === "color" ? new tf(...t) : e === "vec2" ? new ef(...t) : e === "vec3" ? new ji(...t) : e === "vec4" ? new nf(...t) : e === "mat3" ? new Wo(...t) : e === "mat4" ? new Ga(...t) : r === "bool" ? t[0] || !1 : r === "float" || r === "int" || r === "uint" ? t[0] || 0 : r === "string" ? t[0] || "" : r === "ArrayBuffer" ? $1(t[0]) : null
}
function Y1(r) {
    let t = "";
    const e = new Uint8Array(r);
    for (let n = 0; n < e.length; n++)
        t += String.fromCharCode(e[n]);
    return btoa(t)
}
function $1(r) {
    return Uint8Array.from(atob(r), t => t.charCodeAt(0)).buffer
}
class q1 {
    addEventListener(t, e)
    {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[t] === void 0 && (n[t] = []),
        n[t].indexOf(e) === -1 && n[t].push(e)
    }
    hasEventListener(t, e)
    {
        if (this._listeners === void 0)
            return !1;
        const n = this._listeners;
        return n[t] !== void 0 && n[t].indexOf(e) !== -1
    }
    removeEventListener(t, e)
    {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[t];
        if (i !== void 0) {
            const s = i.indexOf(e);
            s !== -1 && i.splice(s, 1)
        }
    }
    dispatchEvent(t)
    {
        if (this._listeners === void 0)
            return;
        const n = this._listeners[t.type];
        if (n !== void 0) {
            t.target = this;
            const i = n.slice(0);
            for (let s = 0, o = i.length; s < o; s++)
                i[s].call(this, t);
            t.target = null
        }
    }
}
const Mm = new Map;
let K1 = 0;
class oi extends q1 {
    constructor(t=null)
    {
        super(),
        this.nodeType = t,
        this.updateType = to.NONE,
        this.updateBeforeType = to.NONE,
        this.updateAfterType = to.NONE,
        this.uuid = z1.generateUUID(),
        this.version = 0,
        this._cacheKey = null,
        this._cacheKeyVersion = 0,
        this.global = !1,
        this.isNode = !0,
        Object.defineProperty(this, "id", {
            value: K1++
        })
    }
    set needsUpdate(t)
    {
        t === !0 && this.version++
    }
    get type()
    {
        return this.constructor.type
    }
    onUpdate(t, e)
    {
        return this.updateType = e, this.update = t.bind(this.getSelf()), this
    }
    onFrameUpdate(t)
    {
        return this.onUpdate(t, to.FRAME)
    }
    onRenderUpdate(t)
    {
        return this.onUpdate(t, to.RENDER)
    }
    onObjectUpdate(t)
    {
        return this.onUpdate(t, to.OBJECT)
    }
    onReference(t)
    {
        return this.updateReference = t.bind(this.getSelf()), this
    }
    getSelf()
    {
        return this.self || this
    }
    updateReference()
    {
        return this
    }
    isGlobal()
    {
        return this.global
    }
    *getChildren()
    {
        for (const {childNode: t} of Ku(this))
            yield t
    }
    dispose()
    {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    traverse(t)
    {
        t(this);
        for (const e of this.getChildren())
            e.traverse(t)
    }
    getCacheKey(t=!1)
    {
        return t = t || this.version !== this._cacheKeyVersion, (t === !0 || this._cacheKey === null) && (this._cacheKey = X1(this, t), this._cacheKeyVersion = this.version), this._cacheKey
    }
    getHash()
    {
        return this.uuid
    }
    getUpdateType()
    {
        return this.updateType
    }
    getUpdateBeforeType()
    {
        return this.updateBeforeType
    }
    getUpdateAfterType()
    {
        return this.updateAfterType
    }
    getElementType(t)
    {
        const e = this.getNodeType(t);
        return t.getElementType(e)
    }
    getNodeType(t)
    {
        const e = t.getNodeProperties(this);
        return e.outputNode ? e.outputNode.getNodeType(t) : this.nodeType
    }
    getShared(t)
    {
        const e = this.getHash(t);
        return t.getNodeFromHash(e) || this
    }
    setup(t)
    {
        const e = t.getNodeProperties(this);
        let n = 0;
        for (const i of this.getChildren())
            e["node" + n++] = i;
        return null
    }
    increaseUsage(t)
    {
        const e = t.getDataFromNode(this);
        return e.usageCount = e.usageCount === void 0 ? 1 : e.usageCount + 1, e.usageCount
    }
    analyze(t)
    {
        if (this.increaseUsage(t) === 1) {
            const n = t.getNodeProperties(this);
            for (const i of Object.values(n))
                i && i.isNode === !0 && i.build(t)
        }
    }
    generate(t, e)
    {
        const {outputNode: n} = t.getNodeProperties(this);
        if (n && n.isNode === !0)
            return n.build(t, e)
    }
    updateBefore()
    {
        console.warn("Abstract function.")
    }
    updateAfter()
    {
        console.warn("Abstract function.")
    }
    update()
    {
        console.warn("Abstract function.")
    }
    build(t, e=null)
    {
        const n = this.getShared(t);
        if (this !== n)
            return n.build(t, e);
        t.addNode(this),
        t.addChain(this);
        let i = null;
        const s = t.getBuildStage();
        if (s === "setup") {
            this.updateReference(t);
            const o = t.getNodeProperties(this);
            if (o.initialized !== !0) {
                const a = t.stack.nodes.length;
                o.initialized = !0,
                o.outputNode = this.setup(t),
                o.outputNode !== null && t.stack.nodes.length !== a && (o.outputNode = t.stack);
                for (const l of Object.values(o))
                    l && l.isNode === !0 && l.build(t)
            }
        } else if (s === "analyze")
            this.analyze(t);
        else if (s === "generate")
            if (this.generate.length === 1) {
                const a = this.getNodeType(t),
                    l = t.getDataFromNode(this);
                i = l.snippet,
                i === void 0 && (i = this.generate(t) || "", l.snippet = i),
                i = t.format(i, a, e)
            } else
                i = this.generate(t, e) || "";
        return t.removeChain(this), i
    }
    getSerializeChildren()
    {
        return Ku(this)
    }
    serialize(t)
    {
        const e = this.getSerializeChildren(),
            n = {};
        for (const {property: i, index: s, childNode: o} of e)
            s !== void 0 ? (n[i] === void 0 && (n[i] = Number.isInteger(s) ? [] : {}), n[i][s] = o.toJSON(t.meta).uuid) : n[i] = o.toJSON(t.meta).uuid;
        Object.keys(n).length > 0 && (t.inputNodes = n)
    }
    deserialize(t)
    {
        if (t.inputNodes !== void 0) {
            const e = t.meta.nodes;
            for (const n in t.inputNodes)
                if (Array.isArray(t.inputNodes[n])) {
                    const i = [];
                    for (const s of t.inputNodes[n])
                        i.push(e[s]);
                    this[n] = i
                } else if (typeof t.inputNodes[n] == "object") {
                    const i = {};
                    for (const s in t.inputNodes[n]) {
                        const o = t.inputNodes[n][s];
                        i[s] = e[o]
                    }
                    this[n] = i
                } else {
                    const i = t.inputNodes[n];
                    this[n] = e[i]
                }
        }
    }
    toJSON(t)
    {
        const {uuid: e, type: n} = this,
            i = t === void 0 || typeof t == "string";
        i && (t = {
            textures: {},
            images: {},
            nodes: {}
        });
        let s = t.nodes[e];
        s === void 0 && (s = {
            uuid: e,
            type: n,
            meta: t,
            metadata: {
                version: 4.6,
                type: "Node",
                generator: "Node.toJSON"
            }
        }, i !== !0 && (t.nodes[s.uuid] = s), this.serialize(s), delete s.meta);
        function o(a) {
            const l = [];
            for (const c in a) {
                const h = a[c];
                delete h.metadata,
                l.push(h)
            }
            return l
        }
        if (i) {
            const a = o(t.textures),
                l = o(t.images),
                c = o(t.nodes);
            a.length > 0 && (s.textures = a),
            l.length > 0 && (s.images = l),
            c.length > 0 && (s.nodes = c)
        }
        return s
    }
}
function fn(r, t) {
    if (typeof t != "function" || !r)
        throw new Error(`Node class ${r} is not a class`);
    if (Mm.has(r)) {
        console.warn(`Redefinition of node class ${r}`);
        return
    }
    Mm.set(r, t),
    t.type = r
}
class sf extends oi {
    constructor(t, e)
    {
        super(),
        this.node = t,
        this.indexNode = e,
        this.isArrayElementNode = !0
    }
    getNodeType(t)
    {
        return this.node.getElementType(t)
    }
    generate(t)
    {
        const e = this.node.build(t),
            n = this.indexNode.build(t, "uint");
        return `${e}[ ${n} ]`
    }
}
fn("ArrayElementNode", sf);
class rf extends oi {
    constructor(t, e)
    {
        super(),
        this.node = t,
        this.convertTo = e
    }
    getNodeType(t)
    {
        const e = this.node.getNodeType(t);
        let n = null;
        for (const i of this.convertTo.split("|"))
            (n === null || t.getTypeLength(e) === t.getTypeLength(i)) && (n = i);
        return n
    }
    serialize(t)
    {
        super.serialize(t),
        t.convertTo = this.convertTo
    }
    deserialize(t)
    {
        super.deserialize(t),
        this.convertTo = t.convertTo
    }
    generate(t, e)
    {
        const n = this.node,
            i = this.getNodeType(t),
            s = n.build(t, i);
        return t.format(s, i, e)
    }
}
fn("ConvertNode", rf);
class Ja extends oi {
    constructor(t)
    {
        super(t),
        this.isTempNode = !0
    }
    hasDependencies(t)
    {
        return t.getDataFromNode(this).usageCount > 1
    }
    build(t, e)
    {
        if (t.getBuildStage() === "generate") {
            const i = t.getVectorType(this.getNodeType(t, e)),
                s = t.getDataFromNode(this);
            if (s.propertyName !== void 0)
                return t.format(s.propertyName, i, e);
            if (i !== "void" && e !== "void" && this.hasDependencies(t)) {
                const o = super.build(t, i),
                    a = t.getVarFromNode(this, null, i),
                    l = t.getPropertyName(a);
                return t.addLineFlowCode(`${l} = ${o}`), s.snippet = o, s.propertyName = l, t.format(s.propertyName, i, e)
            }
        }
        return super.build(t, e)
    }
}
fn("TempNode", Ja);
class W_ extends Ja {
    constructor(t=[], e=null)
    {
        super(e),
        this.nodes = t
    }
    getNodeType(t)
    {
        return this.nodeType !== null ? t.getVectorType(this.nodeType) : t.getTypeFromLength(this.nodes.reduce((e, n) => e + t.getTypeLength(n.getNodeType(t)), 0))
    }
    generate(t, e)
    {
        const n = this.getNodeType(t),
            i = this.nodes,
            s = t.getComponentType(n),
            o = [];
        for (const l of i) {
            let c = l.build(t);
            const h = t.getComponentType(l.getNodeType(t));
            h !== s && (c = t.format(c, h, s)),
            o.push(c)
        }
        const a = `${t.getType(n)}( ${o.join(", ")} )`;
        return t.format(a, n, e)
    }
}
fn("JoinNode", W_);
const j1 = Zd.join("");
class Zu extends oi {
    constructor(t, e="x")
    {
        super(),
        this.node = t,
        this.components = e,
        this.isSplitNode = !0
    }
    getVectorLength()
    {
        let t = this.components.length;
        for (const e of this.components)
            t = Math.max(Zd.indexOf(e) + 1, t);
        return t
    }
    getComponentType(t)
    {
        return t.getComponentType(this.node.getNodeType(t))
    }
    getNodeType(t)
    {
        return t.getTypeFromLength(this.components.length, this.getComponentType(t))
    }
    generate(t, e)
    {
        const n = this.node,
            i = t.getTypeLength(n.getNodeType(t));
        let s = null;
        if (i > 1) {
            let o = null;
            this.getVectorLength() >= i && (o = t.getTypeFromLength(this.getVectorLength(), this.getComponentType(t)));
            const l = n.build(t, o);
            this.components.length === i && this.components === j1.slice(0, this.components.length) ? s = t.format(l, o, e) : s = t.format(`${l}.${this.components}`, this.getNodeType(t), e)
        } else
            s = n.build(t, e);
        return s
    }
    serialize(t)
    {
        super.serialize(t),
        t.components = this.components
    }
    deserialize(t)
    {
        super.deserialize(t),
        this.components = t.components
    }
}
fn("SplitNode", Zu);
class X_ extends Ja {
    constructor(t, e, n)
    {
        super(),
        this.sourceNode = t,
        this.components = e,
        this.targetNode = n
    }
    getNodeType(t)
    {
        return this.sourceNode.getNodeType(t)
    }
    generate(t)
    {
        const {sourceNode: e, components: n, targetNode: i} = this,
            s = this.getNodeType(t),
            o = t.getTypeFromLength(n.length),
            a = i.build(t, o),
            l = e.build(t, s),
            c = t.getTypeLength(s),
            h = [];
        for (let u = 0; u < c; u++) {
            const d = Zd[u];
            d === n[0] ? (h.push(a), u += n.length - 1) : h.push(l + "." + d)
        }
        return `${t.getType(s)}( ${h.join(", ")} )`
    }
}
fn("SetNode", X_);
class Y_ extends oi {
    constructor(t, e=null)
    {
        super(e),
        this.isInputNode = !0,
        this.value = t,
        this.precision = null
    }
    getNodeType()
    {
        return this.nodeType === null ? ju(this.value) : this.nodeType
    }
    getInputType(t)
    {
        return this.getNodeType(t)
    }
    setPrecision(t)
    {
        return this.precision = t, this
    }
    serialize(t)
    {
        super.serialize(t),
        t.value = this.value,
        this.value && this.value.toArray && (t.value = this.value.toArray()),
        t.valueType = ju(this.value),
        t.nodeType = this.nodeType,
        t.valueType === "ArrayBuffer" && (t.value = Y1(t.value)),
        t.precision = this.precision
    }
    deserialize(t)
    {
        super.deserialize(t),
        this.nodeType = t.nodeType,
        this.value = Array.isArray(t.value) ? G_(t.valueType, ...t.value) : t.value,
        this.precision = t.precision || null,
        this.value && this.value.fromArray && (this.value = this.value.fromArray(t.value))
    }
    generate()
    {
        console.warn("Abstract function.")
    }
}
fn("InputNode", Y_);
class Zi extends Y_ {
    constructor(t, e=null)
    {
        super(t, e),
        this.isConstNode = !0
    }
    generateConst(t)
    {
        return t.generateConst(this.getNodeType(t), this.value)
    }
    generate(t, e)
    {
        const n = this.getNodeType(t);
        return t.format(this.generateConst(t), n, e)
    }
}
fn("ConstNode", Zi);
let Z1 = null;
const co = new Map;
function tt(r, t) {
    if (co.has(r)) {
        console.warn(`Redefinition of node element ${r}`);
        return
    }
    if (typeof t != "function")
        throw new Error(`Node element ${r} is not a function`);
    co.set(r, t)
}
const Sm = r => r.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"),
    $_ = {
        setup(r, t) {
            const e = t.shift();
            return r(cf(e), ...t)
        },
        get(r, t, e) {
            if (typeof t == "string" && r[t] === void 0) {
                if (r.isStackNode !== !0 && t === "assign")
                    return (...n) => (Z1.assign(e, ...n), e);
                if (co.has(t)) {
                    const n = co.get(t);
                    return r.isStackNode ? (...i) => e.add(n(...i)) : (...i) => n(e, ...i)
                } else {
                    if (t === "self")
                        return r;
                    if (t.endsWith("Assign") && co.has(t.slice(0, t.length - 6))) {
                        const n = co.get(t.slice(0, t.length - 6));
                        return r.isStackNode ? (...i) => e.assign(i[0], n(...i)) : (...i) => e.assign(n(e, ...i))
                    } else {
                        if (/^[xyzwrgbastpq]{1,4}$/.test(t) === !0)
                            return t = Sm(t), Le(new Zu(e, t));
                        if (/^set[XYZWRGBASTPQ]{1,4}$/.test(t) === !0)
                            return t = Sm(t.slice(3).toLowerCase()), t = t.split("").sort().join(""), n => Le(new X_(r, t, n));
                        if (t === "width" || t === "height" || t === "depth")
                            return t === "width" ? t = "x" : t === "height" ? t = "y" : t === "depth" && (t = "z"), Le(new Zu(r, t));
                        if (/^\d+$/.test(t) === !0)
                            return Le(new sf(e, new Zi(Number(t), "uint")))
                    }
                }
            }
            return Reflect.get(r, t, e)
        },
        set(r, t, e, n) {
            return typeof t == "string" && r[t] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(t) === !0 || t === "width" || t === "height" || t === "depth" || /^\d+$/.test(t) === !0) ? (n[t].assign(e), !0) : Reflect.set(r, t, e, n)
        }
    },
    zh = new WeakMap,
    Tm = new WeakMap,
    J1 = function(r, t=null) {
        const e = ju(r);
        if (e === "node") {
            let n = zh.get(r);
            return n === void 0 && (n = new Proxy(r, $_), zh.set(r, n), zh.set(n, n)), n
        } else {
            if (t === null && (e === "float" || e === "boolean") || e && e !== "shader" && e !== "string")
                return Le(Ju(r, t));
            if (e === "shader")
                return j_(r)
        }
        return r
    },
    Q1 = function(r, t=null) {
        for (const e in r)
            r[e] = Le(r[e], t);
        return r
    },
    tA = function(r, t=null) {
        const e = r.length;
        for (let n = 0; n < e; n++)
            r[n] = Le(r[n], t);
        return r
    },
    eA = function(r, t=null, e=null, n=null) {
        const i = s => Le(n !== null ? Object.assign(s, n) : s);
        return t === null ? (...s) => i(new r(...Ma(s))) : e !== null ? (e = Le(e), (...s) => i(new r(t, ...Ma(s), e))) : (...s) => i(new r(t, ...Ma(s)))
    },
    nA = function(r, ...t) {
        return Le(new r(...Ma(t)))
    };
class iA extends oi {
    constructor(t, e)
    {
        super(),
        this.shaderNode = t,
        this.inputNodes = e
    }
    getNodeType(t)
    {
        const e = t.getNodeProperties(this);
        return e.outputNode === null && (e.outputNode = this.setupOutput(t)), e.outputNode.getNodeType(t)
    }
    call(t)
    {
        const {shaderNode: e, inputNodes: n} = this;
        if (e.layout) {
            let o = Tm.get(t.constructor);
            o === void 0 && (o = new WeakMap, Tm.set(t.constructor, o));
            let a = o.get(e);
            return a === void 0 && (a = Le(t.buildFunctionNode(e)), o.set(e, a)), t.currentFunctionNode !== null && t.currentFunctionNode.includes.push(a), Le(a.call(n))
        }
        const i = e.jsFunc,
            s = n !== null ? i(n, t.stack, t) : i(t.stack, t);
        return Le(s)
    }
    setup(t)
    {
        const {outputNode: e} = t.getNodeProperties(this);
        return e || this.setupOutput(t)
    }
    setupOutput(t)
    {
        return t.addStack(), t.stack.outputNode = this.call(t), t.removeStack()
    }
    generate(t, e)
    {
        const {outputNode: n} = t.getNodeProperties(this);
        return n === null ? this.call(t).build(t, e) : super.generate(t, e)
    }
}
class sA extends oi {
    constructor(t)
    {
        super(),
        this.jsFunc = t,
        this.layout = null,
        this.global = !0
    }
    get isArrayInput()
    {
        return /^\((\s+)?\[/.test(this.jsFunc.toString())
    }
    setLayout(t)
    {
        return this.layout = t, this
    }
    call(t=null)
    {
        return cf(t), Le(new iA(this, t))
    }
    setup()
    {
        return this.call()
    }
}
const rA = [!1, !0],
    oA = [0, 1, 2, 3],
    aA = [-1, -2],
    q_ = [.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2],
    of = new Map;
for (const r of rA)
    of.set(r, new Zi(r));
const af = new Map;
for (const r of oA)
    af.set(r, new Zi(r, "uint"));
const lf = new Map([...af].map(r => new Zi(r.value, "int")));
for (const r of aA)
    lf.set(r, new Zi(r, "int"));
const Uc = new Map([...lf].map(r => new Zi(r.value)));
for (const r of q_)
    Uc.set(r, new Zi(r));
for (const r of q_)
    Uc.set(-r, new Zi(-r));
const Oc = {
        bool: of,
        uint: af,
        ints: lf,
        float: Uc
    },
    Em = new Map([...of, ...Uc]),
    Ju = (r, t) => Em.has(r) ? Em.get(r) : r.isNode === !0 ? r : new Zi(r, t),
    lA = r => {
        try {
            return r.getNodeType()
        } catch {
            return
        }
    },
    Se = function(r, t=null) {
        return (...e) => {
            if ((e.length === 0 || !["bool", "float", "int", "uint"].includes(r) && e.every(i => typeof i != "object")) && (e = [G_(r, ...e)]), e.length === 1 && t !== null && t.has(e[0]))
                return Le(t.get(e[0]));
            if (e.length === 1) {
                const i = Ju(e[0], r);
                return lA(i) === r ? Le(i) : Le(new rf(i, r))
            }
            const n = e.map(i => Ju(i));
            return Le(new W_(n, r))
        }
    };
function K_(r) {
    return new Proxy(new sA(r), $_)
}
const Le = (r, t=null) => J1(r, t),
    cf = (r, t=null) => new Q1(r, t),
    Ma = (r, t=null) => new tA(r, t),
    pt = (...r) => new eA(...r),
    be = (...r) => new nA(...r),
    j_ = r => {
        const t = new K_(r),
            e = (...n) => {
                let i;
                return cf(n), n[0] && n[0].isNode ? i = [...n] : i = n[0], t.call(i)
            };
        return e.shaderNode = t, e.setLayout = n => (t.setLayout(n), e), e
    };
fn("ShaderNode", K_);
tt("toGlobal", r => (r.global = !0, r));
function cA(r) {
    return r
}
tt("append", cA);
const hA = new Se("color"),
    Qa = new Se("float", Oc.float),
    uA = new Se("int", Oc.ints),
    dA = new Se("uint", Oc.uint),
    fA = new Se("bool", Oc.bool),
    Z_ = new Se("vec2"),
    pA = new Se("ivec2"),
    mA = new Se("uvec2"),
    gA = new Se("bvec2"),
    Qu = new Se("vec3"),
    _A = new Se("ivec3"),
    xA = new Se("uvec3"),
    vA = new Se("bvec3"),
    td = new Se("vec4"),
    yA = new Se("ivec4"),
    MA = new Se("uvec4"),
    SA = new Se("bvec4"),
    TA = new Se("mat2"),
    EA = new Se("imat2"),
    bA = new Se("umat2"),
    wA = new Se("bmat2"),
    AA = new Se("mat3"),
    CA = new Se("imat3"),
    RA = new Se("umat3"),
    PA = new Se("bmat3"),
    LA = new Se("mat4"),
    DA = new Se("imat4"),
    NA = new Se("umat4"),
    IA = new Se("bmat4");
tt("toColor", hA);
tt("toFloat", Qa);
tt("toInt", uA);
tt("toUint", dA);
tt("toBool", fA);
tt("toVec2", Z_);
tt("toIvec2", pA);
tt("toUvec2", mA);
tt("toBvec2", gA);
tt("toVec3", Qu);
tt("toIvec3", _A);
tt("toUvec3", xA);
tt("toBvec3", vA);
tt("toVec4", td);
tt("toIvec4", yA);
tt("toUvec4", MA);
tt("toBvec4", SA);
tt("toMat2", TA);
tt("toImat2", EA);
tt("toUmat2", bA);
tt("toBmat2", wA);
tt("toMat3", AA);
tt("toImat3", CA);
tt("toUmat3", RA);
tt("toBmat3", PA);
tt("toMat4", LA);
tt("toImat4", DA);
tt("toUmat4", NA);
tt("toBmat4", IA);
const FA = pt(sf),
    UA = (r, t) => Le(new rf(Le(r), t));
tt("element", FA);
tt("convert", UA);
class _e extends oi {
    constructor(t, e=null, n=!1)
    {
        super(t),
        this.name = e,
        this.varying = n,
        this.isPropertyNode = !0
    }
    getHash(t)
    {
        return this.name || super.getHash(t)
    }
    isGlobal()
    {
        return !0
    }
    generate(t)
    {
        let e;
        return this.varying === !0 ? (e = t.getVaryingFromNode(this, this.name), e.needsInterpolation = !0) : e = t.getVarFromNode(this, this.name), t.getPropertyName(e)
    }
}
const OA = (r, t) => Le(new _e(r, t));
be(_e, "vec4", "DiffuseColor");
be(_e, "vec3", "EmissiveColor");
be(_e, "float", "Roughness");
be(_e, "float", "Metalness");
be(_e, "float", "Clearcoat");
be(_e, "float", "ClearcoatRoughness");
be(_e, "vec3", "Sheen");
be(_e, "float", "SheenRoughness");
be(_e, "float", "Iridescence");
be(_e, "float", "IridescenceIOR");
be(_e, "float", "IridescenceThickness");
be(_e, "float", "AlphaT");
be(_e, "float", "Anisotropy");
be(_e, "vec3", "AnisotropyT");
be(_e, "vec3", "AnisotropyB");
be(_e, "color", "SpecularColor");
be(_e, "float", "SpecularF90");
be(_e, "float", "Shininess");
be(_e, "vec4", "Output");
be(_e, "float", "dashSize");
be(_e, "float", "gapSize");
be(_e, "float", "pointWidth");
be(_e, "float", "IOR");
be(_e, "float", "Transmission");
be(_e, "float", "Thickness");
be(_e, "float", "AttenuationDistance");
be(_e, "color", "AttenuationColor");
be(_e, "float", "Dispersion");
fn("PropertyNode", _e);
class J_ extends oi {
    constructor(t, e, n=null)
    {
        super(),
        this.condNode = t,
        this.ifNode = e,
        this.elseNode = n
    }
    getNodeType(t)
    {
        const e = this.ifNode.getNodeType(t);
        if (this.elseNode !== null) {
            const n = this.elseNode.getNodeType(t);
            if (t.getTypeLength(n) > t.getTypeLength(e))
                return n
        }
        return e
    }
    setup(t)
    {
        const e = t.getNodeProperties(this);
        e.condNode = this.condNode.cache(),
        e.ifNode = this.ifNode.cache(),
        e.elseNode = this.elseNode ? this.elseNode.cache() : null
    }
    generate(t, e)
    {
        const n = this.getNodeType(t),
            i = t.getDataFromNode(this);
        if (i.nodeProperty !== void 0)
            return i.nodeProperty;
        const {condNode: s, ifNode: o, elseNode: a} = t.getNodeProperties(this),
            l = e !== "void",
            c = l ? OA(n).build(t) : "";
        i.nodeProperty = c;
        const h = s.build(t, "bool");
        t.addFlowCode(`
${t.tab}if ( ${h} ) {

`

        ).addFlowTab();
        let u = o.build(t, n);
        if (u && (l ? u = c + " = " + u + ";" : u = "return " + u + ";"), t.removeFlowTab().addFlowCode(t.tab + "	" + u + `

`

        + t.tab + "}"), a !== null) {
            t.addFlowCode(` else {

`

            ).addFlowTab();
            let d = a.build(t, n);
            d && (l ? d = c + " = " + d + ";" : d = "return " + d + ";"),
            t.removeFlowTab().addFlowCode(t.tab + "	" + d + `

`

            + t.tab + `}

`

            )
        } else
            t.addFlowCode(`

`

            );
        return t.format(c, n, e)
    }
}
const zA = pt(J_);
tt("cond", zA);
fn("CondNode", J_);
class Fe extends Ja {
    constructor(t, e, n, ...i)
    {
        if (super(), i.length > 0) {
            let s = new Fe(t, e, n);
            for (let o = 0; o < i.length - 1; o++)
                s = new Fe(t, s, i[o]);
            e = s,
            n = i[i.length - 1]
        }
        this.op = t,
        this.aNode = e,
        this.bNode = n
    }
    getNodeType(t, e)
    {
        const n = this.op,
            i = this.aNode,
            s = this.bNode,
            o = i.getNodeType(t),
            a = typeof s < "u" ? s.getNodeType(t) : null;
        if (o === "void" || a === "void")
            return "void";
        if (n === "%")
            return o;
        if (n === "~" || n === "&" || n === "|" || n === "^" || n === ">>" || n === "<<")
            return t.getIntegerType(o);
        if (n === "!" || n === "==" || n === "&&" || n === "||" || n === "^^")
            return "bool";
        if (n === "<" || n === ">" || n === "<=" || n === ">=") {
            const l = e ? t.getTypeLength(e) : Math.max(t.getTypeLength(o), t.getTypeLength(a));
            return l > 1 ? `bvec${l}` : "bool"
        } else
            return o === "float" && t.isMatrix(a) ? a : t.isMatrix(o) && t.isVector(a) ? t.getVectorFromMatrix(o) : t.isVector(o) && t.isMatrix(a) ? t.getVectorFromMatrix(a) : t.getTypeLength(a) > t.getTypeLength(o) ? a : o
    }
    generate(t, e)
    {
        const n = this.op,
            i = this.aNode,
            s = this.bNode,
            o = this.getNodeType(t, e);
        let a = null,
            l = null;
        o !== "void" ? (a = i.getNodeType(t), l = typeof s < "u" ? s.getNodeType(t) : null, n === "<" || n === ">" || n === "<=" || n === ">=" || n === "==" ? t.isVector(a) ? l = a : a = l = "float" : n === ">>" || n === "<<" ? (a = o, l = t.changeComponentType(l, "uint")) : t.isMatrix(a) && t.isVector(l) ? l = t.getVectorFromMatrix(a) : t.isVector(a) && t.isMatrix(l) ? a = t.getVectorFromMatrix(l) : a = l = o) : a = l = o;
        const c = i.build(t, a),
            h = typeof s < "u" ? s.build(t, l) : null,
            u = t.getTypeLength(e),
            d = t.getFunctionOperator(n);
        if (e !== "void")
            return n === "<" && u > 1 ? t.format(`${t.getMethod("lessThan")}( ${c}, ${h} )`, o, e) : n === "<=" && u > 1 ? t.format(`${t.getMethod("lessThanEqual")}( ${c}, ${h} )`, o, e) : n === ">" && u > 1 ? t.format(`${t.getMethod("greaterThan")}( ${c}, ${h} )`, o, e) : n === ">=" && u > 1 ? t.format(`${t.getMethod("greaterThanEqual")}( ${c}, ${h} )`, o, e) : n === "!" || n === "~" ? t.format(`(${n}${c})`, a, e) : d ? t.format(`${d}( ${c}, ${h} )`, o, e) : t.format(`( ${c} ${n} ${h} )`, o, e);
        if (a !== "void")
            return d ? t.format(`${d}( ${c}, ${h} )`, o, e) : t.format(`${c} ${n} ${h}`, o, e)
    }
    serialize(t)
    {
        super.serialize(t),
        t.op = this.op
    }
    deserialize(t)
    {
        super.deserialize(t),
        this.op = t.op
    }
}
const BA = pt(Fe, "+"),
    ed = pt(Fe, "-"),
    hf = pt(Fe, "*"),
    Q_ = pt(Fe, "/"),
    kA = pt(Fe, "%"),
    HA = pt(Fe, "=="),
    VA = pt(Fe, "!="),
    GA = pt(Fe, "<"),
    WA = pt(Fe, ">"),
    XA = pt(Fe, "<="),
    YA = pt(Fe, ">="),
    $A = pt(Fe, "&&"),
    qA = pt(Fe, "||"),
    KA = pt(Fe, "!"),
    jA = pt(Fe, "^^"),
    ZA = pt(Fe, "&"),
    JA = pt(Fe, "~"),
    QA = pt(Fe, "|"),
    tC = pt(Fe, "^"),
    eC = pt(Fe, "<<"),
    nC = pt(Fe, ">>");
tt("add", BA);
tt("sub", ed);
tt("mul", hf);
tt("div", Q_);
tt("remainder", kA);
tt("equal", HA);
tt("notEqual", VA);
tt("lessThan", GA);
tt("greaterThan", WA);
tt("lessThanEqual", XA);
tt("greaterThanEqual", YA);
tt("and", $A);
tt("or", qA);
tt("not", KA);
tt("xor", jA);
tt("bitAnd", ZA);
tt("bitNot", JA);
tt("bitOr", QA);
tt("bitXor", tC);
tt("shiftLeft", eC);
tt("shiftRight", nC);
fn("OperatorNode", Fe);
class B extends Ja {
    constructor(t, e, n=null, i=null)
    {
        super(),
        this.method = t,
        this.aNode = e,
        this.bNode = n,
        this.cNode = i
    }
    getInputType(t)
    {
        const e = this.aNode.getNodeType(t),
            n = this.bNode ? this.bNode.getNodeType(t) : null,
            i = this.cNode ? this.cNode.getNodeType(t) : null,
            s = t.isMatrix(e) ? 0 : t.getTypeLength(e),
            o = t.isMatrix(n) ? 0 : t.getTypeLength(n),
            a = t.isMatrix(i) ? 0 : t.getTypeLength(i);
        return s > o && s > a ? e : o > a ? n : a > s ? i : e
    }
    getNodeType(t)
    {
        const e = this.method;
        return e === B.LENGTH || e === B.DISTANCE || e === B.DOT ? "float" : e === B.CROSS ? "vec3" : e === B.ALL ? "bool" : e === B.EQUALS ? t.changeComponentType(this.aNode.getNodeType(t), "bool") : e === B.MOD ? this.aNode.getNodeType(t) : this.getInputType(t)
    }
    generate(t, e)
    {
        const n = this.method,
            i = this.getNodeType(t),
            s = this.getInputType(t),
            o = this.aNode,
            a = this.bNode,
            l = this.cNode,
            c = t.renderer.isWebGLRenderer === !0;
        if (n === B.TRANSFORM_DIRECTION) {
            let h = o,
                u = a;
            t.isMatrix(h.getNodeType(t)) ? u = td(Qu(u), 0) : h = td(Qu(h), 0);
            const d = hf(h, u).xyz;
            return t0(d).build(t, e)
        } else {
            if (n === B.NEGATE)
                return t.format("( - " + o.build(t, s) + " )", i, e);
            if (n === B.ONE_MINUS)
                return ed(1, o).build(t, e);
            if (n === B.RECIPROCAL)
                return Q_(1, o).build(t, e);
            if (n === B.DIFFERENCE)
                return uf(ed(o, a)).build(t, e);
            {
                const h = [];
                return n === B.CROSS || n === B.MOD ? h.push(o.build(t, i), a.build(t, i)) : n === B.STEP ? h.push(o.build(t, t.getTypeLength(o.getNodeType(t)) === 1 ? "float" : s), a.build(t, s)) : c && (n === B.MIN || n === B.MAX) || n === B.MOD ? h.push(o.build(t, s), a.build(t, t.getTypeLength(a.getNodeType(t)) === 1 ? "float" : s)) : n === B.REFRACT ? h.push(o.build(t, s), a.build(t, s), l.build(t, "float")) : n === B.MIX ? h.push(o.build(t, s), a.build(t, s), l.build(t, t.getTypeLength(l.getNodeType(t)) === 1 ? "float" : s)) : (h.push(o.build(t, s)), a !== null && h.push(a.build(t, s)), l !== null && h.push(l.build(t, s))), t.format(`${t.getMethod(n, i)}( ${h.join(", ")} )`, i, e)
            }
        }
    }
    serialize(t)
    {
        super.serialize(t),
        t.method = this.method
    }
    deserialize(t)
    {
        super.deserialize(t),
        this.method = t.method
    }
}
B.ALL = "all";
B.ANY = "any";
B.EQUALS = "equals";
B.RADIANS = "radians";
B.DEGREES = "degrees";
B.EXP = "exp";
B.EXP2 = "exp2";
B.LOG = "log";
B.LOG2 = "log2";
B.SQRT = "sqrt";
B.INVERSE_SQRT = "inversesqrt";
B.FLOOR = "floor";
B.CEIL = "ceil";
B.NORMALIZE = "normalize";
B.FRACT = "fract";
B.SIN = "sin";
B.COS = "cos";
B.TAN = "tan";
B.ASIN = "asin";
B.ACOS = "acos";
B.ATAN = "atan";
B.ABS = "abs";
B.SIGN = "sign";
B.LENGTH = "length";
B.NEGATE = "negate";
B.ONE_MINUS = "oneMinus";
B.DFDX = "dFdx";
B.DFDY = "dFdy";
B.ROUND = "round";
B.RECIPROCAL = "reciprocal";
B.TRUNC = "trunc";
B.FWIDTH = "fwidth";
B.BITCAST = "bitcast";
B.TRANSPOSE = "transpose";
B.ATAN2 = "atan2";
B.MIN = "min";
B.MAX = "max";
B.MOD = "mod";
B.STEP = "step";
B.REFLECT = "reflect";
B.DISTANCE = "distance";
B.DIFFERENCE = "difference";
B.DOT = "dot";
B.CROSS = "cross";
B.POW = "pow";
B.TRANSFORM_DIRECTION = "transformDirection";
B.MIX = "mix";
B.CLAMP = "clamp";
B.REFRACT = "refract";
B.SMOOTHSTEP = "smoothstep";
B.FACEFORWARD = "faceforward";
Qa(1e-6);
Qa(1e6);
const iC = Qa(Math.PI);
Qa(Math.PI * 2);
const sC = pt(B, B.ALL),
    rC = pt(B, B.ANY),
    oC = pt(B, B.EQUALS),
    aC = pt(B, B.RADIANS),
    lC = pt(B, B.DEGREES),
    cC = pt(B, B.EXP),
    hC = pt(B, B.EXP2),
    uC = pt(B, B.LOG),
    dC = pt(B, B.LOG2),
    fC = pt(B, B.SQRT),
    pC = pt(B, B.INVERSE_SQRT),
    mC = pt(B, B.FLOOR),
    gC = pt(B, B.CEIL),
    t0 = pt(B, B.NORMALIZE),
    e0 = pt(B, B.FRACT),
    n0 = pt(B, B.SIN),
    _C = pt(B, B.COS),
    xC = pt(B, B.TAN),
    vC = pt(B, B.ASIN),
    yC = pt(B, B.ACOS),
    MC = pt(B, B.ATAN),
    uf = pt(B, B.ABS),
    i0 = pt(B, B.SIGN),
    SC = pt(B, B.LENGTH),
    TC = pt(B, B.NEGATE),
    EC = pt(B, B.ONE_MINUS),
    bC = pt(B, B.DFDX),
    wC = pt(B, B.DFDY),
    AC = pt(B, B.ROUND),
    CC = pt(B, B.RECIPROCAL),
    RC = pt(B, B.TRUNC),
    PC = pt(B, B.FWIDTH);
pt(B, B.BITCAST);
const LC = pt(B, B.TRANSPOSE),
    DC = pt(B, B.ATAN2),
    NC = pt(B, B.MIN),
    IC = pt(B, B.MAX),
    s0 = pt(B, B.MOD),
    FC = pt(B, B.STEP),
    UC = pt(B, B.REFLECT),
    OC = pt(B, B.DISTANCE),
    zC = pt(B, B.DIFFERENCE),
    df = pt(B, B.DOT),
    BC = pt(B, B.CROSS),
    r0 = pt(B, B.POW),
    kC = pt(B, B.POW, 2),
    HC = pt(B, B.POW, 3),
    VC = pt(B, B.POW, 4),
    GC = pt(B, B.TRANSFORM_DIRECTION),
    WC = r => hf(i0(r), r0(uf(r), 1 / 3)),
    XC = r => df(r, r),
    YC = pt(B, B.MIX),
    o0 = (r, t=0, e=1) => Le(new B(B.CLAMP, Le(r), Le(t), Le(e))),
    $C = r => o0(r),
    qC = pt(B, B.REFRACT),
    KC = pt(B, B.SMOOTHSTEP),
    jC = pt(B, B.FACEFORWARD),
    ZC = j_(([r]) => {
        const n = 43758.5453,
            i = df(r.xy, Z_(12.9898, 78.233)),
            s = s0(i, iC);
        return e0(n0(s).mul(n))
    }),
    JC = (r, t, e) => YC(t, e, r),
    QC = (r, t, e) => KC(t, e, r);
tt("all", sC);
tt("any", rC);
tt("equals", oC);
tt("radians", aC);
tt("degrees", lC);
tt("exp", cC);
tt("exp2", hC);
tt("log", uC);
tt("log2", dC);
tt("sqrt", fC);
tt("inverseSqrt", pC);
tt("floor", mC);
tt("ceil", gC);
tt("normalize", t0);
tt("fract", e0);
tt("sin", n0);
tt("cos", _C);
tt("tan", xC);
tt("asin", vC);
tt("acos", yC);
tt("atan", MC);
tt("abs", uf);
tt("sign", i0);
tt("length", SC);
tt("lengthSq", XC);
tt("negate", TC);
tt("oneMinus", EC);
tt("dFdx", bC);
tt("dFdy", wC);
tt("round", AC);
tt("reciprocal", CC);
tt("trunc", RC);
tt("fwidth", PC);
tt("atan2", DC);
tt("min", NC);
tt("max", IC);
tt("mod", s0);
tt("step", FC);
tt("reflect", UC);
tt("distance", OC);
tt("dot", df);
tt("cross", BC);
tt("pow", r0);
tt("pow2", kC);
tt("pow3", HC);
tt("pow4", VC);
tt("transformDirection", GC);
tt("mix", JC);
tt("clamp", o0);
tt("refract", qC);
tt("smoothstep", QC);
tt("faceForward", jC);
tt("difference", zC);
tt("saturate", $C);
tt("cbrt", WC);
tt("transpose", LC);
tt("rand", ZC);
fn("MathNode", B);
class a0 extends oi {
    constructor(t=[], ...e)
    {
        super(),
        this.functionNodes = t,
        this.parametersNodes = e,
        this._candidateFnCall = null,
        this.global = !0
    }
    getNodeType()
    {
        return this.functionNodes[0].shaderNode.layout.type
    }
    setup(t)
    {
        const e = this.parametersNodes;
        let n = this._candidateFnCall;
        if (n === null) {
            let i = null,
                s = -1;
            for (const o of this.functionNodes) {
                const l = o.shaderNode.layout;
                if (l === null)
                    throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
                const c = l.inputs;
                if (e.length === c.length) {
                    let h = 0;
                    for (let u = 0; u < e.length; u++) {
                        const d = e[u],
                            f = c[u];
                        d.getNodeType(t) === f.type ? h++ : h = 0
                    }
                    h > s && (i = o, s = h)
                }
            }
            this._candidateFnCall = n = i(...e)
        }
        return n
    }
}
pt(a0);
fn("FunctionOverloadingNode", a0);
class l0 extends oi {
    constructor(t="", e="void")
    {
        super(e),
        this.snippet = t
    }
    generate(t, e)
    {
        const n = this.getNodeType(t),
            i = this.snippet;
        if (n === "void")
            t.addLineFlowCode(i);
        else
            return t.format(`( ${i} )`, n, e)
    }
}
const tR = pt(l0);
fn("ExpressionNode", l0);
class c0 extends oi {
    constructor(t, e)
    {
        super(),
        this.isBypassNode = !0,
        this.outputNode = t,
        this.callNode = e
    }
    getNodeType(t)
    {
        return this.outputNode.getNodeType(t)
    }
    generate(t)
    {
        const e = this.callNode.build(t, "void");
        return e !== "" && t.addLineFlowCode(e), this.outputNode.build(t)
    }
}
const h0 = pt(c0);
tt("bypass", h0);
fn("BypassNode", c0);
class u0 extends oi {
    constructor(t=[])
    {
        super(),
        this.params = t
    }
    getVarName(t)
    {
        return String.fromCharCode(105 + t)
    }
    getProperties(t)
    {
        const e = t.getNodeProperties(this);
        if (e.stackNode !== void 0)
            return e;
        const n = {};
        for (let s = 0, o = this.params.length - 1; s < o; s++) {
            const a = this.params[s],
                l = a.isNode !== !0 && a.name || this.getVarName(s),
                c = a.isNode !== !0 && a.type || "int";
            n[l] = tR(l, c)
        }
        const i = t.addStack();
        return e.returnsNode = this.params[this.params.length - 1](n, i, t), e.stackNode = i, t.removeStack(), e
    }
    getNodeType(t)
    {
        const {returnsNode: e} = this.getProperties(t);
        return e ? e.getNodeType(t) : "void"
    }
    setup(t)
    {
        this.getProperties(t)
    }
    generate(t)
    {
        const e = this.getProperties(t),
            n = this.params,
            i = e.stackNode;
        for (let a = 0, l = n.length - 1; a < l; a++) {
            const c = n[a];
            let h = null,
                u = null,
                d = null,
                f = null,
                m = null,
                _ = null;
            c.isNode ? (f = "int", d = this.getVarName(a), h = "0", u = c.build(t, f), m = "<") : (f = c.type || "int", d = c.name || this.getVarName(a), h = c.start, u = c.end, m = c.condition, _ = c.update, typeof h == "number" ? h = h.toString() : h && h.isNode && (h = h.build(t, f)), typeof u == "number" ? u = u.toString() : u && u.isNode && (u = u.build(t, f)), h !== void 0 && u === void 0 ? (h = h + " - 1", u = "0", m = ">=") : u !== void 0 && h === void 0 && (h = "0", m = "<"), m === void 0 && (Number(h) > Number(u) ? m = ">=" : m = "<"));
            const g = {
                    start: h,
                    end: u,
                    condition: m
                },
                p = g.start,
                x = g.end;
            let v = "",
                y = "",
                C = "";
            _ || (f === "int" || f === "uint" ? m.includes("<") ? _ = "++" : _ = "--" : m.includes("<") ? _ = "+= 1." : _ = "-= 1."),
            v += t.getVar(f, d) + " = " + p,
            y += d + " " + m + " " + x,
            C += d + " " + _;
            const A = `for ( ${v}; ${y}; ${C} )`;
            t.addFlowCode((a === 0 ? `
`
            : "") + t.tab + A + ` {

`

            ).addFlowTab()
        }
        const s = i.build(t, "void"),
            o = e.returnsNode ? e.returnsNode.build(t) : "";
        t.removeFlowTab().addFlowCode(`
`
        + t.tab + s);
        for (let a = 0, l = this.params.length - 1; a < l; a++)
            t.addFlowCode((a === 0 ? "" : t.tab) + `}

`

            ).removeFlowTab();
        return t.addFlowTab(), o
    }
}
const eR = (...r) => Le(new u0(Ma(r, "int"))).append();
tt("loop", (r, ...t) => h0(r, eR(...t)));
fn("LoopNode", u0);
class nR {
    constructor(t)
    {
        this.container = t.dom,
        this.lenis = t.lenis,
        this.width = window.innerWidth,
        this.height = window.innerHeight,
        this.currentRotation = this.targetRotation = 0,
        this.lastScroll = this.lastTime = 0,
        this.scrollDirection = 1,
        this.initialY = 0,
        this.index = 0,
        this.setup(),
        this.addEventListeners()
    }
    addEventListeners() {}
    removeEventListeners() {}
    onScroll(t)
    {
        this.extraY = window.scrollY / window.innerHeight * this.viewport.height
    }
    onResize()
    {
        this.width = window.innerWidth,
        this.height = window.innerHeight,
        this.camera.aspect = this.width / this.height,
        this.renderer.setSize(this.width, this.height),
        this.camera.updateProjectionMatrix(),
        this.updateObjectsPositionAndScale()
    }
    setup()
    {
        this.renderer = new wg({
            antialias: !0,
            alpha: !0
        }),
        this.renderer.setSize(this.width, this.height),
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 3)),
        this.container.appendChild(this.renderer.domElement),
        this.camera = new yn(50, this.width / this.height, 1, 10),
        this.camera.position.z = -2,
        this.scene = new Ag,
        this.textureLoader = new Fg,
        this.controls = new ZE(this.camera, this.renderer.domElement),
        this.controls.enableZoom = !1,
        this.controls.enablePan = !1,
        this.controls.enableDamping = !0;
        const t = 2 * Math.tan(this.camera.fov / 180 * Math.PI / 2) * -this.camera.position.z,
            e = t * this.camera.aspect;
        this.viewport = {
            height: t,
            width: e
        },
        this.loader = new db,
        this.matcap = this.textureLoader.load(x1),
        this.matcapMaterial = new vE,
        this.matcapMaterial.matcap = this.matcap,
        this.matcapMaterial.depthTest = !1,
        this.matcapMaterial.side = wi
    }
    addObjects()
    {
        this.objects = new ds,
        this.scene.add(this.objects),
        this.symbolContainers = document.querySelectorAll(".fSymbol"),
        this.symbolContainers.forEach(t => {
            this.loader.load(_1, (function(e) {
                this.symbol = e.scene.children[0],
                this.symbol.material = this.matcapMaterial,
                this.symbol.geometry.center(),
                this.symbol.rotation.x = Math.PI / 2,
                this.objects.add(this.symbol),
                this.updateObjectsPositionAndScale()
            }).bind(this))
        })
    }
    removeObjects()
    {
        this.scene.traverse(t => {
            this.scene.remove(t),
            t.geometry && t.geometry.dispose(),
            t.material && (Array.isArray(t.material) ? t.material.forEach(e => e.dispose()) : t.material.dispose()),
            t.texture && t.texture.dispose()
        }),
        this.objects = new ds
    }
    updateObjectsPositionAndScale()
    {
        const t = 2 * Math.tan(this.camera.fov / 180 * Math.PI / 2) * -this.camera.position.z,
            e = t * this.camera.aspect;
        this.viewport = {
            height: t,
            width: e
        },
        this.initialY = window.scrollY,
        this.objects.children.forEach((n, i) => {
            const s = this.symbolContainers[i].getBoundingClientRect(),
                o = (s.x + .5 * s.width) / window.innerWidth * this.viewport.width - .5 * this.viewport.width,
                a = (s.y + .5 * s.height) / window.innerHeight * this.viewport.height - .5 * this.viewport.height,
                l = s.height / window.innerHeight * this.viewport.height * .4;
            n.position.x = -o,
            n.position.y = -a,
            n.scale.set(l, l, l)
        })
    }
    animate(t)
    {
        this.extraY = (window.scrollY - this.initialY) / window.innerHeight * this.viewport.height,
        this.objects.position.y = this.extraY;
        const e = t - this.lastTime,
            n = this.lenis.animatedScroll - this.lastScroll;
        this.lastScroll < this.lenis.animatedScroll ? this.scrollDirection = 1 : this.lastScroll > this.lenis.animatedScroll && (this.scrollDirection = -1),
        this.symbol && (this.targetRotation += e * .001 * this.scrollDirection + n * .01, this.currentRotation = on.utils.interpolate(this.currentRotation, this.targetRotation, .05)),
        this.objects.children.forEach(i => {
            i.rotation.z = this.currentRotation
        }),
        this.lastScroll = this.lenis.animatedScroll,
        this.lastTime = t,
        this.controls.update(),
        this.renderer.render(this.scene, this.camera)
    }
    show()
    {
        return new Promise(t => {
            on.fromTo(this.container, {
                maskImage: "linear-gradient(90deg, rgba(0, 0, 0, 1) -20%, rgba(0, 0, 0, 0) 0%, rgba(255, 255, 255, 0) 120%)"
            }, {
                duration: 1.5,
                ease: "expo.inOut",
                onComplete: t,
                maskImage: "linear-gradient(90deg, rgba(0, 0, 0, 1) 100%, rgba(0, 0, 0, 0) 120%, rgba(255, 255, 255, 0) 120%)"
            })
        })
    }
    hide()
    {
        return new Promise(t => {
            on.fromTo(this.container, {
                maskImage: "linear-gradient(90deg, rgba(0, 0, 0, 0) -20%, rgba(0, 0, 0, 1) -0%, rgba(255, 255, 255, 1) 120%)"
            }, {
                duration: 1.5,
                ease: "expo.inOut",
                onComplete: t,
                maskImage: "linear-gradient(90deg, rgba(0, 0, 0, 0) 100%, rgba(0, 0, 0, 1) 120%, rgba(255, 255, 255, 1) 120%)"
            })
        })
    }
}
class iR {
    constructor() {}
    show({color: t})
    {
        return this.color = t, new Promise(e => {
            on.set(this.element, {
                rotation: 0
            }),
            on.to(this, {
                duration: 1.5,
                ease: "expo.inOut",
                onComplete: e,
                onUpdate: this.onUpdate.bind(this),
                progress: 1
            })
        })
    }
    hide()
    {
        return new Promise(t => {
            on.set(this.element, {
                rotation: 180
            }),
            on.to(this, {
                duration: 1.5,
                ease: "expo.inOut",
                onComplete: t,
                onUpdate: this.onUpdate.bind(this),
                progress: 0
            })
        })
    }
    onUpdate() {}
}
class Lr {
    constructor()
    {
        this.content = document.querySelector(".content")
    }
    show()
    {
        return new Promise(t => {
            on.fromTo(this.content, {
                maskImage: "linear-gradient(90deg, rgba(0, 0, 0, 1) -20%, rgba(0, 0, 0, 0) 0%, rgba(255, 255, 255, 0) 120%)"
            }, {
                duration: 1.5,
                ease: "expo.inOut",
                onComplete: t,
                maskImage: "linear-gradient(90deg, rgba(0, 0, 0, 1) 100%, rgba(0, 0, 0, 0) 120%, rgba(255, 255, 255, 0) 120%)"
            })
        })
    }
    hide()
    {
        return new Promise(t => {
            on.fromTo(this.content, {
                maskImage: "linear-gradient(90deg, rgba(0, 0, 0, 0) -20%, rgba(0, 0, 0, 1) -0%, rgba(255, 255, 255, 1) 120%)"
            }, {
                duration: 1.5,
                ease: "expo.inOut",
                onComplete: t,
                maskImage: "linear-gradient(90deg, rgba(0, 0, 0, 0) 100%, rgba(0, 0, 0, 1) 120%, rgba(255, 255, 255, 1) 120%)"
            })
        })
    }
}
class sR extends Lr {
    constructor()
    {
        super()
    }
    addSymbols() {}
    removeSymbols() {}
    addEventListeners(t) {}
    update() {}
    create() {}
    destroy()
    {
        this.removeSymbols()
    }
}
class d0 {
    constructor(t)
    {
        this.wrapper = document.querySelector(t),
        this.container = this.wrapper.parentNode,
        this.wrapperWidth = this.wrapper.offsetWidth,
        this.sliders = this.wrapper.querySelectorAll(".work__slider"),
        this.sliderWidth = this.sliders[0].offsetWidth,
        this.wrapper.style.height = this.sliders[0].offsetHeight + "px",
        this.cloneSlider(),
        this.slides = this.wrapper.querySelectorAll(".work__slide"),
        this.slideWidth = this.slides[0].offsetWidth,
        this.cursor = document.getElementById("gallery__cursor"),
        this.cursorX = 0,
        this.cursorY = 0,
        this.startX = this.currentX = this.lastX = 0,
        this.currentOffset = this.startOffset = this.targetOffset = 0,
        this.velocity = 0,
        this.maxVelocity = 100,
        this.friction = .97,
        this.lastTime = 0,
        this.hasSwiped = !1,
        this.clicked = !1,
        this.onLoad()
    }
    onLoad()
    {
        this.image = this.sliders[0].querySelector("img"),
        this.image.complete ? this.onResize() : this.image.addEventListener("load", this.onResize.bind(this))
    }
    addEventListeners()
    {
        this.container.addEventListener("mousedown", this.onMouseDown.bind(this)),
        this.container.addEventListener("mousemove", this.onMouseMove.bind(this)),
        this.container.addEventListener("mouseup", this.onMouseUp.bind(this)),
        this.container.addEventListener("mouseleave", this.onMouseUp.bind(this)),
        this.container.addEventListener("touchstart", this.onMouseDown.bind(this)),
        this.container.addEventListener("touchmove", this.onMouseMove.bind(this)),
        this.container.addEventListener("touchend", this.onMouseUp.bind(this)),
        this.container.addEventListener("mouseenter", this.onMouseEnter.bind(this))
    }
    removeEventListeners()
    {
        this.container.removeEventListener("mousedown", this.onMouseDown.bind(this)),
        this.container.removeEventListener("mousemove", this.onMouseMove.bind(this)),
        this.container.removeEventListener("mouseup", this.onMouseUp.bind(this)),
        this.container.removeEventListener("mouseleave", this.onMouseUp.bind(this)),
        this.container.removeEventListener("touchstart", this.onMouseDown.bind(this)),
        this.container.removeEventListener("touchmove", this.onMouseMove.bind(this)),
        this.container.removeEventListener("touchend", this.onMouseUp.bind(this)),
        this.container.removeEventListener("mouseenter", this.onMouseEnter.bind(this))
    }
    onMouseEnter(t)
    {
        this.cursorX = t.clientX,
        this.cursorY = t.clientY,
        this.cursor.style.left = `${this.cursorX}px`,
        this.cursor.style.top = `${this.cursorY}px`
    }
    onResize()
    {
        this.sliderWidth = this.sliders[0].offsetWidth,
        this.wrapper.style.height = this.sliders[0].offsetHeight + "px",
        window.innerWidth > 650 && (this.currentOffset = this.startOffset = this.targetOffset = (this.wrapperWidth - this.slideWidth) / 2, this.sliders[0].style.left = `${-this.currentOffset - this.sliderWidth}px`, this.sliders[1].style.left = `${-this.currentOffset}px`, this.sliders[2].style.left = `${-this.currentOffset + this.sliderWidth}px`)
    }
    cloneSlider()
    {
        const t = this.sliders[0].cloneNode(!0),
            e = this.sliders[0].cloneNode(!0);
        t.style.left = `${-this.sliderWidth}px`,
        e.style.left = `${this.sliderWidth}px`,
        this.wrapper.insertBefore(t, this.sliders[0]),
        this.wrapper.appendChild(e),
        this.sliders = this.wrapper.querySelectorAll(".work__slider")
    }
    updateSliderPosition()
    {
        this.wrapper.style.transform = `translateX(${this.currentOffset}px)`
    }
    lerp(t, e, n)
    {
        return Math.abs(t - e) < .1 ? e : t + (e - t) * n
    }
    getScaleFactor(t, e)
    {
        let n = 3;
        const i = this.slides[1].offsetWidth;
        let s = .2,
            o = window.innerWidth * .3;
        e < i && (s = 0, n = 3, o = (i - e) * 3);
        const a = (e + 2 * o) / n;
        return t < 0 - o || t > e + o ? s : t + o < a ? this.lerp(s, 1, (t + o) / a) : t + o < (n - 1) * a ? 1 : this.lerp(1, s, (t - (n - 1) * a + o) / a)
    }
    updateSlidesScale()
    {
        this.slides.forEach(t => {
            const e = t.getBoundingClientRect(),
                n = e.left + e.width / 2,
                i = this.getScaleFactor(n, window.innerWidth);
            t.style.transform = `scale(${i})`
        })
    }
    onMouseDown(t)
    {
        this.isDragging = !0,
        this.startX = t.pageX || t.touches[0].pageX,
        this.wrapper.style.cursor = "grabbing",
        this.startOffset = this.currentOffset,
        this.velocity = 0,
        this.lastTime = Date.now(),
        this.clicked = !0
    }
    onMouseMove(t)
    {
        if (t.touches === void 0 || t.touches.length == 0 ? (this.cursorX = t.clientX, this.cursorY = t.clientY) : (this.cursorX = t.touches[0].clientX, this.cursorY = t.touches[0].clientY), !this.isDragging)
            return;
        t.touches === void 0 || t.touches.length == 0 ? this.currentX = t.pageX : this.currentX = t.touches[0].pageX;
        const e = this.currentX - this.startX;
        this.targetOffset = this.startOffset + e;
        const n = Date.now(),
            i = n - this.lastTime;
        this.lastTime = n,
        Math.abs(this.lastX - this.currentX) < 1 ? this.velocity = 0 : this.velocity = on.utils.clamp(-this.maxVelocity, this.maxVelocity, e * .5 / i),
        this.lastX = this.currentX,
        this.clicked = !1
    }
    onMouseUp(t)
    {
        if (this.clicked) {
            const i = t.target.parentNode;
            if (i.classList.contains("work__slide")) {
                const s = i.querySelector("a");
                s && s.click()
            }
            this.clicked = !1
        }
        this.isDragging = !1,
        this.wrapper.style.cursor = "pointer";
        const e = Date.now(),
            n = e - this.lastTime;
        this.lastTime = e,
        n > 50 && (this.velocity = 0)
    }
    update()
    {
        if (this.isDragging || (this.targetOffset += this.velocity), this.targetOffset > this.currentOffset) {
            let n = Array.from(this.sliders).reduce((s, o) => {
                    const a = parseFloat(o.style.left),
                        l = parseFloat(s.style.left);
                    return a < l ? o : s
                }),
                i = Array.from(this.sliders).find(s => parseFloat(s.style.left) + this.currentOffset > window.innerWidth);
            if (i) {
                const s = parseFloat(n.style.left) - this.sliderWidth;
                i.style.left = `${s}px`
            }
        } else if (this.targetOffset < this.currentOffset) {
            let n = Array.from(this.sliders).reduce((s, o) => {
                const a = parseFloat(o.style.left),
                    l = parseFloat(s.style.left);
                return a > l ? o : s
            });
            const i = Array.from(this.sliders).find(s => {
                const o = parseFloat(s.style.left),
                    a = s.offsetWidth;
                return o + this.currentOffset + a < 0
            });
            if (i) {
                const s = parseFloat(n.style.left) + this.sliderWidth;
                i.style.left = `${s}px`
            }
        }
        let t = this.lerp(parseFloat(this.cursor.style.left || 0), this.cursorX, .1),
            e = this.lerp(parseFloat(this.cursor.style.top || 0), this.cursorY, .1);
        this.cursor.style.left = `${t}px`,
        this.cursor.style.top = `${e}px`,
        this.velocity *= this.friction,
        this.currentOffset = this.lerp(this.currentOffset, this.targetOffset, .1),
        this.updateSliderPosition(),
        this.updateSlidesScale()
    }
}
function rR(r, t) {
    for (var e = 0; e < t.length; e++) {
        var n = t[e];
        n.enumerable = n.enumerable || !1,
        n.configurable = !0,
        "value" in n && (n.writable = !0),
        Object.defineProperty(r, n.key, n)
    }
}
function oR(r, t, e) {
    return t && rR(r.prototype, t), r
} /*!
 * Observer 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/







var un,
    ec,
    ni,
    Gs,
    Ws,
    yo,
    f0,
    hr,
    Sa,
    p0,
    fs,
    Ei,
    m0,
    g0 = function() {
        return un || typeof window < "u" && (un = window.gsap) && un.registerPlugin && un
    },
    _0 = 1,
    ho = [],
    oe = [],
    Gi = [],
    Ta = Date.now,
    nd = function(t, e) {
        return e
    },
    aR = function() {
        var t = Sa.core,
            e = t.bridge || {},
            n = t._scrollers,
            i = t._proxies;
        n.push.apply(n, oe),
        i.push.apply(i, Gi),
        oe = n,
        Gi = i,
        nd = function(o, a) {
            return e[o](a)
        }
    },
    qs = function(t, e) {
        return ~Gi.indexOf(t) && Gi[Gi.indexOf(t) + 1][e]
    },
    Ea = function(t) {
        return !!~p0.indexOf(t)
    },
    wn = function(t, e, n, i, s) {
        return t.addEventListener(e, n, {
            passive: i !== !1,
            capture: !!s
        })
    },
    bn = function(t, e, n, i) {
        return t.removeEventListener(e, n, !!i)
    },
    Nl = "scrollLeft",
    Il = "scrollTop",
    id = function() {
        return fs && fs.isPressed || oe.cache++
    },
    Ec = function(t, e) {
        var n = function i(s) {
            if (s || s === 0) {
                _0 && (ni.history.scrollRestoration = "manual");
                var o = fs && fs.isPressed;
                s = i.v = Math.round(s) || (fs && fs.iOS ? 1 : 0),
                t(s),
                i.cacheID = oe.cache,
                o && nd("ss", s)
            } else
                (e || oe.cache !== i.cacheID || nd("ref")) && (i.cacheID = oe.cache, i.v = t());
            return i.v + i.offset
        };
        return n.offset = 0, t && n
    },
    Nn = {
        s: Nl,
        p: "left",
        p2: "Left",
        os: "right",
        os2: "Right",
        d: "width",
        d2: "Width",
        a: "x",
        sc: Ec(function(r) {
            return arguments.length ? ni.scrollTo(r, Je.sc()) : ni.pageXOffset || Gs[Nl] || Ws[Nl] || yo[Nl] || 0
        })
    },
    Je = {
        s: Il,
        p: "top",
        p2: "Top",
        os: "bottom",
        os2: "Bottom",
        d: "height",
        d2: "Height",
        a: "y",
        op: Nn,
        sc: Ec(function(r) {
            return arguments.length ? ni.scrollTo(Nn.sc(), r) : ni.pageYOffset || Gs[Il] || Ws[Il] || yo[Il] || 0
        })
    },
    Bn = function(t, e) {
        return (e && e._ctx && e._ctx.selector || un.utils.toArray)(t)[0] || (typeof t == "string" && un.config().nullTargetWarn !== !1 ? console.warn("Element not found:", t) : null)
    },
    Zs = function(t, e) {
        var n = e.s,
            i = e.sc;
        Ea(t) && (t = Gs.scrollingElement || Ws);
        var s = oe.indexOf(t),
            o = i === Je.sc ? 1 : 2;
        !~s && (s = oe.push(t) - 1),
        oe[s + o] || wn(t, "scroll", id);
        var a = oe[s + o],
            l = a || (oe[s + o] = Ec(qs(t, n), !0) || (Ea(t) ? i : Ec(function(c) {
                return arguments.length ? t[n] = c : t[n]
            })));
        return l.target = t, a || (l.smooth = un.getProperty(t, "scrollBehavior") === "smooth"), l
    },
    sd = function(t, e, n) {
        var i = t,
            s = t,
            o = Ta(),
            a = o,
            l = e || 50,
            c = Math.max(500, l * 3),
            h = function(m, _) {
                var g = Ta();
                _ || g - o > l ? (s = i, i = m, a = o, o = g) : n ? i += m : i = s + (m - s) / (g - a) * (o - a)
            },
            u = function() {
                s = i = n ? 0 : i,
                a = o = 0
            },
            d = function(m) {
                var _ = a,
                    g = s,
                    p = Ta();
                return (m || m === 0) && m !== i && h(m), o === a || p - a > c ? 0 : (i + (n ? g : -g)) / ((n ? p : o) - _) * 1e3
            };
        return {
            update: h,
            reset: u,
            getVelocity: d
        }
    },
    ia = function(t, e) {
        return e && !t._gsapAllow && t.preventDefault(), t.changedTouches ? t.changedTouches[0] : t
    },
    bm = function(t) {
        var e = Math.max.apply(Math, t),
            n = Math.min.apply(Math, t);
        return Math.abs(e) >= Math.abs(n) ? e : n
    },
    x0 = function() {
        Sa = un.core.globals().ScrollTrigger,
        Sa && Sa.core && aR()
    },
    v0 = function(t) {
        return un = t || g0(), !ec && un && typeof document < "u" && document.body && (ni = window, Gs = document, Ws = Gs.documentElement, yo = Gs.body, p0 = [ni, Gs, Ws, yo], un.utils.clamp, m0 = un.core.context || function() {}, hr = "onpointerenter" in yo ? "pointer" : "mouse", f0 = We.isTouch = ni.matchMedia && ni.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in ni || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Ei = We.eventTypes = ("ontouchstart" in Ws ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Ws ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
            return _0 = 0
        }, 500), x0(), ec = 1), ec
    };
Nn.op = Je;
oe.cache = 0;
var We = function() {
    function r(e) {
        this.init(e)
    }
    var t = r.prototype;
    return t.init = function(n) {
        ec || v0(un) || console.warn("Please gsap.registerPlugin(Observer)"),
        Sa || x0();
        var i = n.tolerance,
            s = n.dragMinimum,
            o = n.type,
            a = n.target,
            l = n.lineHeight,
            c = n.debounce,
            h = n.preventDefault,
            u = n.onStop,
            d = n.onStopDelay,
            f = n.ignore,
            m = n.wheelSpeed,
            _ = n.event,
            g = n.onDragStart,
            p = n.onDragEnd,
            x = n.onDrag,
            v = n.onPress,
            y = n.onRelease,
            C = n.onRight,
            A = n.onLeft,
            T = n.onUp,
            R = n.onDown,
            E = n.onChangeX,
            M = n.onChangeY,
            D = n.onChange,
            I = n.onToggleX,
            k = n.onToggleY,
            $ = n.onHover,
            j = n.onHoverEnd,
            G = n.onMove,
            H = n.ignoreCheck,
            V = n.isNormalizer,
            nt = n.onGestureStart,
            P = n.onGestureEnd,
            ct = n.onWheel,
            Ut = n.onEnable,
            Zt = n.onDisable,
            J = n.onClick,
            it = n.scrollSpeed,
            ft = n.capture,
            ut = n.allowClicks,
            Pt = n.lockAxis,
            Nt = n.onLockAxis;
        this.target = a = Bn(a) || Ws,
        this.vars = n,
        f && (f = un.utils.toArray(f)),
        i = i || 1e-9,
        s = s || 0,
        m = m || 1,
        it = it || 1,
        o = o || "wheel,touch,pointer",
        c = c !== !1,
        l || (l = parseFloat(ni.getComputedStyle(yo).lineHeight) || 22);
        var Kt,
            Jt,
            N,
            zt,
            Bt,
            jt,
            yt,
            q = this,
            Lt = 0,
            kt = 0,
            L = n.passive || !h,
            b = Zs(a, Nn),
            K = Zs(a, Je),
            st = b(),
            rt = K(),
            Q = ~o.indexOf("touch") && !~o.indexOf("pointer") && Ei[0] === "pointerdown",
            At = Ea(a),
            at = a.ownerDocument || Gs,
            dt = [0, 0, 0],
            Ot = [0, 0, 0],
            lt = 0,
            xt = function() {
                return lt = Ta()
            },
            It = function(Mt, Qt) {
                return (q.event = Mt) && f && ~f.indexOf(Mt.target) || Qt && Q && Mt.pointerType !== "touch" || H && H(Mt, Qt)
            },
            Xt = function() {
                q._vx.reset(),
                q._vy.reset(),
                Jt.pause(),
                u && u(q)
            },
            vt = function() {
                var Mt = q.deltaX = bm(dt),
                    Qt = q.deltaY = bm(Ot),
                    ht = Math.abs(Mt) >= i,
                    $t = Math.abs(Qt) >= i;
                D && (ht || $t) && D(q, Mt, Qt, dt, Ot),
                ht && (C && q.deltaX > 0 && C(q), A && q.deltaX < 0 && A(q), E && E(q), I && q.deltaX < 0 != Lt < 0 && I(q), Lt = q.deltaX, dt[0] = dt[1] = dt[2] = 0),
                $t && (R && q.deltaY > 0 && R(q), T && q.deltaY < 0 && T(q), M && M(q), k && q.deltaY < 0 != kt < 0 && k(q), kt = q.deltaY, Ot[0] = Ot[1] = Ot[2] = 0),
                (zt || N) && (G && G(q), N && (x(q), N = !1), zt = !1),
                jt && !(jt = !1) && Nt && Nt(q),
                Bt && (ct(q), Bt = !1),
                Kt = 0
            },
            Wt = function(Mt, Qt, ht) {
                dt[ht] += Mt,
                Ot[ht] += Qt,
                q._vx.update(Mt),
                q._vy.update(Qt),
                c ? Kt || (Kt = requestAnimationFrame(vt)) : vt()
            },
            Yt = function(Mt, Qt) {
                Pt && !yt && (q.axis = yt = Math.abs(Mt) > Math.abs(Qt) ? "x" : "y", jt = !0),
                yt !== "y" && (dt[2] += Mt, q._vx.update(Mt, !0)),
                yt !== "x" && (Ot[2] += Qt, q._vy.update(Qt, !0)),
                c ? Kt || (Kt = requestAnimationFrame(vt)) : vt()
            },
            de = function(Mt) {
                if (!It(Mt, 1)) {
                    Mt = ia(Mt, h);
                    var Qt = Mt.clientX,
                        ht = Mt.clientY,
                        $t = Qt - q.x,
                        Dt = ht - q.y,
                        qt = q.isDragging;
                    q.x = Qt,
                    q.y = ht,
                    (qt || Math.abs(q.startX - Qt) >= s || Math.abs(q.startY - ht) >= s) && (x && (N = !0), qt || (q.isDragging = !0), Yt($t, Dt), qt || g && g(q))
                }
            },
            S = q.onPress = function(Ct) {
                It(Ct, 1) || Ct && Ct.button || (q.axis = yt = null, Jt.pause(), q.isPressed = !0, Ct = ia(Ct), Lt = kt = 0, q.startX = q.x = Ct.clientX, q.startY = q.y = Ct.clientY, q._vx.reset(), q._vy.reset(), wn(V ? a : at, Ei[1], de, L, !0), q.deltaX = q.deltaY = 0, v && v(q))
            },
            F = q.onRelease = function(Ct) {
                if (!It(Ct, 1)) {
                    bn(V ? a : at, Ei[1], de, !0);
                    var Mt = !isNaN(q.y - q.startY),
                        Qt = q.isDragging,
                        ht = Qt && (Math.abs(q.x - q.startX) > 3 || Math.abs(q.y - q.startY) > 3),
                        $t = ia(Ct);
                    !ht && Mt && (q._vx.reset(), q._vy.reset(), h && ut && un.delayedCall(.08, function() {
                        if (Ta() - lt > 300 && !Ct.defaultPrevented) {
                            if (Ct.target.click)
                                Ct.target.click();
                            else if (at.createEvent) {
                                var Dt = at.createEvent("MouseEvents");
                                Dt.initMouseEvent("click", !0, !0, ni, 1, $t.screenX, $t.screenY, $t.clientX, $t.clientY, !1, !1, !1, !1, 0, null),
                                Ct.target.dispatchEvent(Dt)
                            }
                        }
                    })),
                    q.isDragging = q.isGesturing = q.isPressed = !1,
                    u && Qt && !V && Jt.restart(!0),
                    p && Qt && p(q),
                    y && y(q, ht)
                }
            },
            Y = function(Mt) {
                return Mt.touches && Mt.touches.length > 1 && (q.isGesturing = !0) && nt(Mt, q.isDragging)
            },
            Z = function() {
                return (q.isGesturing = !1) || P(q)
            },
            et = function(Mt) {
                if (!It(Mt)) {
                    var Qt = b(),
                        ht = K();
                    Wt((Qt - st) * it, (ht - rt) * it, 1),
                    st = Qt,
                    rt = ht,
                    u && Jt.restart(!0)
                }
            },
            Tt = function(Mt) {
                if (!It(Mt)) {
                    Mt = ia(Mt, h),
                    ct && (Bt = !0);
                    var Qt = (Mt.deltaMode === 1 ? l : Mt.deltaMode === 2 ? ni.innerHeight : 1) * m;
                    Wt(Mt.deltaX * Qt, Mt.deltaY * Qt, 0),
                    u && !V && Jt.restart(!0)
                }
            },
            Ht = function(Mt) {
                if (!It(Mt)) {
                    var Qt = Mt.clientX,
                        ht = Mt.clientY,
                        $t = Qt - q.x,
                        Dt = ht - q.y;
                    q.x = Qt,
                    q.y = ht,
                    zt = !0,
                    u && Jt.restart(!0),
                    ($t || Dt) && Yt($t, Dt)
                }
            },
            Te = function(Mt) {
                q.event = Mt,
                $(q)
            },
            xe = function(Mt) {
                q.event = Mt,
                j(q)
            },
            ne = function(Mt) {
                return It(Mt) || ia(Mt, h) && J(q)
            };
        Jt = q._dc = un.delayedCall(d || .25, Xt).pause(),
        q.deltaX = q.deltaY = 0,
        q._vx = sd(0, 50, !0),
        q._vy = sd(0, 50, !0),
        q.scrollX = b,
        q.scrollY = K,
        q.isDragging = q.isGesturing = q.isPressed = !1,
        m0(this),
        q.enable = function(Ct) {
            return q.isEnabled || (wn(At ? at : a, "scroll", id), o.indexOf("scroll") >= 0 && wn(At ? at : a, "scroll", et, L, ft), o.indexOf("wheel") >= 0 && wn(a, "wheel", Tt, L, ft), (o.indexOf("touch") >= 0 && f0 || o.indexOf("pointer") >= 0) && (wn(a, Ei[0], S, L, ft), wn(at, Ei[2], F), wn(at, Ei[3], F), ut && wn(a, "click", xt, !0, !0), J && wn(a, "click", ne), nt && wn(at, "gesturestart", Y), P && wn(at, "gestureend", Z), $ && wn(a, hr + "enter", Te), j && wn(a, hr + "leave", xe), G && wn(a, hr + "move", Ht)), q.isEnabled = !0, Ct && Ct.type && S(Ct), Ut && Ut(q)), q
        },
        q.disable = function() {
            q.isEnabled && (ho.filter(function(Ct) {
                return Ct !== q && Ea(Ct.target)
            }).length || bn(At ? at : a, "scroll", id), q.isPressed && (q._vx.reset(), q._vy.reset(), bn(V ? a : at, Ei[1], de, !0)), bn(At ? at : a, "scroll", et, ft), bn(a, "wheel", Tt, ft), bn(a, Ei[0], S, ft), bn(at, Ei[2], F), bn(at, Ei[3], F), bn(a, "click", xt, !0), bn(a, "click", ne), bn(at, "gesturestart", Y), bn(at, "gestureend", Z), bn(a, hr + "enter", Te), bn(a, hr + "leave", xe), bn(a, hr + "move", Ht), q.isEnabled = q.isPressed = q.isDragging = !1, Zt && Zt(q))
        },
        q.kill = q.revert = function() {
            q.disable();
            var Ct = ho.indexOf(q);
            Ct >= 0 && ho.splice(Ct, 1),
            fs === q && (fs = 0)
        },
        ho.push(q),
        V && Ea(a) && (fs = q),
        q.enable(_)
    }, oR(r, [{
        key: "velocityX",
        get: function() {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function() {
            return this._vy.getVelocity()
        }
    }]), r
}();
We.version = "3.12.5";
We.create = function(r) {
    return new We(r)
};
We.register = v0;
We.getAll = function() {
    return ho.slice()
};
We.getById = function(r) {
    return ho.filter(function(t) {
        return t.vars.id === r
    })[0]
};
g0() && un.registerPlugin(We); /*!
 * ScrollTrigger 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/







var wt,
    so,
    he,
    ze,
    bi,
    Ie,
    y0,
    bc,
    Wa,
    ba,
    ca,
    Fl,
    xn,
    zc,
    rd,
    Rn,
    wm,
    Am,
    ro,
    M0,
    Bh,
    S0,
    Cn,
    od,
    T0,
    E0,
    Is,
    ad,
    ff,
    Mo,
    pf,
    wc,
    ld,
    kh,
    Ul = 1,
    vn = Date.now,
    Hh = vn(),
    gi = 0,
    ha = 0,
    Cm = function(t, e, n) {
        var i = Jn(t) && (t.substr(0, 6) === "clamp(" || t.indexOf("max") > -1);
        return n["_" + e + "Clamp"] = i, i ? t.substr(6, t.length - 7) : t
    },
    Rm = function(t, e) {
        return e && (!Jn(t) || t.substr(0, 6) !== "clamp(") ? "clamp(" + t + ")" : t
    },
    lR = function r() {
        return ha && requestAnimationFrame(r)
    },
    Pm = function() {
        return zc = 1
    },
    Lm = function() {
        return zc = 0
    },
    Fi = function(t) {
        return t
    },
    ua = function(t) {
        return Math.round(t * 1e5) / 1e5 || 0
    },
    b0 = function() {
        return typeof window < "u"
    },
    w0 = function() {
        return wt || b0() && (wt = window.gsap) && wt.registerPlugin && wt
    },
    wr = function(t) {
        return !!~y0.indexOf(t)
    },
    A0 = function(t) {
        return (t === "Height" ? pf : he["inner" + t]) || bi["client" + t] || Ie["client" + t]
    },
    C0 = function(t) {
        return qs(t, "getBoundingClientRect") || (wr(t) ? function() {
                return oc.width = he.innerWidth, oc.height = pf, oc
            } : function() {
                return cs(t)
            })
    },
    cR = function(t, e, n) {
        var i = n.d,
            s = n.d2,
            o = n.a;
        return (o = qs(t, "getBoundingClientRect")) ? function() {
            return o()[i]
        } : function() {
            return (e ? A0(s) : t["client" + s]) || 0
        }
    },
    hR = function(t, e) {
        return !e || ~Gi.indexOf(t) ? C0(t) : function() {
            return oc
        }
    },
    ki = function(t, e) {
        var n = e.s,
            i = e.d2,
            s = e.d,
            o = e.a;
        return Math.max(0, (n = "scroll" + i) && (o = qs(t, n)) ? o() - C0(t)()[s] : wr(t) ? (bi[n] || Ie[n]) - A0(i) : t[n] - t["offset" + i])
    },
    Ol = function(t, e) {
        for (var n = 0; n < ro.length; n += 3)
            (!e || ~e.indexOf(ro[n + 1])) && t(ro[n], ro[n + 1], ro[n + 2])
    },
    Jn = function(t) {
        return typeof t == "string"
    },
    In = function(t) {
        return typeof t == "function"
    },
    da = function(t) {
        return typeof t == "number"
    },
    ur = function(t) {
        return typeof t == "object"
    },
    sa = function(t, e, n) {
        return t && t.progress(e ? 0 : 1) && n && t.pause()
    },
    Vh = function(t, e) {
        if (t.enabled) {
            var n = t._ctx ? t._ctx.add(function() {
                return e(t)
            }) : e(t);
            n && n.totalTime && (t.callbackAnimation = n)
        }
    },
    no = Math.abs,
    R0 = "left",
    P0 = "top",
    mf = "right",
    gf = "bottom",
    yr = "width",
    Mr = "height",
    wa = "Right",
    Aa = "Left",
    Ca = "Top",
    Ra = "Bottom",
    $e = "padding",
    ui = "margin",
    Bo = "Width",
    _f = "Height",
    Ze = "px",
    di = function(t) {
        return he.getComputedStyle(t)
    },
    uR = function(t) {
        var e = di(t).position;
        t.style.position = e === "absolute" || e === "fixed" ? e : "relative"
    },
    Dm = function(t, e) {
        for (var n in e)
            n in t || (t[n] = e[n]);
        return t
    },
    cs = function(t, e) {
        var n = e && di(t)[rd] !== "matrix(1, 0, 0, 1, 0, 0)" && wt.to(t, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1),
            i = t.getBoundingClientRect();
        return n && n.progress(0).kill(), i
    },
    Ac = function(t, e) {
        var n = e.d2;
        return t["offset" + n] || t["client" + n] || 0
    },
    L0 = function(t) {
        var e = [],
            n = t.labels,
            i = t.duration(),
            s;
        for (s in n)
            e.push(n[s] / i);
        return e
    },
    dR = function(t) {
        return function(e) {
            return wt.utils.snap(L0(t), e)
        }
    },
    xf = function(t) {
        var e = wt.utils.snap(t),
            n = Array.isArray(t) && t.slice(0).sort(function(i, s) {
                return i - s
            });
        return n ? function(i, s, o) {
            o === void 0 && (o = .001);
            var a;
            if (!s)
                return e(i);
            if (s > 0) {
                for (i -= o, a = 0; a < n.length; a++)
                    if (n[a] >= i)
                        return n[a];
                return n[a - 1]
            } else
                for (a = n.length, i += o; a--;)
                    if (n[a] <= i)
                        return n[a];
            return n[0]
        } : function(i, s, o) {
            o === void 0 && (o = .001);
            var a = e(i);
            return !s || Math.abs(a - i) < o || a - i < 0 == s < 0 ? a : e(s < 0 ? i - t : i + t)
        }
    },
    fR = function(t) {
        return function(e, n) {
            return xf(L0(t))(e, n.direction)
        }
    },
    zl = function(t, e, n, i) {
        return n.split(",").forEach(function(s) {
            return t(e, s, i)
        })
    },
    sn = function(t, e, n, i, s) {
        return t.addEventListener(e, n, {
            passive: !i,
            capture: !!s
        })
    },
    nn = function(t, e, n, i) {
        return t.removeEventListener(e, n, !!i)
    },
    Bl = function(t, e, n) {
        n = n && n.wheelHandler,
        n && (t(e, "wheel", n), t(e, "touchmove", n))
    },
    Nm = {
        startColor: "green",
        endColor: "red",
        indent: 0,
        fontSize: "16px",
        fontWeight: "normal"
    },
    kl = {
        toggleActions: "play",
        anticipatePin: 0
    },
    Cc = {
        top: 0,
        left: 0,
        center: .5,
        bottom: 1,
        right: 1
    },
    nc = function(t, e) {
        if (Jn(t)) {
            var n = t.indexOf("="),
                i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
            ~n && (t.indexOf("%") > n && (i *= e / 100), t = t.substr(0, n - 1)),
            t = i + (t in Cc ? Cc[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
        }
        return t
    },
    Hl = function(t, e, n, i, s, o, a, l) {
        var c = s.startColor,
            h = s.endColor,
            u = s.fontSize,
            d = s.indent,
            f = s.fontWeight,
            m = ze.createElement("div"),
            _ = wr(n) || qs(n, "pinType") === "fixed",
            g = t.indexOf("scroller") !== -1,
            p = _ ? Ie : n,
            x = t.indexOf("start") !== -1,
            v = x ? c : h,
            y = "border-color:" + v + ";font-size:" + u + ";color:" + v + ";font-weight:" + f + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        return y += "position:" + ((g || l) && _ ? "fixed;" : "absolute;"), (g || l || !_) && (y += (i === Je ? mf : gf) + ":" + (o + parseFloat(d)) + "px;"), a && (y += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), m._isStart = x, m.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")), m.style.cssText = y, m.innerText = e || e === 0 ? t + "-" + e : t, p.children[0] ? p.insertBefore(m, p.children[0]) : p.appendChild(m), m._offset = m["offset" + i.op.d2], ic(m, 0, i, x), m
    },
    ic = function(t, e, n, i) {
        var s = {
                display: "block"
            },
            o = n[i ? "os2" : "p2"],
            a = n[i ? "p2" : "os2"];
        t._isFlipped = i,
        s[n.a + "Percent"] = i ? -100 : 0,
        s[n.a] = i ? "1px" : 0,
        s["border" + o + Bo] = 1,
        s["border" + a + Bo] = 0,
        s[n.p] = e + "px",
        wt.set(t, s)
    },
    se = [],
    cd = {},
    Xa,
    Im = function() {
        return vn() - gi > 34 && (Xa || (Xa = requestAnimationFrame(gs)))
    },
    io = function() {
        (!Cn || !Cn.isPressed || Cn.startX > Ie.clientWidth) && (oe.cache++, Cn ? Xa || (Xa = requestAnimationFrame(gs)) : gs(), gi || Cr("scrollStart"), gi = vn())
    },
    Gh = function() {
        E0 = he.innerWidth,
        T0 = he.innerHeight
    },
    fa = function() {
        oe.cache++,
        !xn && !S0 && !ze.fullscreenElement && !ze.webkitFullscreenElement && (!od || E0 !== he.innerWidth || Math.abs(he.innerHeight - T0) > he.innerHeight * .25) && bc.restart(!0)
    },
    Ar = {},
    pR = [],
    D0 = function r() {
        return nn(ee, "scrollEnd", r) || mr(!0)
    },
    Cr = function(t) {
        return Ar[t] && Ar[t].map(function(e) {
                return e()
            }) || pR
    },
    Zn = [],
    N0 = function(t) {
        for (var e = 0; e < Zn.length; e += 5)
            (!t || Zn[e + 4] && Zn[e + 4].query === t) && (Zn[e].style.cssText = Zn[e + 1], Zn[e].getBBox && Zn[e].setAttribute("transform", Zn[e + 2] || ""), Zn[e + 3].uncache = 1)
    },
    vf = function(t, e) {
        var n;
        for (Rn = 0; Rn < se.length; Rn++)
            n = se[Rn],
            n && (!e || n._ctx === e) && (t ? n.kill(1) : n.revert(!0, !0));
        wc = !0,
        e && N0(e),
        e || Cr("revert")
    },
    I0 = function(t, e) {
        oe.cache++,
        (e || !Pn) && oe.forEach(function(n) {
            return In(n) && n.cacheID++ && (n.rec = 0)
        }),
        Jn(t) && (he.history.scrollRestoration = ff = t)
    },
    Pn,
    Sr = 0,
    Fm,
    mR = function() {
        if (Fm !== Sr) {
            var t = Fm = Sr;
            requestAnimationFrame(function() {
                return t === Sr && mr(!0)
            })
        }
    },
    F0 = function() {
        Ie.appendChild(Mo),
        pf = !Cn && Mo.offsetHeight || he.innerHeight,
        Ie.removeChild(Mo)
    },
    Um = function(t) {
        return Wa(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(e) {
            return e.style.display = t ? "none" : "block"
        })
    },
    mr = function(t, e) {
        if (gi && !t && !wc) {
            sn(ee, "scrollEnd", D0);
            return
        }
        F0(),
        Pn = ee.isRefreshing = !0,
        oe.forEach(function(i) {
            return In(i) && ++i.cacheID && (i.rec = i())
        });
        var n = Cr("refreshInit");
        M0 && ee.sort(),
        e || vf(),
        oe.forEach(function(i) {
            In(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"), i(0))
        }),
        se.slice(0).forEach(function(i) {
            return i.refresh()
        }),
        wc = !1,
        se.forEach(function(i) {
            if (i._subPinOffset && i.pin) {
                var s = i.vars.horizontal ? "offsetWidth" : "offsetHeight",
                    o = i.pin[s];
                i.revert(!0, 1),
                i.adjustPinSpacing(i.pin[s] - o),
                i.refresh()
            }
        }),
        ld = 1,
        Um(!0),
        se.forEach(function(i) {
            var s = ki(i.scroller, i._dir),
                o = i.vars.end === "max" || i._endClamp && i.end > s,
                a = i._startClamp && i.start >= s;
            (o || a) && i.setPositions(a ? s - 1 : i.start, o ? Math.max(a ? s : i.start + 1, s) : i.end, !0)
        }),
        Um(!1),
        ld = 0,
        n.forEach(function(i) {
            return i && i.render && i.render(-1)
        }),
        oe.forEach(function(i) {
            In(i) && (i.smooth && requestAnimationFrame(function() {
                return i.target.style.scrollBehavior = "smooth"
            }), i.rec && i(i.rec))
        }),
        I0(ff, 1),
        bc.pause(),
        Sr++,
        Pn = 2,
        gs(2),
        se.forEach(function(i) {
            return In(i.vars.onRefresh) && i.vars.onRefresh(i)
        }),
        Pn = ee.isRefreshing = !1,
        Cr("refresh")
    },
    hd = 0,
    sc = 1,
    Pa,
    gs = function(t) {
        if (t === 2 || !Pn && !wc) {
            ee.isUpdating = !0,
            Pa && Pa.update(0);
            var e = se.length,
                n = vn(),
                i = n - Hh >= 50,
                s = e && se[0].scroll();
            if (sc = hd > s ? -1 : 1, Pn || (hd = s), i && (gi && !zc && n - gi > 200 && (gi = 0, Cr("scrollEnd")), ca = Hh, Hh = n), sc < 0) {
                for (Rn = e; Rn-- > 0;)
                    se[Rn] && se[Rn].update(0, i);
                sc = 1
            } else
                for (Rn = 0; Rn < e; Rn++)
                    se[Rn] && se[Rn].update(0, i);
            ee.isUpdating = !1
        }
        Xa = 0
    },
    ud = [R0, P0, gf, mf, ui + Ra, ui + wa, ui + Ca, ui + Aa, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
    rc = ud.concat([yr, Mr, "boxSizing", "max" + Bo, "max" + _f, "position", ui, $e, $e + Ca, $e + wa, $e + Ra, $e + Aa]),
    gR = function(t, e, n) {
        So(n);
        var i = t._gsap;
        if (i.spacerIsNative)
            So(i.spacerState);
        else if (t._gsap.swappedIn) {
            var s = e.parentNode;
            s && (s.insertBefore(t, e), s.removeChild(e))
        }
        t._gsap.swappedIn = !1
    },
    Wh = function(t, e, n, i) {
        if (!t._gsap.swappedIn) {
            for (var s = ud.length, o = e.style, a = t.style, l; s--;)
                l = ud[s],
                o[l] = n[l];
            o.position = n.position === "absolute" ? "absolute" : "relative",
            n.display === "inline" && (o.display = "inline-block"),
            a[gf] = a[mf] = "auto",
            o.flexBasis = n.flexBasis || "auto",
            o.overflow = "visible",
            o.boxSizing = "border-box",
            o[yr] = Ac(t, Nn) + Ze,
            o[Mr] = Ac(t, Je) + Ze,
            o[$e] = a[ui] = a[P0] = a[R0] = "0",
            So(i),
            a[yr] = a["max" + Bo] = n[yr],
            a[Mr] = a["max" + _f] = n[Mr],
            a[$e] = n[$e],
            t.parentNode !== e && (t.parentNode.insertBefore(e, t), e.appendChild(t)),
            t._gsap.swappedIn = !0
        }
    },
    _R = /([A-Z])/g,
    So = function(t) {
        if (t) {
            var e = t.t.style,
                n = t.length,
                i = 0,
                s,
                o;
            for ((t.t._gsap || wt.core.getCache(t.t)).uncache = 1; i < n; i += 2)
                o = t[i + 1],
                s = t[i],
                o ? e[s] = o : e[s] && e.removeProperty(s.replace(_R, "-$1").toLowerCase())
        }
    },
    Vl = function(t) {
        for (var e = rc.length, n = t.style, i = [], s = 0; s < e; s++)
            i.push(rc[s], n[rc[s]]);
        return i.t = t, i
    },
    xR = function(t, e, n) {
        for (var i = [], s = t.length, o = n ? 8 : 0, a; o < s; o += 2)
            a = t[o],
            i.push(a, a in e ? e[a] : t[o + 1]);
        return i.t = t.t, i
    },
    oc = {
        left: 0,
        top: 0
    },
    Om = function(t, e, n, i, s, o, a, l, c, h, u, d, f, m) {
        In(t) && (t = t(l)),
        Jn(t) && t.substr(0, 3) === "max" && (t = d + (t.charAt(4) === "=" ? nc("0" + t.substr(3), n) : 0));
        var _ = f ? f.time() : 0,
            g,
            p,
            x;
        if (f && f.seek(0), isNaN(t) || (t = +t), da(t))
            f && (t = wt.utils.mapRange(f.scrollTrigger.start, f.scrollTrigger.end, 0, d, t)),
            a && ic(a, n, i, !0);
        else {
            In(e) && (e = e(l));
            var v = (t || "0").split(" "),
                y,
                C,
                A,
                T;
            x = Bn(e, l) || Ie,
            y = cs(x) || {},
            (!y || !y.left && !y.top) && di(x).display === "none" && (T = x.style.display, x.style.display = "block", y = cs(x), T ? x.style.display = T : x.style.removeProperty("display")),
            C = nc(v[0], y[i.d]),
            A = nc(v[1] || "0", n),
            t = y[i.p] - c[i.p] - h + C + s - A,
            a && ic(a, A, i, n - A < 20 || a._isStart && A > 20),
            n -= n - A
        }
        if (m && (l[m] = t || -.001, t < 0 && (t = 0)), o) {
            var R = t + n,
                E = o._isStart;
            g = "scroll" + i.d2,
            ic(o, R, i, E && R > 20 || !E && (u ? Math.max(Ie[g], bi[g]) : o.parentNode[g]) <= R + 1),
            u && (c = cs(a), u && (o.style[i.op.p] = c[i.op.p] - i.op.m - o._offset + Ze))
        }
        return f && x && (g = cs(x), f.seek(d), p = cs(x), f._caScrollDist = g[i.p] - p[i.p], t = t / f._caScrollDist * d), f && f.seek(_), f ? t : Math.round(t)
    },
    vR = /(webkit|moz|length|cssText|inset)/i,
    zm = function(t, e, n, i) {
        if (t.parentNode !== e) {
            var s = t.style,
                o,
                a;
            if (e === Ie) {
                t._stOrig = s.cssText,
                a = di(t);
                for (o in a)
                    !+o && !vR.test(o) && a[o] && typeof s[o] == "string" && o !== "0" && (s[o] = a[o]);
                s.top = n,
                s.left = i
            } else
                s.cssText = t._stOrig;
            wt.core.getCache(t).uncache = 1,
            e.appendChild(t)
        }
    },
    U0 = function(t, e, n) {
        var i = e,
            s = i;
        return function(o) {
            var a = Math.round(t());
            return a !== i && a !== s && Math.abs(a - i) > 3 && Math.abs(a - s) > 3 && (o = a, n && n()), s = i, i = o, o
        }
    },
    Gl = function(t, e, n) {
        var i = {};
        i[e.p] = "+=" + n,
        wt.set(t, i)
    },
    Bm = function(t, e) {
        var n = Zs(t, e),
            i = "_scroll" + e.p2,
            s = function o(a, l, c, h, u) {
                var d = o.tween,
                    f = l.onComplete,
                    m = {};
                c = c || n();
                var _ = U0(n, c, function() {
                    d.kill(),
                    o.tween = 0
                });
                return u = h && u || 0, h = h || a - c, d && d.kill(), l[i] = a, l.inherit = !1, l.modifiers = m, m[i] = function() {
                    return _(c + h * d.ratio + u * d.ratio * d.ratio)
                }, l.onUpdate = function() {
                    oe.cache++,
                    o.tween && gs()
                }, l.onComplete = function() {
                    o.tween = 0,
                    f && f.call(d)
                }, d = o.tween = wt.to(t, l), d
            };
        return t[i] = n, n.wheelHandler = function() {
            return s.tween && s.tween.kill() && (s.tween = 0)
        }, sn(t, "wheel", n.wheelHandler), ee.isTouch && sn(t, "touchmove", n.wheelHandler), s
    },
    ee = function() {
        function r(e, n) {
            so || r.register(wt) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
            ad(this),
            this.init(e, n)
        }
        var t = r.prototype;
        return t.init = function(n, i) {
            if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !ha) {
                this.update = this.refresh = this.kill = Fi;
                return
            }
            n = Dm(Jn(n) || da(n) || n.nodeType ? {
                trigger: n
            } : n, kl);
            var s = n,
                o = s.onUpdate,
                a = s.toggleClass,
                l = s.id,
                c = s.onToggle,
                h = s.onRefresh,
                u = s.scrub,
                d = s.trigger,
                f = s.pin,
                m = s.pinSpacing,
                _ = s.invalidateOnRefresh,
                g = s.anticipatePin,
                p = s.onScrubComplete,
                x = s.onSnapComplete,
                v = s.once,
                y = s.snap,
                C = s.pinReparent,
                A = s.pinSpacer,
                T = s.containerAnimation,
                R = s.fastScrollEnd,
                E = s.preventOverlaps,
                M = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? Nn : Je,
                D = !u && u !== 0,
                I = Bn(n.scroller || he),
                k = wt.core.getCache(I),
                $ = wr(I),
                j = ("pinType" in n ? n.pinType : qs(I, "pinType") || $ && "fixed") === "fixed",
                G = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack],
                H = D && n.toggleActions.split(" "),
                V = "markers" in n ? n.markers : kl.markers,
                nt = $ ? 0 : parseFloat(di(I)["border" + M.p2 + Bo]) || 0,
                P = this,
                ct = n.onRefreshInit && function() {
                    return n.onRefreshInit(P)
                },
                Ut = cR(I, $, M),
                Zt = hR(I, $),
                J = 0,
                it = 0,
                ft = 0,
                ut = Zs(I, M),
                Pt,
                Nt,
                Kt,
                Jt,
                N,
                zt,
                Bt,
                jt,
                yt,
                q,
                Lt,
                kt,
                L,
                b,
                K,
                st,
                rt,
                Q,
                At,
                at,
                dt,
                Ot,
                lt,
                xt,
                It,
                Xt,
                vt,
                Wt,
                Yt,
                de,
                S,
                F,
                Y,
                Z,
                et,
                Tt,
                Ht,
                Te,
                xe;
            if (P._startClamp = P._endClamp = !1, P._dir = M, g *= 45, P.scroller = I, P.scroll = T ? T.time.bind(T) : ut, Jt = ut(), P.vars = n, i = i || n.animation, "refreshPriority" in n && (M0 = 1, n.refreshPriority === -9999 && (Pa = P)), k.tweenScroll = k.tweenScroll || {
                top: Bm(I, Je),
                left: Bm(I, Nn)
            }, P.tweenTo = Pt = k.tweenScroll[M.p], P.scrubDuration = function(ht) {
                Y = da(ht) && ht,
                Y ? F ? F.duration(ht) : F = wt.to(i, {
                    ease: "expo",
                    totalProgress: "+=0",
                    inherit: !1,
                    duration: Y,
                    paused: !0,
                    onComplete: function() {
                        return p && p(P)
                    }
                }) : (F && F.progress(1).kill(), F = 0)
            }, i && (i.vars.lazy = !1, i._initted && !P.isReverted || i.vars.immediateRender !== !1 && n.immediateRender !== !1 && i.duration() && i.render(0, !0, !0), P.animation = i.pause(), i.scrollTrigger = P, P.scrubDuration(u), de = 0, l || (l = i.vars.id)), y && ((!ur(y) || y.push) && (y = {
                snapTo: y
            }), "scrollBehavior" in Ie.style && wt.set($ ? [Ie, bi] : I, {
                scrollBehavior: "auto"
            }), oe.forEach(function(ht) {
                return In(ht) && ht.target === ($ ? ze.scrollingElement || bi : I) && (ht.smooth = !1)
            }), Kt = In(y.snapTo) ? y.snapTo : y.snapTo === "labels" ? dR(i) : y.snapTo === "labelsDirectional" ? fR(i) : y.directional !== !1 ? function(ht, $t) {
                return xf(y.snapTo)(ht, vn() - it < 500 ? 0 : $t.direction)
            } : wt.utils.snap(y.snapTo), Z = y.duration || {
                min: .1,
                max: 2
            }, Z = ur(Z) ? ba(Z.min, Z.max) : ba(Z, Z), et = wt.delayedCall(y.delay || Y / 2 || .1, function() {
                var ht = ut(),
                    $t = vn() - it < 500,
                    Dt = Pt.tween;
                if (($t || Math.abs(P.getVelocity()) < 10) && !Dt && !zc && J !== ht) {
                    var qt = (ht - zt) / b,
                        Oe = i && !D ? i.totalProgress() : qt,
                        ie = $t ? 0 : (Oe - S) / (vn() - ca) * 1e3 || 0,
                        Ae = wt.utils.clamp(-qt, 1 - qt, no(ie / 2) * ie / .185),
                        Ke = qt + (y.inertia === !1 ? 0 : Ae),
                        De,
                        Ce,
                        ve = y,
                        Yn = ve.onStart,
                        w = ve.onInterrupt,
                        U = ve.onComplete;
                    if (De = Kt(Ke, P), da(De) || (De = Ke), Ce = Math.round(zt + De * b), ht <= Bt && ht >= zt && Ce !== ht) {
                        if (Dt && !Dt._initted && Dt.data <= no(Ce - ht))
                            return;
                        y.inertia === !1 && (Ae = De - qt),
                        Pt(Ce, {
                            duration: Z(no(Math.max(no(Ke - Oe), no(De - Oe)) * .185 / ie / .05 || 0)),
                            ease: y.ease || "power3",
                            data: no(Ce - ht),
                            onInterrupt: function() {
                                return et.restart(!0) && w && w(P)
                            },
                            onComplete: function() {
                                P.update(),
                                J = ut(),
                                i && (F ? F.resetTo("totalProgress", De, i._tTime / i._tDur) : i.progress(De)),
                                de = S = i && !D ? i.totalProgress() : P.progress,
                                x && x(P),
                                U && U(P)
                            }
                        }, ht, Ae * b, Ce - ht - Ae * b),
                        Yn && Yn(P, Pt.tween)
                    }
                } else
                    P.isActive && J !== ht && et.restart(!0)
            }).pause()), l && (cd[l] = P), d = P.trigger = Bn(d || f !== !0 && f), xe = d && d._gsap && d._gsap.stRevert, xe && (xe = xe(P)), f = f === !0 ? d : Bn(f), Jn(a) && (a = {
                targets: d,
                className: a
            }), f && (m === !1 || m === ui || (m = !m && f.parentNode && f.parentNode.style && di(f.parentNode).display === "flex" ? !1 : $e), P.pin = f, Nt = wt.core.getCache(f), Nt.spacer ? K = Nt.pinState : (A && (A = Bn(A), A && !A.nodeType && (A = A.current || A.nativeElement), Nt.spacerIsNative = !!A, A && (Nt.spacerState = Vl(A))), Nt.spacer = Q = A || ze.createElement("div"), Q.classList.add("pin-spacer"), l && Q.classList.add("pin-spacer-" + l), Nt.pinState = K = Vl(f)), n.force3D !== !1 && wt.set(f, {
                force3D: !0
            }), P.spacer = Q = Nt.spacer, Yt = di(f), xt = Yt[m + M.os2], at = wt.getProperty(f), dt = wt.quickSetter(f, M.a, Ze), Wh(f, Q, Yt), rt = Vl(f)), V) {
                kt = ur(V) ? Dm(V, Nm) : Nm,
                q = Hl("scroller-start", l, I, M, kt, 0),
                Lt = Hl("scroller-end", l, I, M, kt, 0, q),
                At = q["offset" + M.op.d2];
                var ne = Bn(qs(I, "content") || I);
                jt = this.markerStart = Hl("start", l, ne, M, kt, At, 0, T),
                yt = this.markerEnd = Hl("end", l, ne, M, kt, At, 0, T),
                T && (Te = wt.quickSetter([jt, yt], M.a, Ze)),
                !j && !(Gi.length && qs(I, "fixedMarkers") === !0) && (uR($ ? Ie : I), wt.set([q, Lt], {
                    force3D: !0
                }), Xt = wt.quickSetter(q, M.a, Ze), Wt = wt.quickSetter(Lt, M.a, Ze))
            }
            if (T) {
                var Ct = T.vars.onUpdate,
                    Mt = T.vars.onUpdateParams;
                T.eventCallback("onUpdate", function() {
                    P.update(0, 0, 1),
                    Ct && Ct.apply(T, Mt || [])
                })
            }
            if (P.previous = function() {
                return se[se.indexOf(P) - 1]
            }, P.next = function() {
                return se[se.indexOf(P) + 1]
            }, P.revert = function(ht, $t) {
                if (!$t)
                    return P.kill(!0);
                var Dt = ht !== !1 || !P.enabled,
                    qt = xn;
                Dt !== P.isReverted && (Dt && (Tt = Math.max(ut(), P.scroll.rec || 0), ft = P.progress, Ht = i && i.progress()), jt && [jt, yt, q, Lt].forEach(function(Oe) {
                    return Oe.style.display = Dt ? "none" : "block"
                }), Dt && (xn = P, P.update(Dt)), f && (!C || !P.isActive) && (Dt ? gR(f, Q, K) : Wh(f, Q, di(f), It)), Dt || P.update(Dt), xn = qt, P.isReverted = Dt)
            }, P.refresh = function(ht, $t, Dt, qt) {
                if (!((xn || !P.enabled) && !$t)) {
                    if (f && ht && gi) {
                        sn(r, "scrollEnd", D0);
                        return
                    }
                    !Pn && ct && ct(P),
                    xn = P,
                    Pt.tween && !Dt && (Pt.tween.kill(), Pt.tween = 0),
                    F && F.pause(),
                    _ && i && i.revert({
                        kill: !1
                    }).invalidate(),
                    P.isReverted || P.revert(!0, !0),
                    P._subPinOffset = !1;
                    var Oe = Ut(),
                        ie = Zt(),
                        Ae = T ? T.duration() : ki(I, M),
                        Ke = b <= .01,
                        De = 0,
                        Ce = qt || 0,
                        ve = ur(Dt) ? Dt.end : n.end,
                        Yn = n.endTrigger || d,
                        w = ur(Dt) ? Dt.start : n.start || (n.start === 0 || !d ? 0 : f ? "0 0" : "0 100%"),
                        U = P.pinnedContainer = n.pinnedContainer && Bn(n.pinnedContainer, P),
                        X = d && Math.max(0, se.indexOf(P)) || 0,
                        W = X,
                        z,
                        ot,
                        mt,
                        bt,
                        gt,
                        Et,
                        Ft,
                        Vt,
                        fe,
                        Ee,
                        pe,
                        je,
                        ce;
                    for (V && ur(Dt) && (je = wt.getProperty(q, M.p), ce = wt.getProperty(Lt, M.p)); W--;)
                        Et = se[W],
                        Et.end || Et.refresh(0, 1) || (xn = P),
                        Ft = Et.pin,
                        Ft && (Ft === d || Ft === f || Ft === U) && !Et.isReverted && (Ee || (Ee = []), Ee.unshift(Et), Et.revert(!0, !0)),
                        Et !== se[W] && (X--, W--);
                    for (In(w) && (w = w(P)), w = Cm(w, "start", P), zt = Om(w, d, Oe, M, ut(), jt, q, P, ie, nt, j, Ae, T, P._startClamp && "_startClamp") || (f ? -.001 : 0), In(ve) && (ve = ve(P)), Jn(ve) && !ve.indexOf("+=") && (~ve.indexOf(" ") ? ve = (Jn(w) ? w.split(" ")[0] : "") + ve : (De = nc(ve.substr(2), Oe), ve = Jn(w) ? w : (T ? wt.utils.mapRange(0, T.duration(), T.scrollTrigger.start, T.scrollTrigger.end, zt) : zt) + De, Yn = d)), ve = Cm(ve, "end", P), Bt = Math.max(zt, Om(ve || (Yn ? "100% 0" : Ae), Yn, Oe, M, ut() + De, yt, Lt, P, ie, nt, j, Ae, T, P._endClamp && "_endClamp")) || -.001, De = 0, W = X; W--;)
                        Et = se[W],
                        Ft = Et.pin,
                        Ft && Et.start - Et._pinPush <= zt && !T && Et.end > 0 && (z = Et.end - (P._startClamp ? Math.max(0, Et.start) : Et.start), (Ft === d && Et.start - Et._pinPush < zt || Ft === U) && isNaN(w) && (De += z * (1 - Et.progress)), Ft === f && (Ce += z));
                    if (zt += De, Bt += De, P._startClamp && (P._startClamp += De), P._endClamp && !Pn && (P._endClamp = Bt || -.001, Bt = Math.min(Bt, ki(I, M))), b = Bt - zt || (zt -= .01) && .001, Ke && (ft = wt.utils.clamp(0, 1, wt.utils.normalize(zt, Bt, Tt))), P._pinPush = Ce, jt && De && (z = {}, z[M.a] = "+=" + De, U && (z[M.p] = "-=" + ut()), wt.set([jt, yt], z)), f && !(ld && P.end >= ki(I, M)))
                        z = di(f),
                        bt = M === Je,
                        mt = ut(),
                        Ot = parseFloat(at(M.a)) + Ce,
                        !Ae && Bt > 1 && (pe = ($ ? ze.scrollingElement || bi : I).style, pe = {
                            style: pe,
                            value: pe["overflow" + M.a.toUpperCase()]
                        }, $ && di(Ie)["overflow" + M.a.toUpperCase()] !== "scroll" && (pe.style["overflow" + M.a.toUpperCase()] = "scroll")),
                        Wh(f, Q, z),
                        rt = Vl(f),
                        ot = cs(f, !0),
                        Vt = j && Zs(I, bt ? Nn : Je)(),
                        m ? (It = [m + M.os2, b + Ce + Ze], It.t = Q, W = m === $e ? Ac(f, M) + b + Ce : 0, W && (It.push(M.d, W + Ze), Q.style.flexBasis !== "auto" && (Q.style.flexBasis = W + Ze)), So(It), U && se.forEach(function(Rt) {
                            Rt.pin === U && Rt.vars.pinSpacing !== !1 && (Rt._subPinOffset = !0)
                        }), j && ut(Tt)) : (W = Ac(f, M), W && Q.style.flexBasis !== "auto" && (Q.style.flexBasis = W + Ze)),
                        j && (gt = {
                            top: ot.top + (bt ? mt - zt : Vt) + Ze,
                            left: ot.left + (bt ? Vt : mt - zt) + Ze,
                            boxSizing: "border-box",
                            position: "fixed"
                        }, gt[yr] = gt["max" + Bo] = Math.ceil(ot.width) + Ze, gt[Mr] = gt["max" + _f] = Math.ceil(ot.height) + Ze, gt[ui] = gt[ui + Ca] = gt[ui + wa] = gt[ui + Ra] = gt[ui + Aa] = "0", gt[$e] = z[$e], gt[$e + Ca] = z[$e + Ca], gt[$e + wa] = z[$e + wa], gt[$e + Ra] = z[$e + Ra], gt[$e + Aa] = z[$e + Aa], st = xR(K, gt, C), Pn && ut(0)),
                        i ? (fe = i._initted, Bh(1), i.render(i.duration(), !0, !0), lt = at(M.a) - Ot + b + Ce, vt = Math.abs(b - lt) > 1, j && vt && st.splice(st.length - 2, 2), i.render(0, !0, !0), fe || i.invalidate(!0), i.parent || i.totalTime(i.totalTime()), Bh(0)) : lt = b,
                        pe && (pe.value ? pe.style["overflow" + M.a.toUpperCase()] = pe.value : pe.style.removeProperty("overflow-" + M.a));
                    else if (d && ut() && !T)
                        for (ot = d.parentNode; ot && ot !== Ie;)
                            ot._pinOffset && (zt -= ot._pinOffset, Bt -= ot._pinOffset),
                            ot = ot.parentNode;
                    Ee && Ee.forEach(function(Rt) {
                        return Rt.revert(!1, !0)
                    }),
                    P.start = zt,
                    P.end = Bt,
                    Jt = N = Pn ? Tt : ut(),
                    !T && !Pn && (Jt < Tt && ut(Tt), P.scroll.rec = 0),
                    P.revert(!1, !0),
                    it = vn(),
                    et && (J = -1, et.restart(!0)),
                    xn = 0,
                    i && D && (i._initted || Ht) && i.progress() !== Ht && i.progress(Ht || 0, !0).render(i.time(), !0, !0),
                    (Ke || ft !== P.progress || T || _) && (i && !D && i.totalProgress(T && zt < -.001 && !ft ? wt.utils.normalize(zt, Bt, 0) : ft, !0), P.progress = Ke || (Jt - zt) / b === ft ? 0 : ft),
                    f && m && (Q._pinOffset = Math.round(P.progress * lt)),
                    F && F.invalidate(),
                    isNaN(je) || (je -= wt.getProperty(q, M.p), ce -= wt.getProperty(Lt, M.p), Gl(q, M, je), Gl(jt, M, je - (qt || 0)), Gl(Lt, M, ce), Gl(yt, M, ce - (qt || 0))),
                    Ke && !Pn && P.update(),
                    h && !Pn && !L && (L = !0, h(P), L = !1)
                }
            }, P.getVelocity = function() {
                return (ut() - N) / (vn() - ca) * 1e3 || 0
            }, P.endAnimation = function() {
                sa(P.callbackAnimation),
                i && (F ? F.progress(1) : i.paused() ? D || sa(i, P.direction < 0, 1) : sa(i, i.reversed()))
            }, P.labelToScroll = function(ht) {
                return i && i.labels && (zt || P.refresh() || zt) + i.labels[ht] / i.duration() * b || 0
            }, P.getTrailing = function(ht) {
                var $t = se.indexOf(P),
                    Dt = P.direction > 0 ? se.slice(0, $t).reverse() : se.slice($t + 1);
                return (Jn(ht) ? Dt.filter(function(qt) {
                    return qt.vars.preventOverlaps === ht
                }) : Dt).filter(function(qt) {
                    return P.direction > 0 ? qt.end <= zt : qt.start >= Bt
                })
            }, P.update = function(ht, $t, Dt) {
                if (!(T && !Dt && !ht)) {
                    var qt = Pn === !0 ? Tt : P.scroll(),
                        Oe = ht ? 0 : (qt - zt) / b,
                        ie = Oe < 0 ? 0 : Oe > 1 ? 1 : Oe || 0,
                        Ae = P.progress,
                        Ke,
                        De,
                        Ce,
                        ve,
                        Yn,
                        w,
                        U,
                        X;
                    if ($t && (N = Jt, Jt = T ? ut() : qt, y && (S = de, de = i && !D ? i.totalProgress() : ie)), g && f && !xn && !Ul && gi && (!ie && zt < qt + (qt - N) / (vn() - ca) * g ? ie = 1e-4 : ie === 1 && Bt > qt + (qt - N) / (vn() - ca) * g && (ie = .9999)), ie !== Ae && P.enabled) {
                        if (Ke = P.isActive = !!ie && ie < 1, De = !!Ae && Ae < 1, w = Ke !== De, Yn = w || !!ie != !!Ae, P.direction = ie > Ae ? 1 : -1, P.progress = ie, Yn && !xn && (Ce = ie && !Ae ? 0 : ie === 1 ? 1 : Ae === 1 ? 2 : 3, D && (ve = !w && H[Ce + 1] !== "none" && H[Ce + 1] || H[Ce], X = i && (ve === "complete" || ve === "reset" || ve in i))), E && (w || X) && (X || u || !i) && (In(E) ? E(P) : P.getTrailing(E).forEach(function(mt) {
                            return mt.endAnimation()
                        })), D || (F && !xn && !Ul ? (F._dp._time - F._start !== F._time && F.render(F._dp._time - F._start), F.resetTo ? F.resetTo("totalProgress", ie, i._tTime / i._tDur) : (F.vars.totalProgress = ie, F.invalidate().restart())) : i && i.totalProgress(ie, !!(xn && (it || ht)))), f) {
                            if (ht && m && (Q.style[m + M.os2] = xt), !j)
                                dt(ua(Ot + lt * ie));
                            else if (Yn) {
                                if (U = !ht && ie > Ae && Bt + 1 > qt && qt + 1 >= ki(I, M), C)
                                    if (!ht && (Ke || U)) {
                                        var W = cs(f, !0),
                                            z = qt - zt;
                                        zm(f, Ie, W.top + (M === Je ? z : 0) + Ze, W.left + (M === Je ? 0 : z) + Ze)
                                    } else
                                        zm(f, Q);
                                So(Ke || U ? st : rt),
                                vt && ie < 1 && Ke || dt(Ot + (ie === 1 && !U ? lt : 0))
                            }
                        }
                        y && !Pt.tween && !xn && !Ul && et.restart(!0),
                        a && (w || v && ie && (ie < 1 || !kh)) && Wa(a.targets).forEach(function(mt) {
                            return mt.classList[Ke || v ? "add" : "remove"](a.className)
                        }),
                        o && !D && !ht && o(P),
                        Yn && !xn ? (D && (X && (ve === "complete" ? i.pause().totalProgress(1) : ve === "reset" ? i.restart(!0).pause() : ve === "restart" ? i.restart(!0) : i[ve]()), o && o(P)), (w || !kh) && (c && w && Vh(P, c), G[Ce] && Vh(P, G[Ce]), v && (ie === 1 ? P.kill(!1, 1) : G[Ce] = 0), w || (Ce = ie === 1 ? 1 : 3, G[Ce] && Vh(P, G[Ce]))), R && !Ke && Math.abs(P.getVelocity()) > (da(R) ? R : 2500) && (sa(P.callbackAnimation), F ? F.progress(1) : sa(i, ve === "reverse" ? 1 : !ie, 1))) : D && o && !xn && o(P)
                    }
                    if (Wt) {
                        var ot = T ? qt / T.duration() * (T._caScrollDist || 0) : qt;
                        Xt(ot + (q._isFlipped ? 1 : 0)),
                        Wt(ot)
                    }
                    Te && Te(-qt / T.duration() * (T._caScrollDist || 0))
                }
            }, P.enable = function(ht, $t) {
                P.enabled || (P.enabled = !0, sn(I, "resize", fa), $ || sn(I, "scroll", io), ct && sn(r, "refreshInit", ct), ht !== !1 && (P.progress = ft = 0, Jt = N = J = ut()), $t !== !1 && P.refresh())
            }, P.getTween = function(ht) {
                return ht && Pt ? Pt.tween : F
            }, P.setPositions = function(ht, $t, Dt, qt) {
                if (T) {
                    var Oe = T.scrollTrigger,
                        ie = T.duration(),
                        Ae = Oe.end - Oe.start;
                    ht = Oe.start + Ae * ht / ie,
                    $t = Oe.start + Ae * $t / ie
                }
                P.refresh(!1, !1, {
                    start: Rm(ht, Dt && !!P._startClamp),
                    end: Rm($t, Dt && !!P._endClamp)
                }, qt),
                P.update()
            }, P.adjustPinSpacing = function(ht) {
                if (It && ht) {
                    var $t = It.indexOf(M.d) + 1;
                    It[$t] = parseFloat(It[$t]) + ht + Ze,
                    It[1] = parseFloat(It[1]) + ht + Ze,
                    So(It)
                }
            }, P.disable = function(ht, $t) {
                if (P.enabled && (ht !== !1 && P.revert(!0, !0), P.enabled = P.isActive = !1, $t || F && F.pause(), Tt = 0, Nt && (Nt.uncache = 1), ct && nn(r, "refreshInit", ct), et && (et.pause(), Pt.tween && Pt.tween.kill() && (Pt.tween = 0)), !$)) {
                    for (var Dt = se.length; Dt--;)
                        if (se[Dt].scroller === I && se[Dt] !== P)
                            return;
                    nn(I, "resize", fa),
                    $ || nn(I, "scroll", io)
                }
            }, P.kill = function(ht, $t) {
                P.disable(ht, $t),
                F && !$t && F.kill(),
                l && delete cd[l];
                var Dt = se.indexOf(P);
                Dt >= 0 && se.splice(Dt, 1),
                Dt === Rn && sc > 0 && Rn--,
                Dt = 0,
                se.forEach(function(qt) {
                    return qt.scroller === P.scroller && (Dt = 1)
                }),
                Dt || Pn || (P.scroll.rec = 0),
                i && (i.scrollTrigger = null, ht && i.revert({
                    kill: !1
                }), $t || i.kill()),
                jt && [jt, yt, q, Lt].forEach(function(qt) {
                    return qt.parentNode && qt.parentNode.removeChild(qt)
                }),
                Pa === P && (Pa = 0),
                f && (Nt && (Nt.uncache = 1), Dt = 0, se.forEach(function(qt) {
                    return qt.pin === f && Dt++
                }), Dt || (Nt.spacer = 0)),
                n.onKill && n.onKill(P)
            }, se.push(P), P.enable(!1, !1), xe && xe(P), i && i.add && !b) {
                var Qt = P.update;
                P.update = function() {
                    P.update = Qt,
                    zt || Bt || P.refresh()
                },
                wt.delayedCall(.01, P.update),
                b = .01,
                zt = Bt = 0
            } else
                P.refresh();
            f && mR()
        }, r.register = function(n) {
            return so || (wt = n || w0(), b0() && window.document && r.enable(), so = ha), so
        }, r.defaults = function(n) {
            if (n)
                for (var i in n)
                    kl[i] = n[i];
            return kl
        }, r.disable = function(n, i) {
            ha = 0,
            se.forEach(function(o) {
                return o[i ? "kill" : "disable"](n)
            }),
            nn(he, "wheel", io),
            nn(ze, "scroll", io),
            clearInterval(Fl),
            nn(ze, "touchcancel", Fi),
            nn(Ie, "touchstart", Fi),
            zl(nn, ze, "pointerdown,touchstart,mousedown", Pm),
            zl(nn, ze, "pointerup,touchend,mouseup", Lm),
            bc.kill(),
            Ol(nn);
            for (var s = 0; s < oe.length; s += 3)
                Bl(nn, oe[s], oe[s + 1]),
                Bl(nn, oe[s], oe[s + 2])
        }, r.enable = function() {
            if (he = window, ze = document, bi = ze.documentElement, Ie = ze.body, wt && (Wa = wt.utils.toArray, ba = wt.utils.clamp, ad = wt.core.context || Fi, Bh = wt.core.suppressOverwrites || Fi, ff = he.history.scrollRestoration || "auto", hd = he.pageYOffset, wt.core.globals("ScrollTrigger", r), Ie)) {
                ha = 1,
                Mo = document.createElement("div"),
                Mo.style.height = "100vh",
                Mo.style.position = "absolute",
                F0(),
                lR(),
                We.register(wt),
                r.isTouch = We.isTouch,
                Is = We.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
                od = We.isTouch === 1,
                sn(he, "wheel", io),
                y0 = [he, ze, bi, Ie],
                wt.matchMedia ? (r.matchMedia = function(l) {
                    var c = wt.matchMedia(),
                        h;
                    for (h in l)
                        c.add(h, l[h]);
                    return c
                }, wt.addEventListener("matchMediaInit", function() {
                    return vf()
                }), wt.addEventListener("matchMediaRevert", function() {
                    return N0()
                }), wt.addEventListener("matchMedia", function() {
                    mr(0, 1),
                    Cr("matchMedia")
                }), wt.matchMedia("(orientation: portrait)", function() {
                    return Gh(), Gh
                })) : console.warn("Requires GSAP 3.11.0 or later"),
                Gh(),
                sn(ze, "scroll", io);
                var n = Ie.style,
                    i = n.borderTopStyle,
                    s = wt.core.Animation.prototype,
                    o,
                    a;
                for (s.revert || Object.defineProperty(s, "revert", {
                    value: function() {
                        return this.time(-.01, !0)
                    }
                }), n.borderTopStyle = "solid", o = cs(Ie), Je.m = Math.round(o.top + Je.sc()) || 0, Nn.m = Math.round(o.left + Nn.sc()) || 0, i ? n.borderTopStyle = i : n.removeProperty("border-top-style"), Fl = setInterval(Im, 250), wt.delayedCall(.5, function() {
                    return Ul = 0
                }), sn(ze, "touchcancel", Fi), sn(Ie, "touchstart", Fi), zl(sn, ze, "pointerdown,touchstart,mousedown", Pm), zl(sn, ze, "pointerup,touchend,mouseup", Lm), rd = wt.utils.checkPrefix("transform"), rc.push(rd), so = vn(), bc = wt.delayedCall(.2, mr).pause(), ro = [ze, "visibilitychange", function() {
                    var l = he.innerWidth,
                        c = he.innerHeight;
                    ze.hidden ? (wm = l, Am = c) : (wm !== l || Am !== c) && fa()
                }, ze, "DOMContentLoaded", mr, he, "load", mr, he, "resize", fa], Ol(sn), se.forEach(function(l) {
                    return l.enable(0, 1)
                }), a = 0; a < oe.length; a += 3)
                    Bl(nn, oe[a], oe[a + 1]),
                    Bl(nn, oe[a], oe[a + 2])
            }
        }, r.config = function(n) {
            "limitCallbacks" in n && (kh = !!n.limitCallbacks);
            var i = n.syncInterval;
            i && clearInterval(Fl) || (Fl = i) && setInterval(Im, i),
            "ignoreMobileResize" in n && (od = r.isTouch === 1 && n.ignoreMobileResize),
            "autoRefreshEvents" in n && (Ol(nn) || Ol(sn, n.autoRefreshEvents || "none"), S0 = (n.autoRefreshEvents + "").indexOf("resize") === -1)
        }, r.scrollerProxy = function(n, i) {
            var s = Bn(n),
                o = oe.indexOf(s),
                a = wr(s);
            ~o && oe.splice(o, a ? 6 : 2),
            i && (a ? Gi.unshift(he, i, Ie, i, bi, i) : Gi.unshift(s, i))
        }, r.clearMatchMedia = function(n) {
            se.forEach(function(i) {
                return i._ctx && i._ctx.query === n && i._ctx.kill(!0, !0)
            })
        }, r.isInViewport = function(n, i, s) {
            var o = (Jn(n) ? Bn(n) : n).getBoundingClientRect(),
                a = o[s ? yr : Mr] * i || 0;
            return s ? o.right - a > 0 && o.left + a < he.innerWidth : o.bottom - a > 0 && o.top + a < he.innerHeight
        }, r.positionInViewport = function(n, i, s) {
            Jn(n) && (n = Bn(n));
            var o = n.getBoundingClientRect(),
                a = o[s ? yr : Mr],
                l = i == null ? a / 2 : i in Cc ? Cc[i] * a : ~i.indexOf("%") ? parseFloat(i) * a / 100 : parseFloat(i) || 0;
            return s ? (o.left + l) / he.innerWidth : (o.top + l) / he.innerHeight
        }, r.killAll = function(n) {
            if (se.slice(0).forEach(function(s) {
                return s.vars.id !== "ScrollSmoother" && s.kill()
            }), n !== !0) {
                var i = Ar.killAll || [];
                Ar = {},
                i.forEach(function(s) {
                    return s()
                })
            }
        }, r
    }();
ee.version = "3.12.5";
ee.saveStyles = function(r) {
    return r ? Wa(r).forEach(function(t) {
        if (t && t.style) {
            var e = Zn.indexOf(t);
            e >= 0 && Zn.splice(e, 5),
            Zn.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), wt.core.getCache(t), ad())
        }
    }) : Zn
};
ee.revert = function(r, t) {
    return vf(!r, t)
};
ee.create = function(r, t) {
    return new ee(r, t)
};
ee.refresh = function(r) {
    return r ? fa() : (so || ee.register()) && mr(!0)
};
ee.update = function(r) {
    return ++oe.cache && gs(r === !0 ? 2 : 0)
};
ee.clearScrollMemory = I0;
ee.maxScroll = function(r, t) {
    return ki(r, t ? Nn : Je)
};
ee.getScrollFunc = function(r, t) {
    return Zs(Bn(r), t ? Nn : Je)
};
ee.getById = function(r) {
    return cd[r]
};
ee.getAll = function() {
    return se.filter(function(r) {
        return r.vars.id !== "ScrollSmoother"
    })
};
ee.isScrolling = function() {
    return !!gi
};
ee.snapDirectional = xf;
ee.addEventListener = function(r, t) {
    var e = Ar[r] || (Ar[r] = []);
    ~e.indexOf(t) || e.push(t)
};
ee.removeEventListener = function(r, t) {
    var e = Ar[r],
        n = e && e.indexOf(t);
    n >= 0 && e.splice(n, 1)
};
ee.batch = function(r, t) {
    var e = [],
        n = {},
        i = t.interval || .016,
        s = t.batchMax || 1e9,
        o = function(c, h) {
            var u = [],
                d = [],
                f = wt.delayedCall(i, function() {
                    h(u, d),
                    u = [],
                    d = []
                }).pause();
            return function(m) {
                u.length || f.restart(!0),
                u.push(m.trigger),
                d.push(m),
                s <= u.length && f.progress(1)
            }
        },
        a;
    for (a in t)
        n[a] = a.substr(0, 2) === "on" && In(t[a]) && a !== "onRefreshInit" ? o(a, t[a]) : t[a];
    return In(s) && (s = s(), sn(ee, "refresh", function() {
        return s = t.batchMax()
    })), Wa(r).forEach(function(l) {
        var c = {};
        for (a in n)
            c[a] = n[a];
        c.trigger = l,
        e.push(ee.create(c))
    }), e
};
var km = function(t, e, n, i) {
        return e > i ? t(i) : e < 0 && t(0), n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
    },
    Xh = function r(t, e) {
        e === !0 ? t.style.removeProperty("touch-action") : t.style.touchAction = e === !0 ? "auto" : e ? "pan-" + e + (We.isTouch ? " pinch-zoom" : "") : "none",
        t === bi && r(Ie, e)
    },
    Wl = {
        auto: 1,
        scroll: 1
    },
    yR = function(t) {
        var e = t.event,
            n = t.target,
            i = t.axis,
            s = (e.changedTouches ? e.changedTouches[0] : e).target,
            o = s._gsap || wt.core.getCache(s),
            a = vn(),
            l;
        if (!o._isScrollT || a - o._isScrollT > 2e3) {
            for (; s && s !== Ie && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(Wl[(l = di(s)).overflowY] || Wl[l.overflowX]));)
                s = s.parentNode;
            o._isScroll = s && s !== n && !wr(s) && (Wl[(l = di(s)).overflowY] || Wl[l.overflowX]),
            o._isScrollT = a
        }
        (o._isScroll || i === "x") && (e.stopPropagation(), e._gsapAllow = !0)
    },
    O0 = function(t, e, n, i) {
        return We.create({
            target: t,
            capture: !0,
            debounce: !1,
            lockAxis: !0,
            type: e,
            onWheel: i = i && yR,
            onPress: i,
            onDrag: i,
            onScroll: i,
            onEnable: function() {
                return n && sn(ze, We.eventTypes[0], Vm, !1, !0)
            },
            onDisable: function() {
                return nn(ze, We.eventTypes[0], Vm, !0)
            }
        })
    },
    MR = /(input|label|select|textarea)/i,
    Hm,
    Vm = function(t) {
        var e = MR.test(t.target.tagName);
        (e || Hm) && (t._gsapAllow = !0, Hm = e)
    },
    SR = function(t) {
        ur(t) || (t = {}),
        t.preventDefault = t.isNormalizer = t.allowClicks = !0,
        t.type || (t.type = "wheel,touch"),
        t.debounce = !!t.debounce,
        t.id = t.id || "normalizer";
        var e = t,
            n = e.normalizeScrollX,
            i = e.momentum,
            s = e.allowNestedScroll,
            o = e.onRelease,
            a,
            l,
            c = Bn(t.target) || bi,
            h = wt.core.globals().ScrollSmoother,
            u = h && h.get(),
            d = Is && (t.content && Bn(t.content) || u && t.content !== !1 && !u.smooth() && u.content()),
            f = Zs(c, Je),
            m = Zs(c, Nn),
            _ = 1,
            g = (We.isTouch && he.visualViewport ? he.visualViewport.scale * he.visualViewport.width : he.outerWidth) / he.innerWidth,
            p = 0,
            x = In(i) ? function() {
                return i(a)
            } : function() {
                return i || 2.8
            },
            v,
            y,
            C = O0(c, t.type, !0, s),
            A = function() {
                return y = !1
            },
            T = Fi,
            R = Fi,
            E = function() {
                l = ki(c, Je),
                R = ba(Is ? 1 : 0, l),
                n && (T = ba(0, ki(c, Nn))),
                v = Sr
            },
            M = function() {
                d._gsap.y = ua(parseFloat(d._gsap.y) + f.offset) + "px",
                d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)",
                f.offset = f.cacheID = 0
            },
            D = function() {
                if (y) {
                    requestAnimationFrame(A);
                    var V = ua(a.deltaY / 2),
                        nt = R(f.v - V);
                    if (d && nt !== f.v + f.offset) {
                        f.offset = nt - f.v;
                        var P = ua((parseFloat(d && d._gsap.y) || 0) - f.offset);
                        d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + P + ", 0, 1)",
                        d._gsap.y = P + "px",
                        f.cacheID = oe.cache,
                        gs()
                    }
                    return !0
                }
                f.offset && M(),
                y = !0
            },
            I,
            k,
            $,
            j,
            G = function() {
                E(),
                I.isActive() && I.vars.scrollY > l && (f() > l ? I.progress(1) && f(l) : I.resetTo("scrollY", l))
            };
        return d && wt.set(d, {
            y: "+=0"
        }), t.ignoreCheck = function(H) {
            return Is && H.type === "touchmove" && D() || _ > 1.05 && H.type !== "touchstart" || a.isGesturing || H.touches && H.touches.length > 1
        }, t.onPress = function() {
            y = !1;
            var H = _;
            _ = ua((he.visualViewport && he.visualViewport.scale || 1) / g),
            I.pause(),
            H !== _ && Xh(c, _ > 1.01 ? !0 : n ? !1 : "x"),
            k = m(),
            $ = f(),
            E(),
            v = Sr
        }, t.onRelease = t.onGestureStart = function(H, V) {
            if (f.offset && M(), !V)
                j.restart(!0);
            else {
                oe.cache++;
                var nt = x(),
                    P,
                    ct;
                n && (P = m(), ct = P + nt * .05 * -H.velocityX / .227, nt *= km(m, P, ct, ki(c, Nn)), I.vars.scrollX = T(ct)),
                P = f(),
                ct = P + nt * .05 * -H.velocityY / .227,
                nt *= km(f, P, ct, ki(c, Je)),
                I.vars.scrollY = R(ct),
                I.invalidate().duration(nt).play(.01),
                (Is && I.vars.scrollY >= l || P >= l - 1) && wt.to({}, {
                    onUpdate: G,
                    duration: nt
                })
            }
            o && o(H)
        }, t.onWheel = function() {
            I._ts && I.pause(),
            vn() - p > 1e3 && (v = 0, p = vn())
        }, t.onChange = function(H, V, nt, P, ct) {
            if (Sr !== v && E(), V && n && m(T(P[2] === V ? k + (H.startX - H.x) : m() + V - P[1])), nt) {
                f.offset && M();
                var Ut = ct[2] === nt,
                    Zt = Ut ? $ + H.startY - H.y : f() + nt - ct[1],
                    J = R(Zt);
                Ut && Zt !== J && ($ += J - Zt),
                f(J)
            }
            (nt || V) && gs()
        }, t.onEnable = function() {
            Xh(c, n ? !1 : "x"),
            ee.addEventListener("refresh", G),
            sn(he, "resize", G),
            f.smooth && (f.target.style.scrollBehavior = "auto", f.smooth = m.smooth = !1),
            C.enable()
        }, t.onDisable = function() {
            Xh(c, !0),
            nn(he, "resize", G),
            ee.removeEventListener("refresh", G),
            C.kill()
        }, t.lockAxis = t.lockAxis !== !1, a = new We(t), a.iOS = Is, Is && !f() && f(1), Is && wt.ticker.add(Fi), j = a._dc, I = wt.to(a, {
            ease: "power4",
            paused: !0,
            inherit: !1,
            scrollX: n ? "+=0.1" : "+=0",
            scrollY: "+=0.1",
            modifiers: {
                scrollY: U0(f, f(), function() {
                    return I.pause()
                })
            },
            onUpdate: gs,
            onComplete: j.vars.onComplete
        }), a
    };
ee.sort = function(r) {
    return se.sort(r || function(t, e) {
        return (t.vars.refreshPriority || 0) * -1e6 + t.start - (e.start + (e.vars.refreshPriority || 0) * -1e6)
    })
};
ee.observe = function(r) {
    return new We(r)
};
ee.normalizeScroll = function(r) {
    if (typeof r > "u")
        return Cn;
    if (r === !0 && Cn)
        return Cn.enable();
    if (r === !1) {
        Cn && Cn.kill(),
        Cn = r;
        return
    }
    var t = r instanceof We ? r : SR(r);
    return Cn && Cn.target === t.target && Cn.kill(), wr(t.target) && (Cn = t), t
};
ee.core = {
    _getVelocityProp: sd,
    _inputObserver: O0,
    _scrollers: oe,
    _proxies: Gi,
    bridge: {
        ss: function() {
            gi || Cr("scrollStart"),
            gi = vn()
        },
        ref: function() {
            return xn
        }
    }
};
w0() && wt.registerPlugin(ee);
class TR {
    constructor(t)
    {
        this.element = document.querySelector(t),
        this.cards = this.element.querySelectorAll(".testimonial__card"),
        this.mm = on.matchMedia(),
        this.addAnimations()
    }
    destroy()
    {
        ee.getAll().forEach(t => {
            t.kill()
        })
    }
    addAnimations()
    {
        this.mm.add("(min-width: 651px)", () => {
            this.totalScrollHeight = 2 * window.innerHeight - this.cards[0].offsetHeight,
            this.positions = [22.5, 50, 77.5],
            this.rotations = [-15, 0, 15],
            ee.create({
                trigger: this.element,
                start: "top top",
                end: () => `+=${this.totalScrollHeight}`,
                pin: !0,
                pinSpacing: !0
            }),
            this.cards.forEach((t, e) => {
                on.to(t, {
                    left: `${this.positions[e]}%`,
                    rotation: `${this.rotations[e]}`,
                    ease: "none",
                    scrollTrigger: {
                        trigger: this.element,
                        start: "top top",
                        end: () => `+=${window.innerHeight}`,
                        scrub: .5
                    }
                })
            }),
            this.cards.forEach((t, e) => {
                const n = t.querySelector(".card__front"),
                    i = t.querySelector(".card__back"),
                    s = e * .05,
                    o = 1 / 3 + s,
                    a = 2 / 3 + s;
                ee.create({
                    trigger: this.element,
                    start: "top top",
                    end: () => `+=${this.totalScrollHeight}`,
                    scrub: 1,
                    onUpdate: l => {
                        const c = l.progress;
                        if (c > o && c < a) {
                            const h = (c - o) / .3333333333333333,
                                u = -180 * h,
                                d = 180 - 180 * h;
                            this.rotations[e] * (1 - h),
                            on.to(n, {
                                rotateY: d,
                                ease: "power1.out"
                            }),
                            on.to(i, {
                                rotateY: u,
                                ease: "power1.out"
                            })
                        }
                    }
                })
            })
        }),
        this.mm.add("(max-width: 650px)", () => {
            this.totalScrollHeight = window.innerHeight / 2,
            this.rotations = [-15, 0, 15],
            this.cards.forEach((t, e) => {
                const n = t.querySelector(".card__front"),
                    i = t.querySelector(".card__back");
                ee.create({
                    trigger: t,
                    start: "top 60%",
                    end: () => `+=${this.totalScrollHeight}`,
                    scrub: 1,
                    onUpdate: s => {
                        const a = s.progress,
                            l = -180 * a,
                            c = 180 - 180 * a;
                        this.rotations[e] * (1 - a),
                        on.to(n, {
                            rotateY: c,
                            ease: "power1.out"
                        }),
                        on.to(i, {
                            rotateY: l,
                            ease: "power1.out"
                        })
                    }
                })
            })
        })
    }
}
class ER extends Lr {
    constructor()
    {
        super()
    }
    addEventListeners()
    {
        this.gallery.addEventListeners()
    }
    removeEventListeners()
    {
        this.gallery.removeEventListeners()
    }
    onResize()
    {
        this.gallery.onResize()
    }
    update()
    {
        this.gallery.update()
    }
    create()
    {
        this.gallery = new d0(".home__work__slider-wrapper"),
        this.cards = new TR(".home__testimonials__list"),
        this.addEventListeners()
    }
    destroy()
    {
        this.removeEventListeners(),
        this.cards.destroy()
    }
}
class bR extends Lr {
    constructor()
    {
        super()
    }
    addSymbols() {}
    removeSymbols() {}
    addEventListeners()
    {
        this.gallery.addEventListeners()
    }
    removeEventListeners()
    {
        this.gallery.removeEventListeners()
    }
    update()
    {
        this.gallery.update()
    }
    create()
    {
        this.gallery = new d0(".work__work__slider-wrapper"),
        this.addEventListeners()
    }
    destroy()
    {
        this.removeEventListeners()
    }
}
class wR extends Lr {
    constructor()
    {
        super()
    }
    addEventListeners(t) {}
    update() {}
    create() {}
    destroy() {}
}
class AR extends Lr {
    constructor()
    {
        super()
    }
    addSymbols() {}
    removeSymbols() {}
    addEventListeners() {}
    removeEventListeners() {}
    update() {}
    create()
    {
        this.addEventListeners()
    }
    destroy()
    {
        this.removeEventListeners()
    }
}
class CR {
    constructor(t, e)
    {
        this.element = document.querySelector(t),
        e.on("scroll", this.onScroll.bind(this)),
        this.scrollDirection = 0
    }
    onScroll(t)
    {
        t.direction === 1 ? this.element.classList.add("hide") : this.element.classList.remove("hide")
    }
    changeIndicatorPosition(t)
    {
        t === "/case" && (t = "/work"),
        this.element.querySelectorAll("a").forEach(i => {
            i.classList.remove("active")
        }),
        this.element.querySelectorAll(`[data-route='${t}']`).forEach(i => {
            i.classList.add("active")
        })
    }
}
class RR extends Lr {
    constructor()
    {
        super()
    }
    addSymbols() {}
    removeSymbols() {}
    addEventListeners(t) {}
    update() {}
    create() {}
    destroy() {}
}
class PR extends Lr {
    constructor()
    {
        super()
    }
    addSymbols() {}
    removeSymbols() {}
    addEventListeners(t) {}
    update() {}
    create() {}
    destroy() {}
}
on.registerPlugin(ee);
class LR {
    constructor()
    {
        this.isChangingRoute = !1,
        window.location.pathname === "/en" ? this.template = "/" : window.location.pathname.includes("/case/") ? this.template = "/case" : this.template = window.location.pathname.replace("/en", ""),
        this.content = document.querySelector(".content"),
        this.header = document.querySelector(".header__navigation"),
        this.footer = document.querySelector(".footer__main"),
        this.privacy = document.getElementById("footerPrivacy"),
        this.metaLang = document.querySelector('meta[name="lang"]'),
        this.metaDescription = document.querySelector('meta[name="description"]'),
        this.metaOgTitle = document.querySelector('meta[property="og:title"]'),
        this.metaOgDescription = document.querySelector('meta[property="og:description"]'),
        this.metaOgUrl = document.querySelector('meta[property="og:url"]'),
        this.toggleBackgound = document.getElementById("background_toggle"),
        this.toggleBackgoundP = document.querySelector("#background_toggle p"),
        this.languageSwitcher = document.getElementById("language_switcher"),
        this.backgroundCanvasWrapper = document.getElementById("backgroundCanvas"),
        this.backToTop = document.getElementById("backToTop"),
        this.backgroundCanvas = new nw({
            dom: this.backgroundCanvasWrapper
        }),
        this.setupScroll(),
        this.frontCanvas = new nR({
            dom: document.getElementById("frontCanvas"),
            lenis: this.lenis
        }),
        this.createPages(),
        this.createNavigation(),
        this.createTransition(),
        this.addEventListeners(),
        this.addLinkListeners(),
        this.frontCanvas.addObjects(),
        this.update()
    }
    setupScroll()
    {
        this.lenis = new V0({
            prevent: t => t.classList.contains("pm__body")
        })
    }
    createNavigation()
    {
        this.navigation = new CR("header.header", this.lenis)
    }
    createPages()
    {
        this.pages = {
            "/": new ER,
            "/about": new sR,
            "/work": new bR,
            "/contact": new wR,
            "/case": new AR,
            "/privacy": new PR,
            notFound: new RR
        },
        this.page = this.pages[this.template],
        this.page || (this.page = this.pages.notFound),
        this.page.create(),
        this.page.show(),
        this.frontCanvas.show()
    }
    createTransition()
    {
        this.transition = new iR
    }
    onToggleBackgoundClick()
    {
        this.toggleBackgound.classList.toggle("disabled"),
        this.backgroundCanvasWrapper.classList.toggle("disabled")
    }
    onBackToTopClick()
    {
        this.lenis.scrollTo(0)
    }
    addEventListeners()
    {
        window.addEventListener("popstate", this.onPopState.bind(this)),
        window.addEventListener("resize", this.onResize.bind(this)),
        this.toggleBackgound.addEventListener("click", this.onToggleBackgoundClick.bind(this)),
        this.backToTop.addEventListener("click", this.onBackToTopClick.bind(this)),
        this.resizeObserver = new ResizeObserver(t => {
            this.frontCanvas.onResize()
        }),
        this.resizeObserver.observe(document.body)
    }
    onResize()
    {
        this.page && this.page.onResize && this.page.onResize(),
        this.frontCanvas.onResize()
    }
    async onChange({url: t, push: e=!0})
    {
        if (this.isChangingRoute)
            return;
        this.isChangingRoute = !0;
        const [n, i, s] = await Promise.all([this.page.hide(), this.frontCanvas.hide(), window.fetch(t)]);
        if (this.lenis.scrollTo(0), this.frontCanvas.removeObjects(), s.status === 200) {
            this.page.create(),
            t = t.replace(window.location.origin, "");
            const o = await s.text(),
                a = document.createElement("div");
            a.innerHTML = o;
            const l = a.querySelector(".content"),
                c = a.querySelector(".header__navigation"),
                h = a.querySelector("#background_toggle p"),
                u = a.querySelector("#backToTop"),
                d = a.querySelector("#footerPrivacy"),
                f = a.querySelector(".footer__main"),
                m = a.querySelector('meta[name="lang"]').getAttribute("content"),
                _ = a.querySelector("title"),
                g = a.querySelector('meta[name="description"]').getAttribute("content"),
                p = a.querySelector('meta[property="og:url"]').getAttribute("content"),
                x = a.querySelector("#language_switcher"),
                v = this.metaLang.getAttribute("content");
            this.content.innerHTML = l.innerHTML,
            v !== m && (this.header.innerHTML = c.innerHTML, this.footer.innerHTML = f.innerHTML, this.toggleBackgoundP.innerHTML = h.innerHTML, this.backToTop.innerHTML = u.innerHTML, this.privacy.innerHTML = d.innerHTML, this.privacy.href = d.href, document.documentElement.setAttribute("lang", m), this.metaLang.setAttribute("content", m), this.languageSwitcher = document.getElementById("language_switcher")),
            document.title = _.innerText,
            this.metaDescription.setAttribute("content", g),
            this.metaOgTitle.setAttribute("content", _.innerText),
            this.metaOgDescription.setAttribute("content", g),
            this.metaOgUrl.setAttribute("content", p),
            this.languageSwitcher.href = x.href,
            e && window.history.pushState({}, "", t);
            let y = window.location.pathname;
            y === "/en" ? this.template = "/" : y.includes("/case/") ? this.template = "/case" : this.template = y.replace("/en", "");
            const C = this.pages[this.template];
            this.page.destroy(),
            this.navigation.changeIndicatorPosition(this.template),
            this.page = C,
            this.page.create(),
            this.frontCanvas.addObjects(),
            this.page.show().then(() => {
                this.isChangingRoute = !1
            }),
            this.frontCanvas.show(),
            this.addLinkListeners()
        } else
            window.location.replace(t)
    }
    onPopState()
    {
        this.onChange({
            url: window.location.pathname,
            push: !1
        })
    }
    addLinkListeners()
    {
        const t = document.querySelectorAll("a");
        Array.from(t).forEach(e => {
            const n = e.href.indexOf(window.location.origin) > -1,
                i = e.href.indexOf("mailto") === -1,
                s = e.href.indexOf("tel") === -1;
            n ? e.onclick = o => {
                o.preventDefault(),
                this.onChange({
                    url: e.href
                })
            } : i && s && (e.rel = "noopener", e.target = "_blank")
        })
    }
    update(t)
    {
        this.lenis.raf(t),
        this.page && this.page.update && this.page.update(),
        this.frontCanvas.animate(t),
        this.frame = window.requestAnimationFrame(this.update.bind(this))
    }
}
new LR;
